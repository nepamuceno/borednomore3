{
    "rules_file": "prompt.md",
    "custom_file": "custom.md",
    "prompt_md_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
    "custom_prompt_content": "i return to my  old workable version of borednomore3.py\nnow \n$ for i in ../debian/src/lxqt/wallpapers/*.jpg; do pcmanfm-qt --set-wallpaper \"$i\" --wallpaper-mode=stretch --desktop; done\nworks, is there a faster way for pacmanfm.qt to run",
    "context_files": [
        {
            "path": "/home/deb/borednomore3/borednomore3/ask-viejo/ai_engines.json",
            "enabled": false,
            "pinned": false
        },
        {
            "path": "/home/deb/borednomore3/borednomore3/ask-viejo/custom.md",
            "enabled": false,
            "pinned": false
        },
        {
            "path": "/home/deb/borednomore3/borednomore3/ask-viejo/prompt.md",
            "enabled": false,
            "pinned": false
        },
        {
            "path": "/home/deb/borednomore3/borednomore3/ask-viejo/ask.py",
            "enabled": false,
            "pinned": false
        },
        {
            "path": "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c",
            "enabled": true,
            "pinned": false
        }
    ],
    "inc_rules": false,
    "inc_context": false,
    "history": [
        {
            "id": 1768965772.92257,
            "time": "2026-01-20 21:22:52",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "i return to my  old workable version of borednomore3.py\nnow \n$ for i in ../debian/src/lxqt/wallpapers/*.jpg; do pcmanfm-qt --set-wallpaper \"$i\" --wallpaper-mode=stretch --desktop; done\nworks, is there a faster way for pacmanfm.qt to run",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "i return to my  old workable version of borednomore3.py\nnow \n$ for i in ../debian/src/lxqt/wallpapers/*.jpg; do pcmanfm-qt --set-wallpaper \"$i\" --wallpaper-mode=stretch --desktop; done\nworks, is there a faster way for pacmanfm.qt to run",
            "pinned": false
        },
        {
            "id": 1768962807.66341,
            "time": "2026-01-20 20:33:27",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "deb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ pcmanfm-qt --desktop &\n[2] 287702\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\n[2]+  Done                    pcmanfm-qt --desktop\n\n\nicons restored but wallpapers now does not change",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ pcmanfm-qt --desktop &\n[2] 287702\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\n[2]+  Done                    pcmanfm-qt --desktop\n\n\nicons restored but wallpapers now does not change\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n *\n * Slideshow mode: animate multiple wallpapers via X11 without corrupting pcmanfm-qt.\n * Fixes BadGC errors by freeing pixmaps and images properly.\n * Only syncs config once at the end if requested.\n *\n * Author: Nepamuceno\n * Version: 2.6.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(Display *dpy, Window root, const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\nint run_slideshow(int argc, char **argv);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr,\n            \"Usage:\\n\"\n            \"  %s <image> [--sync-config]\\n\"\n            \"  %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\",\n            argv[0], argv[0]);\n        return 1;\n    }\n\n    if (strcmp(argv[1], \"--slideshow\") == 0) {\n        return run_slideshow(argc, argv);\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n\n    int result = set_wallpaper_x11(dpy, root, filename);\n    XCloseDisplay(dpy);\n\n    if (result != 0) {\n        return result;\n    }\n\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            if (update_config_silent(abs_path) != 0) {\n                fprintf(stderr, \"Warning: Failed to update pcmanfm-qt config safely\\n\");\n            }\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint run_slideshow(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\", argv[0]);\n        return 1;\n    }\n\n    double delay = atof(argv[2]);\n    int sync_config = 0;\n    int last_arg = argc - 1;\n\n    if (strcmp(argv[last_arg], \"--sync-config\") == 0) {\n        sync_config = 1;\n        argc--; // exclude flag from images\n    }\n\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n\n    for (int i = 3; i < argc; i++) {\n        const char *filename = argv[i];\n        if (!file_exists(filename)) {\n            fprintf(stderr, \"Skipping missing file: %s\\n\", filename);\n            continue;\n        }\n        set_wallpaper_x11(dpy, root, filename);\n        usleep((useconds_t)(delay * 1000000));\n    }\n\n    if (sync_config) {\n        const char *last_file = argv[argc - 1];\n        char *abs_path = get_absolute_path(last_file);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    XCloseDisplay(dpy);\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(Display *dpy, Window root, const char *filename) {\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image(); // free original\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image(); // free scaled image\n    XFreePixmap(dpy, pix); // free pixmap to avoid BadGC\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    int fout_fd = fileno(fout);\n    if (flock(fout_fd, LOCK_EX) != 0) {\n        fclose(fin);\n        fclose(fout);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fflush(fout);\n    fsync(fout_fd);\n    flock(fout_fd, LOCK_UN);\n\n    fclose(fin);\n    fclose(fout);\n\n    if (rename(temp_path, config_path) != 0) {\n        perror(\"rename\");\n        unlink(temp_path);\n        return 1;\n    }\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n    int result = set_wallpaper_x11(dpy, root, image_path);\n    XCloseDisplay(dpy);\n    return result;\n}\n",
            "pinned": false
        },
        {
            "id": 1768962799.767016,
            "time": "2026-01-20 20:33:19",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "deb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ pcmanfm-qt --desktop &\n[2] 287702\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\n[2]+  Done                    pcmanfm-qt --desktop\n\n\nicons restored but wallpapers now does not change",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ pcmanfm-qt --desktop &\n[2] 287702\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\n^C\n[2]+  Done                    pcmanfm-qt --desktop\n\n\nicons restored but wallpapers now does not change\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n *\n * Slideshow mode: animate multiple wallpapers via X11 without corrupting pcmanfm-qt.\n * Fixes BadGC errors by freeing pixmaps and images properly.\n * Only syncs config once at the end if requested.\n *\n * Author: Nepamuceno\n * Version: 2.6.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(Display *dpy, Window root, const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\nint run_slideshow(int argc, char **argv);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr,\n            \"Usage:\\n\"\n            \"  %s <image> [--sync-config]\\n\"\n            \"  %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\",\n            argv[0], argv[0]);\n        return 1;\n    }\n\n    if (strcmp(argv[1], \"--slideshow\") == 0) {\n        return run_slideshow(argc, argv);\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n\n    int result = set_wallpaper_x11(dpy, root, filename);\n    XCloseDisplay(dpy);\n\n    if (result != 0) {\n        return result;\n    }\n\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            if (update_config_silent(abs_path) != 0) {\n                fprintf(stderr, \"Warning: Failed to update pcmanfm-qt config safely\\n\");\n            }\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint run_slideshow(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\", argv[0]);\n        return 1;\n    }\n\n    double delay = atof(argv[2]);\n    int sync_config = 0;\n    int last_arg = argc - 1;\n\n    if (strcmp(argv[last_arg], \"--sync-config\") == 0) {\n        sync_config = 1;\n        argc--; // exclude flag from images\n    }\n\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n\n    for (int i = 3; i < argc; i++) {\n        const char *filename = argv[i];\n        if (!file_exists(filename)) {\n            fprintf(stderr, \"Skipping missing file: %s\\n\", filename);\n            continue;\n        }\n        set_wallpaper_x11(dpy, root, filename);\n        usleep((useconds_t)(delay * 1000000));\n    }\n\n    if (sync_config) {\n        const char *last_file = argv[argc - 1];\n        char *abs_path = get_absolute_path(last_file);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    XCloseDisplay(dpy);\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(Display *dpy, Window root, const char *filename) {\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image(); // free original\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image(); // free scaled image\n    XFreePixmap(dpy, pix); // free pixmap to avoid BadGC\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    int fout_fd = fileno(fout);\n    if (flock(fout_fd, LOCK_EX) != 0) {\n        fclose(fin);\n        fclose(fout);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fflush(fout);\n    fsync(fout_fd);\n    flock(fout_fd, LOCK_UN);\n\n    fclose(fin);\n    fclose(fout);\n\n    if (rename(temp_path, config_path) != 0) {\n        perror(\"rename\");\n        unlink(temp_path);\n        return 1;\n    }\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n    int result = set_wallpaper_x11(dpy, root, image_path);\n    XCloseDisplay(dpy);\n    return result;\n}\n",
            "pinned": false
        },
        {
            "id": 1768962514.024542,
            "time": "2026-01-20 20:28:34",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\n\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\nX Error of failed request:  BadGC (invalid GC parameter)\n  Major opcode of failed request:  130 (MIT-SHM)\n  Minor opcode of failed request:  3 (X_ShmPutImage)\n  Resource id in failed request:  0x1600002\n  Serial number of failed request:  13\n  Current serial number in output stream:  14",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\n\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\nX Error of failed request:  BadGC (invalid GC parameter)\n  Major opcode of failed request:  130 (MIT-SHM)\n  Minor opcode of failed request:  3 (X_ShmPutImage)\n  Resource id in failed request:  0x1600002\n  Serial number of failed request:  13\n  Current serial number in output stream:  14\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n *\n * Adds slideshow mode: animate multiple wallpapers via X11 without corrupting pcmanfm-qt.\n * Reuses X11 display across frames and frees pixmaps to avoid BadGC errors.\n * Only syncs config once at the end if requested.\n *\n * Author: Nepamuceno\n * Version: 2.5.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(Display *dpy, Window root, const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\nint run_slideshow(int argc, char **argv);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr,\n            \"Usage:\\n\"\n            \"  %s <image> [--sync-config]\\n\"\n            \"  %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\",\n            argv[0], argv[0]);\n        return 1;\n    }\n\n    if (strcmp(argv[1], \"--slideshow\") == 0) {\n        return run_slideshow(argc, argv);\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n\n    int result = set_wallpaper_x11(dpy, root, filename);\n    XCloseDisplay(dpy);\n\n    if (result != 0) {\n        return result;\n    }\n\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            if (update_config_silent(abs_path) != 0) {\n                fprintf(stderr, \"Warning: Failed to update pcmanfm-qt config safely\\n\");\n            }\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint run_slideshow(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\", argv[0]);\n        return 1;\n    }\n\n    double delay = atof(argv[2]);\n    int sync_config = 0;\n    int last_arg = argc - 1;\n\n    if (strcmp(argv[last_arg], \"--sync-config\") == 0) {\n        sync_config = 1;\n        argc--; // exclude flag from images\n    }\n\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n\n    for (int i = 3; i < argc; i++) {\n        const char *filename = argv[i];\n        if (!file_exists(filename)) {\n            fprintf(stderr, \"Skipping missing file: %s\\n\", filename);\n            continue;\n        }\n        set_wallpaper_x11(dpy, root, filename);\n        usleep((useconds_t)(delay * 1000000));\n    }\n\n    if (sync_config) {\n        const char *last_file = argv[argc - 1];\n        char *abs_path = get_absolute_path(last_file);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    XCloseDisplay(dpy);\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(Display *dpy, Window root, const char *filename) {\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XFreePixmap(dpy, pix); // free pixmap to avoid BadGC\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    int fout_fd = fileno(fout);\n    if (flock(fout_fd, LOCK_EX) != 0) {\n        fclose(fin);\n        fclose(fout);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fflush(fout);\n    fsync(fout_fd);\n    flock(fout_fd, LOCK_UN);\n\n    fclose(fin);\n    fclose(fout);\n\n    if (rename(temp_path, config_path) != 0) {\n        perror(\"rename\");\n        unlink(temp_path);\n        return 1;\n    }\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        return 1;\n    }\n    Window root = DefaultRootWindow(dpy);\n    int result = set_wallpaper_x11(dpy, root, image_path\n",
            "pinned": false
        },
        {
            "id": 1768962423.615775,
            "time": "2026-01-20 20:27:03",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\n\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\nX Error of failed request:  BadGC (invalid GC parameter)\n  Major opcode of failed request:  130 (MIT-SHM)\n  Minor opcode of failed request:  3 (X_ShmPutImage)\n  Resource id in failed request:  0x1600002\n  Serial number of failed request:  13\n  Current serial number in output stream:  14",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\n\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ./native-setwallpaper --slideshow 0.7 ../debian/src/lxqt/wallpapers/*.jpg --sync-config\nX Error of failed request:  BadGC (invalid GC parameter)\n  Major opcode of failed request:  130 (MIT-SHM)\n  Minor opcode of failed request:  3 (X_ShmPutImage)\n  Resource id in failed request:  0x1600002\n  Serial number of failed request:  13\n  Current serial number in output stream:  14\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Adds slideshow mode: animate multiple wallpapers via X11 without corrupting pcmanfm-qt.\n * Only syncs config once at the end if requested.\n * \n * Author: Nepamuceno\n * Version: 2.4.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\nint run_slideshow(int argc, char **argv);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr,\n            \"Usage:\\n\"\n            \"  %s <image> [--sync-config]\\n\"\n            \"  %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\",\n            argv[0], argv[0]);\n        return 1;\n    }\n\n    if (strcmp(argv[1], \"--slideshow\") == 0) {\n        return run_slideshow(argc, argv);\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    int result = set_wallpaper_x11(filename);\n    if (result != 0) {\n        return result;\n    }\n\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            if (update_config_silent(abs_path) != 0) {\n                fprintf(stderr, \"Warning: Failed to update pcmanfm-qt config safely\\n\");\n            }\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint run_slideshow(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s --slideshow <delay_seconds> <image1> <image2> ... [--sync-config]\\n\", argv[0]);\n        return 1;\n    }\n\n    double delay = atof(argv[2]);\n    int sync_config = 0;\n    int last_arg = argc - 1;\n\n    if (strcmp(argv[last_arg], \"--sync-config\") == 0) {\n        sync_config = 1;\n        argc--; // exclude flag from images\n    }\n\n    for (int i = 3; i < argc; i++) {\n        const char *filename = argv[i];\n        if (!file_exists(filename)) {\n            fprintf(stderr, \"Skipping missing file: %s\\n\", filename);\n            continue;\n        }\n        set_wallpaper_x11(filename);\n        usleep((useconds_t)(delay * 1000000));\n    }\n\n    if (sync_config) {\n        const char *last_file = argv[argc - 1];\n        char *abs_path = get_absolute_path(last_file);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    int fout_fd = fileno(fout);\n    if (flock(fout_fd, LOCK_EX) != 0) {\n        fclose(fin);\n        fclose(fout);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fflush(fout);\n    fsync(fout_fd);\n    flock(fout_fd, LOCK_UN);\n\n    fclose(fin);\n    fclose(fout);\n\n    if (rename(temp_path, config_path) != 0) {\n        perror(\"rename\");\n        unlink(temp_path);\n        return 1;\n    }\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768962135.19436,
            "time": "2026-01-20 20:22:15",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\nProblem this is a slide show, animation app to set a wallpaper, need to set a wallaper after another so all animation looks flawless\nif is too slow or pacmanfm-qt quits the i will have a bad animation",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\nProblem this is a slide show, animation app to set a wallpaper, need to set a wallaper after another so all animation looks flawless\nif is too slow or pacmanfm-qt quits the i will have a bad animation\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Sets wallpaper directly via X11/Imlib2 (fast, no flicker)\n * Optionally updates pcmanfm-qt config without reload signal\n * \n * Author: Nepamuceno\n * Version: 2.3.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image> [--sync-config]\\n\", argv[0]);\n        fprintf(stderr, \"  --sync-config: Update pcmanfm-qt config (no reload signal)\\n\");\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    // Check for --sync-config flag\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via X11 (fast, direct)\n    int result = set_wallpaper_x11(filename);\n    \n    if (result != 0) {\n        return result;\n    }\n\n    // Only sync config when explicitly requested\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            if (update_config_silent(abs_path) != 0) {\n                fprintf(stderr, \"Warning: Failed to update pcmanfm-qt config safely\\n\");\n            }\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    int fout_fd = fileno(fout);\n    if (flock(fout_fd, LOCK_EX) != 0) {\n        fclose(fin);\n        fclose(fout);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fflush(fout);\n    fsync(fout_fd);\n    flock(fout_fd, LOCK_UN);\n\n    fclose(fin);\n    fclose(fout);\n\n    if (rename(temp_path, config_path) != 0) {\n        perror(\"rename\");\n        unlink(temp_path); // cleanup temp file if rename fails\n        return 1;\n    }\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768961869.192027,
            "time": "2026-01-20 20:17:49",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nstill i broke pacmanfm-qt, goes to a blank desktop randomly\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Sets wallpaper directly via X11/Imlib2 (fast, no flicker)\n * Optionally updates pcmanfm-qt config without reload signal\n * \n * Author: Nepamuceno\n * Version: 2.2.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image> [--sync-config]\\n\", argv[0]);\n        fprintf(stderr, \"  --sync-config: Update pcmanfm-qt config (no reload signal)\\n\");\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    // Check for --sync-config flag\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via X11 (fast, direct)\n    int result = set_wallpaper_x11(filename);\n    \n    if (result != 0) {\n        return result;\n    }\n\n    // Optionally sync config (silent, no SIGHUP)\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    // Lock to avoid race conditions\n    int fout_fd = fileno(fout);\n    flock(fout_fd, LOCK_EX);\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fflush(fout);\n    fsync(fout_fd);   // ensure data is flushed to disk\n    flock(fout_fd, LOCK_UN);\n\n    fclose(fin);\n    fclose(fout);\n\n    if (rename(temp_path, config_path) != 0) {\n        perror(\"rename\");\n        return 1;\n    }\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768961704.582261,
            "time": "2026-01-20 20:15:04",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nmodify script to run only 10 files\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do \n    ./native-setwallpaper \"$i\"\n    sleep 0.7\ndone\n\n# Sync only final wallpaper to pcmanfm-qt\nlast=$(ls ../debian/src/lxqt/wallpapers/*.jpg | tail -n1)\n./native-setwallpaper \"$last\" --sync-config",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nmodify script to run only 10 files\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do \n    ./native-setwallpaper \"$i\"\n    sleep 0.7\ndone\n\n# Sync only final wallpaper to pcmanfm-qt\nlast=$(ls ../debian/src/lxqt/wallpapers/*.jpg | tail -n1)\n./native-setwallpaper \"$last\" --sync-config\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Sets wallpaper directly via X11/Imlib2 (fast, no flicker)\n * Optionally updates pcmanfm-qt config without reload signal\n * \n * Author: Nepamuceno\n * Version: 2.1.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image> [--sync-config]\\n\", argv[0]);\n        fprintf(stderr, \"  --sync-config: Update pcmanfm-qt config (no reload signal)\\n\");\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    // Check for --sync-config flag\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via X11 (fast, direct)\n    int result = set_wallpaper_x11(filename);\n    \n    if (result != 0) {\n        return result;\n    }\n\n    // Optionally sync config (silent, no SIGHUP)\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fclose(fin);\n    fclose(fout);\n\n    rename(temp_path, config_path);\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768961698.918295,
            "time": "2026-01-20 20:14:58",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nmodify script to run only 10 files\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do \n    ./native-setwallpaper \"$i\"\n    sleep 0.7\ndone\n\n# Sync only final wallpaper to pcmanfm-qt\nlast=$(ls ../debian/src/lxqt/wallpapers/*.jpg | tail -n1)\n./native-setwallpaper \"$last\" --sync-config",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n5. Always give me complete full files\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nmodify script to run only 10 files\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do \n    ./native-setwallpaper \"$i\"\n    sleep 0.7\ndone\n\n# Sync only final wallpaper to pcmanfm-qt\nlast=$(ls ../debian/src/lxqt/wallpapers/*.jpg | tail -n1)\n./native-setwallpaper \"$last\" --sync-config\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Sets wallpaper directly via X11/Imlib2 (fast, no flicker)\n * Optionally updates pcmanfm-qt config without reload signal\n * \n * Author: Nepamuceno\n * Version: 2.1.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image> [--sync-config]\\n\", argv[0]);\n        fprintf(stderr, \"  --sync-config: Update pcmanfm-qt config (no reload signal)\\n\");\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    // Check for --sync-config flag\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via X11 (fast, direct)\n    int result = set_wallpaper_x11(filename);\n    \n    if (result != 0) {\n        return result;\n    }\n\n    // Optionally sync config (silent, no SIGHUP)\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fclose(fin);\n    fclose(fout);\n\n    rename(temp_path, config_path);\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768961347.287359,
            "time": "2026-01-20 20:09:07",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nHow can we fix this?",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt\n\n---\n\nfor i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nHow can we fix this?\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Sets wallpaper directly via X11/Imlib2 (fast, no flicker)\n * Optionally updates pcmanfm-qt config without reload signal\n * \n * Author: Nepamuceno\n * Version: 2.1.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image> [--sync-config]\\n\", argv[0]);\n        fprintf(stderr, \"  --sync-config: Update pcmanfm-qt config (no reload signal)\\n\");\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    // Check for --sync-config flag\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via X11 (fast, direct)\n    int result = set_wallpaper_x11(filename);\n    \n    if (result != 0) {\n        return result;\n    }\n\n    // Optionally sync config (silent, no SIGHUP)\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fclose(fin);\n    fclose(fout);\n\n    rename(temp_path, config_path);\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768961338.89581,
            "time": "2026-01-20 20:08:58",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1.  pacman-fm halts execution\n2. feh is not suported in my lubuntu\n3. we only gone work in native-setwallpaper.c\n4. Focus in not to corrupt pcmanfm-qt",
            "custom_used": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nHow can we fix this?",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "for i in ../debian/src/lxqt/wallpapers/*.jpg; do ./native-setwallpaper \"$i\" --sync-config;sleep 0.7;done\ndeb@deb-hp205g3aio:~/borednomore3/borednomore3/setwallpaper$ ls\nai-engine.md    benchmark.py  Makefile             native-setwallpaper.c   prompt.md       wallpaper_adapter.py\napp_state.json  custom.md     native-setwallpaper  native-setwallpaper.so  setwallpaper.c\n\nproblem pacmanfm-qt gets corrupted\n\nHow can we fix this?\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * native-setwallpaper.c - X11 direct wallpaper setter with optional config sync\n * \n * Sets wallpaper directly via X11/Imlib2 (fast, no flicker)\n * Optionally updates pcmanfm-qt config without reload signal\n * \n * Author: Nepamuceno\n * Version: 2.1.0\n * License: MIT\n */\n\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n#include <Imlib2.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 8192\n\n// Function prototypes\nint set_wallpaper_x11(const char *filename);\nint update_config_silent(const char *image_path);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image> [--sync-config]\\n\", argv[0]);\n        fprintf(stderr, \"  --sync-config: Update pcmanfm-qt config (no reload signal)\\n\");\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    int sync_config = 0;\n\n    // Check for --sync-config flag\n    if (argc > 2 && strcmp(argv[2], \"--sync-config\") == 0) {\n        sync_config = 1;\n    }\n\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File '%s' not found\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via X11 (fast, direct)\n    int result = set_wallpaper_x11(filename);\n    \n    if (result != 0) {\n        return result;\n    }\n\n    // Optionally sync config (silent, no SIGHUP)\n    if (sync_config) {\n        char *abs_path = get_absolute_path(filename);\n        if (abs_path) {\n            update_config_silent(abs_path);\n            free(abs_path);\n        }\n    }\n\n    return 0;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    return realpath(path, NULL);\n}\n\nint set_wallpaper_x11(const char *filename) {\n    Display *dpy = XOpenDisplay(NULL);\n    if (!dpy) {\n        fprintf(stderr, \"Failed to open X11 display\\n\");\n        return 1;\n    }\n\n    Window root = DefaultRootWindow(dpy);\n    Imlib_Image img = imlib_load_image(filename);\n    if (!img) {\n        fprintf(stderr, \"Failed to load image: %s\\n\", filename);\n        XCloseDisplay(dpy);\n        return 1;\n    }\n\n    imlib_context_set_display(dpy);\n    imlib_context_set_visual(DefaultVisual(dpy, DefaultScreen(dpy)));\n    imlib_context_set_colormap(DefaultColormap(dpy, DefaultScreen(dpy)));\n    imlib_context_set_drawable(root);\n    imlib_context_set_image(img);\n\n    int screen = DefaultScreen(dpy);\n    int width = DisplayWidth(dpy, screen);\n    int height = DisplayHeight(dpy, screen);\n\n    Imlib_Image scaled = imlib_create_cropped_scaled_image(\n        0, 0,\n        imlib_image_get_width(), imlib_image_get_height(),\n        width, height\n    );\n    imlib_free_image();\n    imlib_context_set_image(scaled);\n\n    Pixmap pix = XCreatePixmap(dpy, root, width, height,\n                               DefaultDepth(dpy, screen));\n    imlib_context_set_drawable(pix);\n    imlib_render_image_on_drawable(0, 0);\n\n    Atom prop = XInternAtom(dpy, \"_XROOTPMAP_ID\", False);\n    XChangeProperty(dpy, root, prop, XA_PIXMAP, 32, PropModeReplace,\n                    (unsigned char *)&pix, 1);\n\n    XSetWindowBackgroundPixmap(dpy, root, pix);\n    XClearWindow(dpy, root);\n    XFlush(dpy);\n\n    imlib_free_image();\n    XCloseDisplay(dpy);\n\n    return 0;\n}\n\nint update_config_silent(const char *image_path) {\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        return 1;\n    }\n\n    char config_path[MAX_LINE];\n    char temp_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    FILE *fin = fopen(config_path, \"r\");\n    if (!fin) {\n        return 1;\n    }\n\n    FILE *fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fclose(fin);\n        return 1;\n    }\n\n    char line[MAX_LINE];\n    int wallpaper_found = 0;\n\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fclose(fin);\n    fclose(fout);\n\n    rename(temp_path, config_path);\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    return set_wallpaper_x11(image_path);\n}\n",
            "pinned": false
        },
        {
            "id": 1768959492.090029,
            "time": "2026-01-20 19:38:12",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.",
            "custom_used": "$ make all\ngcc -Wall -O3 -fPIC -o native-setwallpaper native-setwallpaper.c -lX11 -lImlib2\nnative-setwallpaper.c: In function \u2018signal_pcmanfm_reload\u2019:\nnative-setwallpaper.c:179:9: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  179 |         system(\"pcmanfm-qt --desktop &\");\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnative-setwallpaper.c:184:5: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  184 |     system(\"dbus-send --session --type=method_call --dest=org.lxqt.session /LXQtSession org.lxqt.session.reloadSettings 2>/dev/null\");\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ngcc -Wall -O3 -fPIC -shared -o native-setwallpaper.so native-setwallpaper.c -lX11 -lImlib2\nnative-setwallpaper.c: In function \u2018signal_pcmanfm_reload\u2019:\nnative-setwallpaper.c:179:9: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  179 |         system(\"pcmanfm-qt --desktop &\");\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnative-setwallpaper.c:184:5: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  184 |     system(\"dbus-send --session --type=method_call --dest=org.lxqt.session /LXQtSession org.lxqt.session.reloadSettings 2>/dev/null\");\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c"
            ],
            "full_content": "$ make all\ngcc -Wall -O3 -fPIC -o native-setwallpaper native-setwallpaper.c -lX11 -lImlib2\nnative-setwallpaper.c: In function \u2018signal_pcmanfm_reload\u2019:\nnative-setwallpaper.c:179:9: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  179 |         system(\"pcmanfm-qt --desktop &\");\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnative-setwallpaper.c:184:5: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  184 |     system(\"dbus-send --session --type=method_call --dest=org.lxqt.session /LXQtSession org.lxqt.session.reloadSettings 2>/dev/null\");\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ngcc -Wall -O3 -fPIC -shared -o native-setwallpaper.so native-setwallpaper.c -lX11 -lImlib2\nnative-setwallpaper.c: In function \u2018signal_pcmanfm_reload\u2019:\nnative-setwallpaper.c:179:9: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  179 |         system(\"pcmanfm-qt --desktop &\");\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnative-setwallpaper.c:184:5: warning: ignoring return value of \u2018system\u2019 declared with attribute \u2018warn_unused_result\u2019 [-Wunused-result]\n  184 |     system(\"dbus-send --session --type=method_call --dest=org.lxqt.session /LXQtSession org.lxqt.session.reloadSettings 2>/dev/null\");\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n---\n\n\n[Filename: native-setwallpaper.c]\n[Path: /home/deb/borednomore3/borednomore3/setwallpaper/native-setwallpaper.c]\n/*\n * setwallpaper.c - LXQt/pcmanfm-qt compatible wallpaper setter\n * \n * This version updates the pcmanfm-qt config file and signals it to reload\n * instead of directly manipulating X11 root window.\n * \n * Author: Nepamuceno\n * Version: 2.0.0\n * License: MIT\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <libgen.h>\n#include <dirent.h>\n\n// Config file path for pcmanfm-qt\n#define CONFIG_PATH_TEMPLATE \"%s/.config/pcmanfm-qt/lxqt/settings.conf\"\n#define TEMP_SUFFIX \".tmp\"\n#define MAX_LINE 4096\n\n// Function prototypes\nint set_wallpaper_pcmanfm(const char *image_path);\nint update_config_file(const char *config_path, const char *image_path);\nint signal_pcmanfm_reload(void);\nint file_exists(const char *path);\nchar* get_absolute_path(const char *path);\n\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <image_path>\\n\", argv[0]);\n        fprintf(stderr, \"Example: %s /path/to/wallpaper.jpg\\n\", argv[0]);\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    \n    // Verify file exists\n    if (!file_exists(filename)) {\n        fprintf(stderr, \"Error: File not found: %s\\n\", filename);\n        return 1;\n    }\n\n    // Get absolute path\n    char *abs_path = get_absolute_path(filename);\n    if (!abs_path) {\n        fprintf(stderr, \"Error: Could not resolve absolute path for: %s\\n\", filename);\n        return 1;\n    }\n\n    // Set wallpaper via pcmanfm-qt method\n    int result = set_wallpaper_pcmanfm(abs_path);\n    \n    free(abs_path);\n    \n    if (result == 0) {\n        // Only print to stderr, not stdout (for silent operation)\n        // fprintf(stderr, \"Wallpaper set successfully\\n\");\n    } else {\n        fprintf(stderr, \"Failed to set wallpaper\\n\");\n    }\n    \n    return result;\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return (stat(path, &st) == 0 && S_ISREG(st.st_mode));\n}\n\nchar* get_absolute_path(const char *path) {\n    char *abs_path = realpath(path, NULL);\n    return abs_path;\n}\n\nint set_wallpaper_pcmanfm(const char *image_path) {\n    // Get home directory\n    const char *home = getenv(\"HOME\");\n    if (!home) {\n        fprintf(stderr, \"Error: HOME environment variable not set\\n\");\n        return 1;\n    }\n\n    // Build config path\n    char config_path[MAX_LINE];\n    snprintf(config_path, sizeof(config_path), CONFIG_PATH_TEMPLATE, home);\n\n    // Update config file\n    if (update_config_file(config_path, image_path) != 0) {\n        return 1;\n    }\n\n    // Signal pcmanfm-qt to reload\n    if (signal_pcmanfm_reload() != 0) {\n        fprintf(stderr, \"Warning: Could not signal pcmanfm-qt to reload\\n\");\n        // Don't fail - the change was written, pcmanfm will pick it up eventually\n    }\n\n    return 0;\n}\n\nint update_config_file(const char *config_path, const char *image_path) {\n    FILE *fin, *fout;\n    char line[MAX_LINE];\n    char temp_path[MAX_LINE];\n    int wallpaper_found = 0;\n\n    // Create temp file path\n    snprintf(temp_path, sizeof(temp_path), \"%s%s\", config_path, TEMP_SUFFIX);\n\n    // Open files\n    fin = fopen(config_path, \"r\");\n    if (!fin) {\n        fprintf(stderr, \"Error: Could not open config file: %s\\n\", config_path);\n        return 1;\n    }\n\n    fout = fopen(temp_path, \"w\");\n    if (!fout) {\n        fprintf(stderr, \"Error: Could not create temp file: %s\\n\", temp_path);\n        fclose(fin);\n        return 1;\n    }\n\n    // Copy file, replacing Wallpaper= line\n    while (fgets(line, sizeof(line), fin)) {\n        if (strncmp(line, \"Wallpaper=\", 10) == 0) {\n            fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n            wallpaper_found = 1;\n        } else {\n            fputs(line, fout);\n        }\n    }\n\n    // If Wallpaper= wasn't found, append it\n    if (!wallpaper_found) {\n        fprintf(fout, \"Wallpaper=%s\\n\", image_path);\n    }\n\n    fclose(fin);\n    fclose(fout);\n\n    // Replace original with temp\n    if (rename(temp_path, config_path) != 0) {\n        fprintf(stderr, \"Error: Could not update config file\\n\");\n        unlink(temp_path);\n        return 1;\n    }\n\n    return 0;\n}\n\nint signal_pcmanfm_reload(void) {\n    // Method 1: Send SIGHUP to pcmanfm-qt process\n    FILE *cmd = popen(\"pgrep -x pcmanfm-qt\", \"r\");\n    if (!cmd) {\n        return 1;\n    }\n\n    char pid_str[32];\n    int found_process = 0;\n    \n    while (fgets(pid_str, sizeof(pid_str), cmd)) {\n        pid_t pid = atoi(pid_str);\n        if (pid > 0) {\n            // Send SIGHUP to reload\n            kill(pid, SIGHUP);\n            found_process = 1;\n        }\n    }\n    pclose(cmd);\n\n    if (!found_process) {\n        // pcmanfm-qt not running, try to start it\n        system(\"pcmanfm-qt --desktop &\");\n        usleep(500000); // Wait 500ms for it to start\n    }\n\n    // Method 2: Also try dbus method as backup\n    system(\"dbus-send --session --type=method_call --dest=org.lxqt.session /LXQtSession org.lxqt.session.reloadSettings 2>/dev/null\");\n\n    return 0;\n}\n\n// Shared library entry point\n__attribute__((visibility(\"default\")))\nint set_wallpaper_universal(const char *image_path) {\n    if (!image_path || !file_exists(image_path)) {\n        return 1;\n    }\n\n    char *abs_path = get_absolute_path(image_path);\n    if (!abs_path) {\n        return 1;\n    }\n\n    int result = set_wallpaper_pcmanfm(abs_path);\n    free(abs_path);\n    \n    return result;\n}\n",
            "pinned": false
        },
        {
            "id": 1768935293.025358,
            "time": "2026-01-20 12:54:53",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.",
            "custom_used": "still have to hold right-click in order to select, if i release right-click the moue pick's up the item where the cursor is sitting in, that is not right and sucks ass, and add a few more themes",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/ask-viejo/ask-beta.py"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.\n\n---\n\nstill have to hold right-click in order to select, if i release right-click the moue pick's up the item where the cursor is sitting in, that is not right and sucks ass, and add a few more themes\n\n---\n\n\n[Filename: ask-beta.py]\n[Path: /home/deb/borednomore3/borednomore3/ask-viejo/ask-beta.py]\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox\nimport customtkinter as ctk\nimport os\nimport subprocess\nimport datetime\nimport json\nimport webbrowser\nimport signal\nimport sys\nimport platform\n\n# Configuraci\u00f3n inicial de apariencia\nctk.set_appearance_mode(\"dark\")\nctk.set_default_color_theme(\"blue\")\n\nclass ModernPromptGUI:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Prompt Engine \u2022 Ultra Modern\")\n        self.root.geometry(\"1280x850\")\n        self.root.minsize(1000, 750)\n        \n        print(f\"[{datetime.datetime.now()}] Initializing ModernPromptGUI...\")\n        \n        # Captura de CTRL+C (SIGINT)\n        signal.signal(signal.SIGINT, self.signal_handler)\n        \n        self.files = []\n        self.history = []\n        \n        # Inclusion Switches Variables\n        self.include_rules_var = tk.BooleanVar(value=True)\n        self.include_context_var = tk.BooleanVar(value=True)\n        \n        # Default Paths\n        self.prompt_md_path = \"prompt.md\"\n        self.custom_prompt_default = \"custom.md\"\n        self.state_file = \"app_state.json\"\n        \n        # Track current working files for tabs\n        self.current_rules_file = self.prompt_md_path\n        self.current_custom_file = self.custom_prompt_default\n        \n        # AI Engines\n        self.ai_engines_path = \"ai_engines.json\"\n        self.ai_engines_data = []\n        self.engine_rows = []\n        \n        # Carga inicial de datos base si existen\n        self.load_initial_content()\n        \n        # Create widgets with proper mouse support\n        self.create_widgets()\n        \n        # Seleccionar pesta\u00f1a Custom Prompt por defecto al iniciar\n        self.tabview.set(\"Custom Prompt\")\n        \n        # Manejo de cierre de ventana\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n        \n        # Cargar estado guardado\n        if os.path.exists(self.state_file):\n            self.load_state()\n        else:\n            self.auto_load_default_files()\n        \n        # Timer de auto-salvado (5 minutos)\n        self.root.after(300000, self.auto_save)\n        \n        # Setup comprehensive mouse support\n        self.setup_comprehensive_mouse_support()\n        \n        print(f\"[{datetime.datetime.now()}] GUI Ready with comprehensive mouse support.\")\n    \n    def setup_comprehensive_mouse_support(self):\n        \"\"\"Setup comprehensive desktop-like mouse support throughout the application\"\"\"\n        \n        # Global mouse wheel support with smooth scrolling\n        self.root.bind_all(\"<MouseWheel>\", self.global_mouse_wheel_handler, add=\"+\")\n        self.root.bind_all(\"<Button-4>\", self.global_mouse_wheel_handler, add=\"+\")  # Linux scroll up\n        self.root.bind_all(\"<Button-5>\", self.global_mouse_wheel_handler, add=\"+\")  # Linux scroll down\n        \n        # Global right-click support\n        self.root.bind_all(\"<Button-3>\", self.global_right_click_handler, add=\"+\")\n        \n        # Auto-scroll support for text widgets\n        self.setup_auto_scroll_support()\n        \n        # Enhanced hover effects\n        self.setup_hover_effects()\n        \n        # Text selection support\n        self.setup_text_selection_support()\n    \n    def global_mouse_wheel_handler(self, event):\n        \"\"\"Handle mouse wheel scrolling globally with smooth acceleration\"\"\"\n        widget = event.widget\n        \n        # Determine scroll direction and amount\n        if event.delta:\n            # Windows/Mac\n            scroll_amount = -1 * (event.delta // 120)\n        else:\n            # Linux\n            scroll_amount = -1 if event.num == 4 else 1\n        \n        # Enhanced scroll handling for different widget types\n        if hasattr(widget, 'yview'):\n            # Smooth scrolling with acceleration\n            widget.yview_scroll(scroll_amount * 3, \"units\")\n            self.apply_smooth_scroll(widget, scroll_amount)\n        elif hasattr(widget, 'canvasy'):\n            # Handle canvas widgets\n            widget.yview_scroll(scroll_amount * 3, \"units\")\n            self.apply_smooth_scroll(widget, scroll_amount)\n        \n        return \"break\"\n    \n    def apply_smooth_scroll(self, widget, direction):\n        \"\"\"Apply smooth scrolling with momentum\"\"\"\n        # Add momentum effect\n        for i in range(1, 4):\n            delay = i * 10  # milliseconds\n            widget.after(delay, lambda w=widget, d=direction, m=i: \n                        w.yview_scroll(d * m // 2, \"units\") if hasattr(w, 'yview') else None)\n    \n    def setup_auto_scroll_support(self):\n        \"\"\"Setup auto-scroll when cursor approaches edges during selection\"\"\"\n        \n        def auto_scroll_motion(event):\n            \"\"\"Handle mouse motion for auto-scroll\"\"\"\n            widget = event.widget\n            \n            if not isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                return\n            \n            # Get widget dimensions\n            width = widget.winfo_width()\n            height = widget.winfo_height()\n            \n            # Auto-scroll zones (pixels from edge)\n            scroll_zone = 30\n            \n            # Check if mouse is near edges\n            if event.y < scroll_zone:\n                # Near top - scroll up\n                widget.yview_scroll(-1, \"units\")\n            elif event.y > height - scroll_zone:\n                # Near bottom - scroll down\n                widget.yview_scroll(1, \"units\")\n            \n            # Horizontal auto-scroll (optional)\n            if event.x < scroll_zone:\n                widget.xview_scroll(-1, \"units\")\n            elif event.x > width - scroll_zone:\n                widget.xview_scroll(1, \"units\")\n        \n        # Bind to all text widgets\n        for widget in [self.prompt_editor, self.custom_prompt]:\n            widget.bind(\"<Motion>\", auto_scroll_motion, add=\"+\")\n    \n    def setup_hover_effects(self):\n        \"\"\"Setup hover effects for interactive elements\"\"\"\n        \n        def on_enter(event):\n            \"\"\"Handle mouse enter\"\"\"\n            widget = event.widget\n            if isinstance(widget, (ctk.CTkButton, tk.Button)):\n                # Store original color\n                if not hasattr(widget, '_original_fg'):\n                    try:\n                        widget._original_fg = widget.cget('fg_color')\n                        # Lighten color for hover\n                        widget.configure(fg_color=self.lighten_color(widget._original_fg))\n                    except:\n                        pass\n            elif isinstance(widget, (ctk.CTkLabel, tk.Label)):\n                # Change cursor for clickable labels\n                widget.configure(cursor=\"hand2\")\n        \n        def on_leave(event):\n            \"\"\"Handle mouse leave\"\"\"\n            widget = event.widget\n            if isinstance(widget, (ctk.CTkButton, tk.Button)):\n                # Restore original color\n                if hasattr(widget, '_original_fg'):\n                    widget.configure(fg_color=widget._original_fg)\n            elif isinstance(widget, (ctk.CTkLabel, tk.Label)):\n                # Reset cursor\n                widget.configure(cursor=\"\")\n        \n        # Bind to all buttons and labels\n        self.root.bind_all(\"<Enter>\", on_enter, add=\"+\")\n        self.root.bind_all(\"<Leave>\", on_leave, add=\"+\")\n    \n    def setup_text_selection_support(self):\n        \"\"\"Enhanced text selection support\"\"\"\n        \n        def double_click_select_word(event):\n            \"\"\"Double-click to select word\"\"\"\n            widget = event.widget\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                # Get click position\n                index = widget.index(f\"@{event.x},{event.y}\")\n                widget.mark_set(\"insert\", index)\n                \n                # Select word at cursor\n                start = widget.index(f\"{index} wordstart\")\n                end = widget.index(f\"{index} wordend\")\n                widget.tag_remove(\"sel\", \"1.0\", \"end\")\n                widget.tag_add(\"sel\", start, end)\n        \n        def triple_click_select_line(event):\n            \"\"\"Triple-click to select line\"\"\"\n            widget = event.widget\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                # Get click position\n                index = widget.index(f\"@{event.x},{event.y}\")\n                \n                # Select entire line\n                line_start = widget.index(f\"{index} linestart\")\n                line_end = widget.index(f\"{index} lineend\")\n                widget.tag_remove(\"sel\", \"1.0\", \"end\")\n                widget.tag_add(\"sel\", line_start, line_end)\n        \n        # Bind double and triple click\n        self.root.bind_all(\"<Double-Button-1>\", double_click_select_word, add=\"+\")\n        self.root.bind_all(\"<Triple-Button-1>\", triple_click_select_line, add=\"+\")\n    \n    def global_right_click_handler(self, event):\n        \"\"\"Handle right-click globally for context menus\"\"\"\n        widget = event.widget\n        \n        # Focus the widget\n        try:\n            widget.focus_set()\n        except:\n            pass\n        \n        # Handle different widget types\n        if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n            self.show_enhanced_text_context_menu(event, widget)\n        elif isinstance(widget, (tk.Entry, ctk.CTkEntry)):\n            self.show_entry_context_menu(event, widget)\n        elif isinstance(widget, (ctk.CTkButton, tk.Button)):\n            self.show_button_context_menu(event, widget)\n        elif isinstance(widget, (ctk.CTkLabel, tk.Label)):\n            self.show_label_context_menu(event, widget)\n        else:\n            self.show_generic_context_menu(event, widget)\n        \n        return \"break\"\n    \n    def show_enhanced_text_context_menu(self, event, widget):\n        \"\"\"Enhanced context menu for text widgets with desktop-like behavior\"\"\"\n        # Create menu for this specific widget\n        menu = tk.Menu(widget, tearoff=0, \n                      bg=\"gray20\", fg=\"white\", \n                      activebackground=\"#3b8ed0\", \n                      borderwidth=0)\n        \n        # FIXED: Proper clipboard operations\n        def cut_text():\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                try:\n                    if widget.tag_ranges(\"sel\"):\n                        selected = widget.get(\"sel.first\", \"sel.last\")\n                        self.root.clipboard_clear()\n                        self.root.clipboard_append(selected)\n                        widget.delete(\"sel.first\", \"sel.last\")\n                        self.set_status(\"Text cut to clipboard\")\n                    else:\n                        # Cut current line if no selection\n                        current_line = widget.index(\"insert\").split('.')[0]\n                        line_start = f\"{current_line}.0\"\n                        line_end = f\"{current_line}.end\"\n                        line_text = widget.get(line_start, line_end)\n                        if line_text:\n                            self.root.clipboard_clear()\n                            self.root.clipboard_append(line_text)\n                            widget.delete(line_start, line_end)\n                            self.set_status(\"Line cut to clipboard\")\n                except Exception as e:\n                    print(f\"Cut error: {e}\")\n        \n        def copy_text():\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                try:\n                    if widget.tag_ranges(\"sel\"):\n                        selected = widget.get(\"sel.first\", \"sel.last\")\n                        self.root.clipboard_clear()\n                        self.root.clipboard_append(selected)\n                        self.set_status(\"Text copied to clipboard\")\n                    else:\n                        # Copy current line if no selection\n                        current_line = widget.index(\"insert\").split('.')[0]\n                        line_start = f\"{current_line}.0\"\n                        line_end = f\"{current_line}.end\"\n                        line_text = widget.get(line_start, line_end)\n                        if line_text:\n                            self.root.clipboard_clear()\n                            self.root.clipboard_append(line_text)\n                            self.set_status(\"Line copied to clipboard\")\n                except Exception as e:\n                    print(f\"Copy error: {e}\")\n        \n        def paste_text():\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                try:\n                    clipboard_content = self.root.clipboard_get()\n                    widget.insert(\"insert\", clipboard_content)\n                    self.set_status(\"Text pasted from clipboard\")\n                except Exception as e:\n                    print(f\"Paste error: {e}\")\n        \n        def select_all_text():\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                try:\n                    widget.tag_add(\"sel\", \"1.0\", \"end\")\n                    widget.mark_set(\"insert\", \"end\")\n                    self.set_status(\"All text selected\")\n                except Exception as e:\n                    print(f\"Select all error: {e}\")\n        \n        def clear_all_text():\n            if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n                try:\n                    widget.delete(\"1.0\", \"end\")\n                    self.set_status(\"All text cleared\")\n                except Exception as e:\n                    print(f\"Clear all error: {e}\")\n        \n        # Add working menu items\n        menu.add_command(label=\"Cut\", command=cut_text)\n        menu.add_command(label=\"Copy\", command=copy_text)\n        menu.add_command(label=\"Paste\", command=paste_text)\n        menu.add_separator()\n        menu.add_command(label=\"Select All\", command=select_all_text)\n        \n        # Enhanced commands for text widgets\n        if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n            menu.add_separator()\n            menu.add_command(label=\"Clear All\", command=clear_all_text)\n        \n        # FIXED: Show menu at exact cursor position without holding requirement\n        try:\n            widget.focus_set()\n            menu.tk_popup(event.x_root, event.y_root)\n            # FIXED: Don't call grab_release - let the menu handle its own lifecycle\n        except Exception as e:\n            print(f\"Menu show error: {e}\")\n    \n    def show_entry_context_menu(self, event, widget):\n        \"\"\"Context menu for entry widgets\"\"\"\n        menu = tk.Menu(widget, tearoff=0, \n                      bg=\"gray20\", fg=\"white\", \n                      activebackground=\"#3b8ed0\", \n                      borderwidth=0)\n        \n        def cut_entry():\n            try:\n                if widget.selection_present():\n                    selected = widget.selection_get()\n                    self.root.clipboard_clear()\n                    self.root.clipboard_append(selected)\n                    widget.delete(\"sel.first\", \"sel.last\")\n                else:\n                    # Cut all if no selection\n                    content = widget.get()\n                    self.root.clipboard_clear()\n                    self.root.clipboard_append(content)\n                    widget.delete(0, tk.END)\n            except Exception as e:\n                print(f\"Entry cut error: {e}\")\n        \n        def copy_entry():\n            try:\n                if widget.selection_present():\n                    selected = widget.selection_get()\n                    self.root.clipboard_clear()\n                    self.root.clipboard_append(selected)\n                else:\n                    # Copy all if no selection\n                    content = widget.get()\n                    self.root.clipboard_clear()\n                    self.root.clipboard_append(content)\n            except Exception as e:\n                print(f\"Entry copy error: {e}\")\n        \n        def paste_entry():\n            try:\n                clipboard_content = self.root.clipboard_get()\n                widget.insert(\"insert\", clipboard_content)\n            except Exception as e:\n                print(f\"Entry paste error: {e}\")\n        \n        def select_all_entry():\n            try:\n                widget.select_range(0, tk.END)\n                widget.focus_set()\n            except Exception as e:\n                print(f\"Entry select all error: {e}\")\n        \n        menu.add_command(label=\"Cut\", command=cut_entry)\n        menu.add_command(label=\"Copy\", command=copy_entry)\n        menu.add_command(label=\"Paste\", command=paste_entry)\n        menu.add_separator()\n        menu.add_command(label=\"Select All\", command=select_all_entry)\n        \n        try:\n            widget.focus_set()\n            menu.tk_popup(event.x_root, event.y_root)\n        except Exception as e:\n            print(f\"Entry menu error: {e}\")\n    \n    def show_button_context_menu(self, event, widget):\n        \"\"\"Context menu for buttons\"\"\"\n        menu = tk.Menu(widget, tearoff=0, \n                      bg=\"gray20\", fg=\"white\", \n                      activebackground=\"#3b8ed0\", \n                      borderwidth=0)\n        \n        # Get button text\n        try:\n            button_text = widget.cget('text')\n            menu.add_command(label=f\"Copy: {button_text[:30]}...\", \n                           command=lambda: self.copy_to_clipboard(button_text))\n        except:\n            menu.add_command(label=\"Copy Button Text\", \n                           command=lambda: self.copy_to_clipboard(\"Button\"))\n        \n        menu.add_separator()\n        menu.add_command(label=\"Button Info\", \n                        command=lambda: messagebox.showinfo(\"Button Info\", f\"Button: {button_text}\"))\n        \n        try:\n            menu.tk_popup(event.x_root, event.y_root)\n        except Exception as e:\n            print(f\"Button menu error: {e}\")\n    \n    def show_label_context_menu(self, event, widget):\n        \"\"\"Context menu for labels\"\"\"\n        menu = tk.Menu(widget, tearoff=0, \n                      bg=\"gray20\", fg=\"white\", \n                      activebackground=\"#3b8ed0\", \n                      borderwidth=0)\n        \n        # Get label text\n        try:\n            label_text = widget.cget('text')\n            if label_text and len(label_text) > 0:\n                menu.add_command(label=f\"Copy: {label_text[:30]}...\", \n                               command=lambda: self.copy_to_clipboard(label_text))\n            else:\n                menu.add_command(label=\"Copy Label Text\", \n                               command=lambda: self.copy_to_clipboard(\"Label\"))\n        except:\n            menu.add_command(label=\"Copy Label Text\", \n                           command=lambda: self.copy_to_clipboard(\"Label\"))\n        \n        menu.add_separator()\n        menu.add_command(label=\"Label Info\", \n                        command=lambda: messagebox.showinfo(\"Label Info\", f\"Label: {label_text}\"))\n        \n        try:\n            menu.tk_popup(event.x_root, event.y_root)\n        except Exception as e:\n            print(f\"Label menu error: {e}\")\n    \n    def show_generic_context_menu(self, event, widget):\n        \"\"\"Generic context menu for other widgets\"\"\"\n        menu = tk.Menu(widget, tearoff=0, \n                      bg=\"gray20\", fg=\"white\", \n                      activebackground=\"#3b8ed0\", \n                      borderwidth=0)\n        \n        menu.add_command(label=\"Refresh UI\", command=self.refresh_ui)\n        menu.add_command(label=\"Copy Position\", \n                        command=lambda: self.copy_to_clipboard(f\"X:{event.x}, Y:{event.y}\"))\n        \n        try:\n            menu.tk_popup(event.x_root, event.y_root)\n        except Exception as e:\n            print(f\"Generic menu error: {e}\")\n    \n    def refresh_ui(self):\n        \"\"\"Refresh the UI\"\"\"\n        self.refresh_file_list_ui()\n        self.refresh_history_ui()\n        self.refresh_ai_list()\n    \n    def lighten_color(self, color):\n        \"\"\"Lighten a color for hover effects\"\"\"\n        if isinstance(color, str) and color.startswith('#'):\n            try:\n                # Simple color lightening\n                r = int(color[1:3], 16)\n                g = int(color[3:5], 16)\n                b = int(color[5:7], 16)\n                \n                # Lighten by 30%\n                r = min(255, r + 30)\n                g = min(255, g + 30)\n                b = min(255, b + 30)\n                \n                return f\"#{r:02x}{g:02x}{b:02x}\"\n            except:\n                return color\n        return color\n\n    # [Keep all the existing methods from the previous version]\n    def load_initial_content(self):\n        \"\"\"Carga contenido inicial de archivos base o los crea si no existen\"\"\"\n        # Asegurar existencia de archivos m\u00ednimos\n        for fpath in [self.prompt_md_path, self.custom_prompt_default]:\n            if not os.path.exists(fpath):\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(\"\") # Crear vac\u00edo\n        \n        if os.path.exists(self.prompt_md_path):\n            with open(self.prompt_md_path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_md_content = f.read()\n        \n        # Prioridad absoluta a ai_engines.json\n        if os.path.exists(self.ai_engines_path):\n            try:\n                with open(self.ai_engines_path, \"r\", encoding=\"utf-8\") as f:\n                    self.ai_engines_data = json.load(f)\n                print(f\"[{datetime.datetime.now()}] Engines loaded from {self.ai_engines_path}\")\n            except Exception as e:\n                print(f\"DEBUG: Error loading ai_engines.json: {e}\")\n\n    def create_widgets(self):\n        \"\"\"Create widgets with proper mouse support using tkinter's built-in functionality\"\"\"\n        # FIXED: Corrected malformed hex color code - removed extra 'd'\n        self.tabview = ctk.CTkTabview(self.root,\n                                      segmented_button_selected_color=\"#3b8ed0\",\n                                      segmented_button_unselected_color=\"#222\",\n                                      segmented_button_selected_hover_color=\"#4fa3e0\")  # FIXED: Was \"#4fa3ed0\"\n        self.tabview.pack(fill=\"both\", expand=True, padx=20, pady=20)\n        \n        self.tab_rules = self.tabview.add(\"\u270f Prompt Rules\")\n        self.tab_custom = self.tabview.add(\"Custom Prompt\")\n        self.tab_files = self.tabview.add(\"Context Files\")\n        self.tab_ai = self.tabview.add(\"AI Engines\")\n        self.tab_history = self.tabview.add(\"History\")\n        \n        # --- Tab: Prompt Rules ---\n        self.lbl_rules_file = ctk.CTkLabel(self.tab_rules, text=f\"Base System Prompt ({self.current_rules_file})\", \n                                          font=(\"Inter\", 14, \"bold\"), text_color=\"#3b8ed0\")\n        self.lbl_rules_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.prompt_editor = ctk.CTkTextbox(self.tab_rules, font=(\"JetBrains Mono\", 13), \n                                           border_width=2, border_color=\"#333\", undo=True)\n        self.prompt_editor.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        \n        # Add proper context menu to text widget - FIXED MOUSE SUPPORT\n        self.add_proper_context_menu(self.prompt_editor)\n        \n        btn_rules_frame = ctk.CTkFrame(self.tab_rules, fg_color=\"transparent\")\n        btn_rules_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_rules_frame, text=\"Save\", width=100, fg_color=\"#2fa572\", \n                     hover_color=\"#218c59\", command=self.save_prompt_md).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Save As...\", width=100, \n                     command=self.save_rules_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Load\", width=100, \n                     command=self.load_rules_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Clear\", width=100, \n                     command=lambda: self.prompt_editor.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Undo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.prompt_editor.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Redo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.prompt_editor.edit_redo()).pack(side=\"right\", padx=5)\n        \n        # --- Tab: Custom Prompt ---\n        # FIXED: Use theme variables instead of hardcoded colors\n        self.tab_custom.configure(fg_color=ctk.ThemeManager.theme[\"CTk\"][\"fg_color\"])\n        \n        self.lbl_custom_file = ctk.CTkLabel(self.tab_custom, \n                                           text=f\"Current Task ({self.current_custom_file})\", \n                                           font=(\"Inter\", 14, \"bold\"), \n                                           text_color=ctk.ThemeManager.theme[\"CTkLabel\"][\"text_color\"])\n        self.lbl_custom_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.custom_prompt = ctk.CTkTextbox(self.tab_custom, font=(\"JetBrains Mono\", 14), \n                                           border_width=2, \n                                           border_color=ctk.ThemeManager.theme[\"CTkTextbox\"][\"border_color\"], \n                                           undo=True, \n                                           fg_color=ctk.ThemeManager.theme[\"CTkTextbox\"][\"fg_color\"])\n        self.custom_prompt.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        \n        # Add proper context menu to text widget - FIXED MOUSE SUPPORT\n        self.add_proper_context_menu(self.custom_prompt)\n        \n        btn_custom_frame = ctk.CTkFrame(self.tab_custom, fg_color=\"transparent\")\n        btn_custom_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_custom_frame, text=\"Save Task\", width=120, fg_color=\"#2fa572\", \n                     hover_color=\"#218c59\", font=(\"Inter\", 12, \"bold\"), \n                     command=self.save_custom_prompt).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Save As...\", width=100, \n                     command=self.save_custom_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Load\", width=100, \n                     command=self.load_custom_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Clear\", width=100, \n                     command=lambda: self.custom_prompt.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Undo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.custom_prompt.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Redo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.custom_prompt.edit_redo()).pack(side=\"right\", padx=5)\n        \n        # --- Tab: Context Files ---\n        # FIXED: Use theme variables instead of hardcoded colors\n        files_header = ctk.CTkFrame(self.tab_files, fg_color=ctk.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"])\n        files_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        \n        ctk.CTkLabel(files_header, text=\"INC\", font=(\"Inter\", 11, \"bold\"), width=30).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(files_header, text=\"PIN\", font=(\"Inter\", 11, \"bold\"), width=40).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FILENAME\", font=(\"Inter\", 11, \"bold\"), width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FULL SYSTEM PATH\", font=(\"Inter\", 11, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        self.files_scroll = ctk.CTkScrollableFrame(self.tab_files, label_text=\"\")\n        self.files_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_files_frame = ctk.CTkFrame(self.tab_files, fg_color=\"transparent\")\n        btn_files_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_files_frame, text=\"Add File\", command=self.add_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_files_frame, text=\"Clear Unpinned\", command=self.clear_files).pack(side=\"left\", padx=5)\n        \n        # --- Tab: AI Engines ---\n        # FIXED: Use theme variables instead of hardcoded colors\n        ai_table_header = ctk.CTkFrame(self.tab_ai, fg_color=ctk.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"])\n        ai_table_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        \n        ctk.CTkLabel(ai_table_header, text=\"URL\", font=(\"Inter\", 12, \"bold\"), width=400, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(ai_table_header, text=\"Description\", font=(\"Inter\", 12, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=35)\n        \n        self.ai_scroll = ctk.CTkScrollableFrame(self.tab_ai, label_text=\"\")\n        self.ai_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_ai_frame = ctk.CTkFrame(self.tab_ai, fg_color=\"transparent\")\n        btn_ai_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_ai_frame, text=\"Save Engines\", width=120, fg_color=\"#2fa572\", \n                     command=self.save_ai_engines).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Save As...\", width=100, \n                     command=self.save_ai_engines_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Load File\", width=100, \n                     command=self.load_ai_engines_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Add Row\", fg_color=\"#1f538d\", \n                     hover_color=\"darkgreen\", width=100, command=self.add_ai_row).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Clear All\", width=100, \n                     command=self.clear_ai_engines).pack(side=\"left\", padx=5)\n        \n        self.refresh_ai_list()\n        \n        # --- Tab: History ---\n        self.setup_history_header()\n        \n        self.history_scroll = ctk.CTkScrollableFrame(self.tab_history, \n                                                    label_text=\"Prompt History Log\", \n                                                    label_text_color=\"#3b8ed0\")\n        self.history_scroll.pack(fill=\"both\", expand=True, padx=12, pady=12)\n        \n        btn_hist_frame = ctk.CTkFrame(self.tab_history, fg_color=\"transparent\")\n        btn_hist_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_hist_frame, text=\"Clear All History\", \n                     command=self.clear_history).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_hist_frame, text=\"Save History As...\", \n                     command=self.save_history_as).pack(side=\"left\", padx=5)\n        \n        # Bottom Action Bar\n        # FIXED: Use theme variables instead of hardcoded colors\n        self.bottom_frame = ctk.CTkFrame(self.root, height=80, border_width=1, \n                                        border_color=ctk.ThemeManager.theme[\"CTkFrame\"][\"border_color\"], \n                                        fg_color=ctk.ThemeManager.theme[\"CTkFrame\"][\"fg_color\"])\n        self.bottom_frame.pack(fill=\"x\", side=\"bottom\", padx=20, pady=20)\n        \n        self.cb_rules = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Rules\", \n                                       variable=self.include_rules_var, \n                                       command=self.save_state)\n        self.cb_rules.pack(side=\"left\", padx=10)\n        \n        self.cb_context = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Context\", \n                                         variable=self.include_context_var, \n                                         command=self.save_state)\n        self.cb_context.pack(side=\"left\", padx=10)\n        \n        ctk.CTkButton(self.bottom_frame, text=\"\ud83d\ude80 GENERATE PROMPT & COPY TO CLIPBOARD\", \n                     fg_color=\"#2fa572\", hover_color=\"#218c59\", font=(\"Inter\", 14, \"bold\"), \n                     command=self.generate_prompt).pack(side=\"left\", padx=20)\n        \n        ctk.CTkButton(self.bottom_frame, text=\"EXIT\", fg_color=\"#b02a37\", \n                     hover_color=\"#8c1c27\", width=60, command=self.on_close).pack(side=\"right\", padx=10)\n        \n        self.theme_menu = ctk.CTkOptionMenu(self.bottom_frame, \n                                           values=[\"Dark\", \"Light\", \"System\"], \n                                           width=100, command=self.change_theme)\n        self.theme_menu.pack(side=\"right\", padx=10)\n        \n        self.status_label = ctk.CTkLabel(self.bottom_frame, text=\"Ready\", \n                                        font=(\"Inter\", 12), \n                                        text_color=ctk.ThemeManager.theme[\"CTkLabel\"][\"text_color\"])\n        self.status_label.pack(side=\"right\", padx=20)\n\n    # [Keep all the existing methods from the previous version, but I'll add the missing ones]\n    def add_proper_context_menu(self, widget):\n        \"\"\"Legacy method - now replaced by global_right_click_handler\"\"\"\n        pass  # This is now handled globally\n\n    def handle_mouse_wheel(self, event, widget):\n        \"\"\"Legacy method - now replaced by global_mouse_wheel_handler\"\"\"\n        pass  # This is now handled globally\n\n    def setup_history_header(self):\n        \"\"\"Setup history header\"\"\"\n        header_frame = ctk.CTkFrame(self.tab_history, fg_color=\"#222\", height=30)\n        header_frame.pack(fill=\"x\", padx=12, pady=(10, 0))\n        \n        ctk.CTkLabel(header_frame, text=\"TYPE\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(header_frame, text=\"PIN\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(header_frame, text=\"DATE/TIME\", font=(\"Inter\", 10, \"bold\"), width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(header_frame, text=\"TASK PREVIEW / CONTENT\", font=(\"Inter\", 10, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=20)\n\n    def auto_load_default_files(self):\n        \"\"\"Carga archivos espec\u00edficos al contexto si no hay estado previo\"\"\"\n        defaults = [self.ai_engines_path, self.state_file, self.custom_prompt_default, self.prompt_md_path]\n        for path in defaults:\n            abs_path = os.path.abspath(path)\n            if not os.path.exists(abs_path): continue\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=True)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n                self.refresh_file_list_ui()\n\n    def signal_handler(self, sig, frame):\n        \"\"\"Maneja CTRL+C salvando el estado antes de interrumpir\"\"\"\n        print(f\"\\n[{datetime.datetime.now()}] INTERRUPT (Ctrl+C). Saving state...\")\n        self.save_state()\n        sys.exit(0)\n\n    def change_theme(self, new_theme):\n        \"\"\"Cambia el modo de apariencia.\"\"\"\n        ctk.set_appearance_mode(new_theme.lower())\n        self.save_state()\n\n    def add_file(self):\n        \"\"\"Add file with proper mouse support\"\"\"\n        paths = filedialog.askopenfilenames()\n        for path in paths:\n            abs_path = os.path.abspath(path)\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=False)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n                self.refresh_file_list_ui()\n                self.save_state()\n\n    def toggle_pin(self, path):\n        \"\"\"Toggle file pinning\"\"\"\n        self.save_state()\n        self.refresh_file_list_ui()\n\n    def remove_file(self, path):\n        \"\"\"Remove file\"\"\"\n        self.files = [f for f in self.files if f['path'] != path]\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    def refresh_file_list_ui(self):\n        \"\"\"Refresh file list UI\"\"\"\n        for widget in self.files_scroll.winfo_children():\n            widget.destroy()\n        \n        for f_obj in self.files:\n            frame = ctk.CTkFrame(self.files_scroll, fg_color=\"transparent\")\n            frame.pack(fill=\"x\", pady=2)\n            \n            ctk.CTkCheckBox(frame, text=\"\", width=20, variable=f_obj['enabled'], \n                           command=self.save_state).pack(side=\"left\", padx=2)\n            ctk.CTkCheckBox(frame, text=\"\ud83d\udccc\", width=40, variable=f_obj['pinned'], \n                           command=lambda p=f_obj['path']: self.toggle_pin(p)).pack(side=\"left\", padx=5)\n            \n            # FIXED: Use theme variables for colors\n            name_color = ctk.ThemeManager.theme[\"CTkButton\"][\"fg_color\"] if f_obj['pinned'].get() else ctk.ThemeManager.theme[\"CTkLabel\"][\"text_color\"]\n            ctk.CTkLabel(frame, text=os.path.basename(f_obj['path']), \n                        font=(\"Inter\", 12, \"bold\"), text_color=name_color, \n                        width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n            ctk.CTkLabel(frame, text=f_obj['path'], font=(\"Inter\", 10), \n                        text_color=ctk.ThemeManager.theme[\"CTkLabel\"][\"text_color\"]).pack(side=\"left\", padx=10)\n            \n            ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", \n                         hover_color=\"#8c1c27\", command=lambda p=f_obj['path']: self.remove_file(p)).pack(side=\"right\", padx=5)\n\n    def clear_files(self):\n        \"\"\"Clear unpinned files\"\"\"\n        self.files = [f for f in self.files if f['pinned'].get()]\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    def refresh_ai_list(self):\n        \"\"\"Refresh AI list\"\"\"\n        for widget in self.ai_scroll.winfo_children():\n            widget.destroy()\n        self.engine_rows = []\n        \n        for i, engine in enumerate(self.ai_engines_data):\n            self.create_ai_row_widgets(engine, i)\n\n    def create_ai_row_widgets(self, data, index):\n        \"\"\"Create AI row widgets\"\"\"\n        frame = ctk.CTkFrame(self.ai_scroll, fg_color=\"transparent\")\n        frame.pack(fill=\"x\", pady=2)\n        \n        url_entry = ctk.CTkEntry(frame, width=400, font=(\"JetBrains Mono\", 12))\n        url_entry.insert(0, data.get('url', ''))\n        url_entry.pack(side=\"left\", padx=5)\n        \n        desc_entry = ctk.CTkEntry(frame, font=(\"Inter\", 12))\n        desc_entry.insert(0, data.get('description', ''))\n        desc_entry.pack(side=\"left\", fill=\"x\", expand=True, padx=5)\n        \n        ctk.CTkButton(frame, text=\"GO\", width=40, \n                     command=lambda u=url_entry: webbrowser.open(u.get())).pack(side=\"left\", padx=2)\n        ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", \n                     hover_color=\"#8c1c27\", command=lambda idx=index: self.remove_ai_row(idx)).pack(side=\"left\", padx=2)\n        \n        self.engine_rows.append({'url': url_entry, 'desc': desc_entry, 'frame': frame})\n\n    def add_ai_row(self):\n        \"\"\"Add AI row\"\"\"\n        self.ai_engines_data.append({\"url\": \"\", \"description\": \"\"})\n        self.refresh_ai_list()\n\n    def remove_ai_row(self, index):\n        \"\"\"Remove AI row\"\"\"\n        self.sync_engines_from_ui()\n        if 0 <= index < len(self.ai_engines_data):\n            self.ai_engines_data.pop(index)\n            self.refresh_ai_list()\n            self.save_state()\n\n    def sync_engines_from_ui(self):\n        \"\"\"Sync engines from UI\"\"\"\n        new_data = []\n        for row in self.engine_rows:\n            new_data.append({\"url\": row['url'].get(), \"description\": row['desc'].get()})\n        self.ai_engines_data = new_data\n\n    def save_ai_engines(self):\n        \"\"\"Save AI engines\"\"\"\n        self.sync_engines_from_ui()\n        with open(self.ai_engines_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.ai_engines_data, f, indent=4)\n        self.save_state()\n        self.set_status(\"AI Engines saved to JSON\")\n\n    def save_ai_engines_as(self):\n        \"\"\"Save AI engines as\"\"\"\n        self.sync_engines_from_ui()\n        path = filedialog.asksaveasfilename(defaultextension=\".json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.ai_engines_data, f, indent=4)\n            self.set_status(f\"Saved to {os.path.basename(path)}\")\n\n    def load_ai_engines_file(self):\n        \"\"\"Load AI engines file\"\"\"\n        path = filedialog.askopenfilename(filetypes=[(\"JSON\", \"*.json\")])\n        if path:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.ai_engines_data = json.load(f)\n            self.refresh_ai_list()\n            self.save_state()\n\n    def clear_ai_engines(self):\n        \"\"\"Clear AI engines\"\"\"\n        self.ai_engines_data = []\n        self.refresh_ai_list()\n        self.save_state()\n\n    def add_to_history(self, prompt_text):\n        \"\"\"Add to history\"\"\"\n        entry = {\n            'id': datetime.datetime.now().timestamp(),\n            'time': datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            'rules_used': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_used': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [f['path'] for f in self.files if f['enabled'].get()],\n            'full_content': prompt_text,\n            'pinned': False\n        }\n        self.history.insert(0, entry)\n        self.refresh_history_ui()\n        self.save_state()\n\n    def toggle_history_pin(self, entry_id):\n        \"\"\"Toggle history pin\"\"\"\n        for item in self.history:\n            if item.get('id') == entry_id:\n                item['pinned'] = not item.get('pinned', False)\n                break\n        self.refresh_history_ui()\n        self.save_state()\n\n    def remove_history_item(self, entry_id):\n        \"\"\"Remove history item\"\"\"\n        self.history = [item for item in self.history if item.get('id') != entry_id]\n        self.refresh_history_ui()\n        self.save_state()\n\n    def clear_history(self):\n        \"\"\"Clear history\"\"\"\n        self.history = [h for h in self.history if h.get('pinned')]\n        self.refresh_history_ui()\n        self.save_state()\n\n    def refresh_history_ui(self):\n        \"\"\"Refresh history UI\"\"\"\n        for widget in self.history_scroll.winfo_children():\n            widget.destroy()\n        \n        # Pinned first, then sorted by timestamp\n        sorted_history = sorted(self.history, key=lambda x: (not x.get('pinned', False), -x.get('id', 0)))\n        \n        for entry in sorted_history:\n            self.render_history_item(entry)\n\n    def render_history_item(self, entry):\n        \"\"\"Render history item\"\"\"\n        entry_id = entry.get('id', datetime.datetime.now().timestamp())\n        is_pinned = entry.get('pinned', False)\n        \n        # FIXED: Use theme variables for colors\n        bg_color = ctk.ThemeManager.theme[\"CTkButton\"][\"fg_color\"] if is_pinned else \"transparent\"\n        item_frame = ctk.CTkFrame(self.history_scroll, border_width=1, fg_color=bg_color)\n        item_frame.pack(fill=\"x\", pady=2, padx=5)\n        \n        header_frame = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        header_frame.pack(fill=\"x\", padx=5, pady=2)\n        \n        # TYPE icon\n        ctk.CTkLabel(header_frame, text=\"\ud83d\udcdc\", width=35).pack(side=\"left\", padx=5)\n        \n        # PIN Button\n        pin_text = \"\ud83d\udccc\" if is_pinned else \"\ud83d\udccd\"\n        ctk.CTkButton(header_frame, text=pin_text, width=35, height=24, fg_color=\"transparent\",\n                     command=lambda: self.toggle_history_pin(entry_id)).pack(side=\"left\", padx=2)\n        \n        # DATE\n        ctk.CTkLabel(header_frame, text=entry['time'], font=(\"Inter\", 11), \n                    width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # PREVIEW\n        summary = entry.get('custom_used', \"\").replace(\"\\n\", \" \")[:80]\n        ctk.CTkLabel(header_frame, text=summary, font=(\"Inter\", 11), \n                    text_color=ctk.ThemeManager.theme[\"CTkLabel\"][\"text_color\"], anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # Buttons\n        ctk.CTkButton(header_frame, text=\"X\", width=30, height=24, fg_color=\"#b02a37\", \n                     hover_color=\"#8c1c27\", command=lambda: self.remove_history_item(entry_id)).pack(side=\"right\", padx=5)\n        ctk.CTkButton(header_frame, text=\"Copy\", width=60, height=24, \n                     command=lambda: self.copy_to_clipboard(entry.get('full_content', \"\"))).pack(side=\"right\", padx=5)\n        \n        # Tree Nodes Container\n        tree_container = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        main_expanded = tk.BooleanVar(value=False)\n        \n        def toggle_main():\n            if main_expanded.get():\n                tree_container.pack_forget()\n                btn_main_toggle.configure(text=\"\u25b6\")\n                main_expanded.set(False)\n            else:\n                tree_container.pack(fill=\"x\", padx=40, pady=(0, 10))\n                btn_main_toggle.configure(text=\"\u25bc\")\n                main_expanded.set(True)\n        \n        btn_main_toggle = ctk.CTkButton(header_frame, text=\"\u25b6\", width=30, fg_color=\"transparent\", command=toggle_main)\n        btn_main_toggle.pack(side=\"right\", padx=5)\n        \n        self.create_tree_node(tree_container, \"\ud83d\udcdc Prompt Rules\", entry.get('rules_used', \"\"))\n        self.create_tree_node(tree_container, \"\u270d Custom Prompt\", entry.get('custom_used', \"\"))\n        self.create_tree_node(tree_container, \"\ud83d\udcc1 Context Files\", \"\\n\".join(entry.get('context_files', [])) or \"No files.\")\n        self.create_tree_node(tree_container, \"\ud83d\ude80 Full Content\", entry.get('full_content', \"\"))\n\n    def create_tree_node(self, parent, label, content):\n        \"\"\"Create tree node\"\"\"\n        node_frame = ctk.CTkFrame(parent, fg_color=\"transparent\")\n        node_frame.pack(fill=\"x\", pady=1)\n        \n        is_open = tk.BooleanVar(value=False)\n        content_box_container = [None]\n        \n        def toggle_node():\n            if is_open.get():\n                if content_box_container[0]: content_box_container[0].destroy()\n                btn_node.configure(text=f\" + {label}\")\n                is_open.set(False)\n            else:\n                tb = ctk.CTkTextbox(node_frame, height=150, font=(\"JetBrains Mono\", 11))\n                tb.insert(\"1.0\", content)\n                tb.configure(state=\"disabled\")\n                tb.pack(fill=\"x\", padx=20, pady=5)\n                content_box_container[0] = tb\n                btn_node.configure(text=f\" - {label}\")\n                is_open.set(True)\n                self.add_proper_context_menu(tb)\n        \n        btn_node = ctk.CTkButton(node_frame, text=f\" + {label}\", anchor=\"w\", fg_color=\"transparent\",\n                                text_color=\"#aaa\", hover_color=\"#222\", height=24, command=toggle_node)\n        btn_node.pack(fill=\"x\")\n\n    def generate_prompt(self):\n        \"\"\"Generate prompt\"\"\"\n        parts = []\n        \n        # 1. Base Rules\n        if self.include_rules_var.get():\n            rules = self.prompt_editor.get(\"1.0\", tk.END).strip()\n            if rules:\n                parts.append(rules)\n        \n        # 2. Custom Prompt (Current Task)\n        custom = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        if custom:\n            parts.append(custom)\n        \n        # 3. Context Files\n        if self.include_context_var.get():\n            for f_obj in self.files:\n                if f_obj['enabled'].get():\n                    fpath = f_obj['path']\n                    if os.path.exists(fpath):\n                        try:\n                            with open(fpath, \"r\", encoding=\"utf-8\") as f:\n                                content = f.read()\n                            header = f\"\\n[Filename: {os.path.basename(fpath)}]\\n[Path: {fpath}]\"\n                            parts.append(header + \"\\n\" + content)\n                        except Exception as e:\n                            print(f\"Error reading {fpath}: {e}\")\n        \n        final_prompt = \"\\n\\n---\\n\\n\".join(parts)\n        \n        # Handle large prompts\n        if len(final_prompt) > 15000:\n            if messagebox.askyesno(\"Prompt Largo\", \n                                   f\"El prompt generado es muy grande ({len(final_prompt)} caracteres).\\n\"\n                                   \"\u00bfDeseas abrir GitHub Gist para subirlo all\u00ed?\"):\n                webbrowser.open(\"https://gist.github.com/\")\n            self.copy_to_clipboard(final_prompt)\n        else:\n            self.copy_to_clipboard(final_prompt)\n        \n        self.add_to_history(final_prompt)\n        self.set_status(\"\u2713 Prompt Copied to Clipboard\")\n\n    def copy_to_clipboard(self, text):\n        \"\"\"Copy to clipboard\"\"\"\n        self.root.clipboard_clear()\n        self.root.clipboard_append(text)\n\n    def set_status(self, text):\n        \"\"\"Set status\"\"\"\n        self.status_label.configure(text=text)\n        self.root.after(3000, lambda: self.status_label.configure(text=\"Ready\"))\n\n    def save_state(self, *args):\n        \"\"\"Save state\"\"\"\n        self.sync_engines_from_ui()\n        state = {\n            'rules_file': self.current_rules_file,\n            'custom_file': self.current_custom_file,\n            'prompt_md_content': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_prompt_content': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [\n                {'path': f['path'], 'enabled': f['enabled'].get(), 'pinned': f['pinned'].get()}\n                for f in self.files\n            ],\n            'inc_rules': self.include_rules_var.get(),\n            'inc_context': self.include_context_var.get(),\n            'history': self.history,\n            'ai_engines': self.ai_engines_data\n        }\n        with open(self.state_file, 'w', encoding=\"utf-8\") as f:\n            json.dump(state, f, indent=4)\n\n    def load_state(self):\n        \"\"\"Load state\"\"\"\n        if not os.path.exists(self.state_file):\n            return\n        \n        try:\n            with open(self.state_file, 'r', encoding=\"utf-8\") as f:\n                state = json.load(f)\n            \n            # Load editor content\n            self.prompt_editor.insert(\"1.0\", state.get('prompt_md_content', ''))\n            self.custom_prompt.insert(\"1.0\", state.get('custom_prompt_content', ''))\n            \n            # Load Flags\n            self.include_rules_var.set(state.get('inc_rules', True))\n            self.include_context_var.set(state.get('inc_context', True))\n            \n            # Load History\n            self.history = state.get('history', [])\n            \n            # Load Engines\n            self.ai_engines_data = state.get('ai_engines', [])\n            \n            # Load files\n            self.files = []\n            for f_data in state.get('context_files', []):\n                if os.path.exists(f_data['path']):\n                    self.files.append({\n                        'path': f_data['path'],\n                        'enabled': tk.BooleanVar(value=f_data['enabled']),\n                        'pinned': tk.BooleanVar(value=f_data['pinned'])\n                    })\n            \n            self.refresh_file_list_ui()\n            self.refresh_history_ui()\n            self.refresh_ai_list()\n        except Exception as e:\n            print(f\"Error loading state: {e}\")\n\n    def auto_save(self):\n        \"\"\"Auto save\"\"\"\n        self.save_state()\n        self.root.after(300000, self.auto_save)\n\n    def on_close(self):\n        \"\"\"On close\"\"\"\n        self.save_state()\n        self.root.destroy()\n\n    # File manager methods\n    def save_prompt_md(self):\n        \"\"\"Save prompt md\"\"\"\n        content = self.prompt_editor.get(\"1.0\", tk.END).strip()\n        with open(self.current_rules_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Rules saved to {os.path.basename(self.current_rules_file)}\")\n\n    def save_rules_as(self):\n        \"\"\"Save rules as\"\"\"\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"prompt.md\")\n        if path:\n            self.current_rules_file = path\n            self.save_prompt_md()\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n\n    def load_rules_file(self):\n        \"\"\"Load rules file\"\"\"\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_rules_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_editor.delete(\"1.0\", tk.END)\n                self.prompt_editor.insert(\"1.0\", f.read())\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n\n    def save_custom_prompt(self):\n        \"\"\"Save custom prompt\"\"\"\n        content = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        with open(self.current_custom_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Task saved to {os.path.basename(self.current_custom_file)}\")\n\n    def save_custom_as(self):\n        \"\"\"Save custom as\"\"\"\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"custom.md\")\n        if path:\n            self.current_custom_file = path\n            self.save_custom_prompt()\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n\n    def load_custom_file(self):\n        \"\"\"Load custom file\"\"\"\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_custom_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.custom_prompt.delete(\"1.0\", tk.END)\n                self.custom_prompt.insert(\"1.0\", f.read())\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n\n    def save_history_as(self):\n        \"\"\"Save history as\"\"\"\n        path = filedialog.asksaveasfilename(defaultextension=\".json\", initialfile=\"history_export.json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.history, f, indent=4)\n            self.set_status(\"History exported.\")\n\nif __name__ == \"__main__\":\n    root = ctk.CTk()\n    app = ModernPromptGUI(root)\n    root.mainloop()\n",
            "pinned": false
        },
        {
            "id": 1768934121.721018,
            "time": "2026-01-20 12:35:21",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.",
            "custom_used": "still have to hold right-click in order to select, if i release right-click the moue pick's up the item where the cursor is sitting in, that is not right and sucks ass, and add a few more themes",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/ask-viejo/ask-beta.py"
            ],
            "full_content": "still have to hold right-click in order to select, if i release right-click the moue pick's up the item where the cursor is sitting in, that is not right and sucks ass, and add a few more themes",
            "pinned": false
        },
        {
            "id": 1768930166.87413,
            "time": "2026-01-20 11:29:26",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.",
            "custom_used": "Mouse do not work\nDo not use hardcode theme values, use theme variables insted",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/ask-viejo/ask-beta.py"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.\n\n---\n\nMouse do not work\nDo not use hardcode theme values, use theme variables insted\n\n---\n\n\n[Filename: ask-beta.py]\n[Path: /home/deb/borednomore3/borednomore3/ask-viejo/ask-beta.py]\n\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox\nimport customtkinter as ctk\nimport os\nimport subprocess\nimport datetime\nimport json\nimport webbrowser\nimport signal\nimport sys\nimport platform\n\n# Configuraci\u00f3n inicial de apariencia\nctk.set_appearance_mode(\"dark\")\nctk.set_default_color_theme(\"blue\")\n\nclass ModernPromptGUI:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Prompt Engine \u2022 Ultra Modern\")\n        self.root.geometry(\"1280x850\")\n        self.root.minsize(1000, 750)\n        \n        print(f\"[{datetime.datetime.now()}] Initializing ModernPromptGUI...\")\n        \n        # Captura de CTRL+C (SIGINT)\n        signal.signal(signal.SIGINT, self.signal_handler)\n        \n        self.files = []\n        self.history = []\n        \n        # Inclusion Switches Variables\n        self.include_rules_var = tk.BooleanVar(value=True)\n        self.include_context_var = tk.BooleanVar(value=True)\n        \n        # Default Paths\n        self.prompt_md_path = \"prompt.md\"\n        self.custom_prompt_default = \"custom.md\"\n        self.state_file = \"app_state.json\"\n        \n        # Track current working files for tabs\n        self.current_rules_file = self.prompt_md_path\n        self.current_custom_file = self.custom_prompt_default\n        \n        # AI Engines\n        self.ai_engines_path = \"ai_engines.json\"\n        self.ai_engines_data = []\n        self.engine_rows = []\n        \n        # Carga inicial de datos base si existen\n        self.load_initial_content()\n        \n        # Create widgets with proper mouse support\n        self.create_widgets()\n        \n        # Seleccionar pesta\u00f1a Custom Prompt por defecto al iniciar\n        self.tabview.set(\"Custom Prompt\")\n        \n        # Manejo de cierre de ventana\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n        \n        # Cargar estado guardado\n        if os.path.exists(self.state_file):\n            self.load_state()\n        else:\n            self.auto_load_default_files()\n        \n        # Timer de auto-salvado (5 minutos)\n        self.root.after(300000, self.auto_save)\n        \n        print(f\"[{datetime.datetime.now()}] GUI Ready.\")\n    \n    def load_initial_content(self):\n        \"\"\"Carga contenido inicial de archivos base o los crea si no existen\"\"\"\n        # Asegurar existencia de archivos m\u00ednimos\n        for fpath in [self.prompt_md_path, self.custom_prompt_default]:\n            if not os.path.exists(fpath):\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(\"\") # Crear vac\u00edo\n        \n        if os.path.exists(self.prompt_md_path):\n            with open(self.prompt_md_path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_md_content = f.read()\n        \n        # Prioridad absoluta a ai_engines.json\n        if os.path.exists(self.ai_engines_path):\n            try:\n                with open(self.ai_engines_path, \"r\", encoding=\"utf-8\") as f:\n                    self.ai_engines_data = json.load(f)\n                print(f\"[{datetime.datetime.now()}] Engines loaded from {self.ai_engines_path}\")\n            except Exception as e:\n                print(f\"DEBUG: Error loading ai_engines.json: {e}\")\n    \n    def create_widgets(self):\n        \"\"\"Create widgets with proper mouse support using tkinter's built-in functionality\"\"\"\n        # Usamos un Tabview de CustomTkinter\n        self.tabview = ctk.CTkTabview(self.root,\n                                      segmented_button_selected_color=\"#3b8ed0\",\n                                      segmented_button_unselected_color=\"#222\",\n                                      segmented_button_selected_hover_color=\"#4fa3ed0\")\n        self.tabview.pack(fill=\"both\", expand=True, padx=20, pady=20)\n        \n        self.tab_rules = self.tabview.add(\"\u270f Prompt Rules\")\n        self.tab_custom = self.tabview.add(\"Custom Prompt\")\n        self.tab_files = self.tabview.add(\"Context Files\")\n        self.tab_ai = self.tabview.add(\"AI Engines\")\n        self.tab_history = self.tabview.add(\"History\")\n        \n        # --- Tab: Prompt Rules ---\n        self.lbl_rules_file = ctk.CTkLabel(self.tab_rules, text=f\"Base System Prompt ({self.current_rules_file})\", \n                                          font=(\"Inter\", 14, \"bold\"), text_color=\"#3b8ed0\")\n        self.lbl_rules_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.prompt_editor = ctk.CTkTextbox(self.tab_rules, font=(\"JetBrains Mono\", 13), \n                                           border_width=2, border_color=\"#333\", undo=True)\n        self.prompt_editor.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        \n        # Add proper context menu to text widget\n        self.add_proper_context_menu(self.prompt_editor)\n        \n        btn_rules_frame = ctk.CTkFrame(self.tab_rules, fg_color=\"transparent\")\n        btn_rules_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_rules_frame, text=\"Save\", width=100, fg_color=\"#2fa572\", \n                     hover_color=\"#218c59\", command=self.save_prompt_md).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Save As...\", width=100, \n                     command=self.save_rules_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Load\", width=100, \n                     command=self.load_rules_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Clear\", width=100, \n                     command=lambda: self.prompt_editor.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Undo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.prompt_editor.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Redo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.prompt_editor.edit_redo()).pack(side=\"right\", padx=5)\n        \n        # --- Tab: Custom Prompt ---\n        self.tab_custom.configure(fg_color=\"#1e1e1e\")\n        self.lbl_custom_file = ctk.CTkLabel(self.tab_custom, \n                                           text=f\"Current Task ({self.current_custom_file})\", \n                                           font=(\"Inter\", 14, \"bold\"), text_color=\"#2fa572\")\n        self.lbl_custom_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.custom_prompt = ctk.CTkTextbox(self.tab_custom, font=(\"JetBrains Mono\", 14), \n                                           border_width=2, border_color=\"#2fa572\", undo=True, \n                                           fg_color=\"#121212\")\n        self.custom_prompt.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        \n        # Add proper context menu to text widget\n        self.add_proper_context_menu(self.custom_prompt)\n        \n        btn_custom_frame = ctk.CTkFrame(self.tab_custom, fg_color=\"transparent\")\n        btn_custom_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_custom_frame, text=\"Save Task\", width=120, fg_color=\"#2fa572\", \n                     hover_color=\"#218c59\", font=(\"Inter\", 12, \"bold\"), \n                     command=self.save_custom_prompt).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Save As...\", width=100, \n                     command=self.save_custom_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Load\", width=100, \n                     command=self.load_custom_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Clear\", width=100, \n                     command=lambda: self.custom_prompt.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Undo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.custom_prompt.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Redo\", width=70, fg_color=\"#444\", \n                     command=lambda: self.custom_prompt.edit_redo()).pack(side=\"right\", padx=5)\n        \n        # --- Tab: Context Files ---\n        files_header = ctk.CTkFrame(self.tab_files, fg_color=\"#222\")\n        files_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        \n        ctk.CTkLabel(files_header, text=\"INC\", font=(\"Inter\", 11, \"bold\"), width=30).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(files_header, text=\"PIN\", font=(\"Inter\", 11, \"bold\"), width=40).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FILENAME\", font=(\"Inter\", 11, \"bold\"), width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FULL SYSTEM PATH\", font=(\"Inter\", 11, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        self.files_scroll = ctk.CTkScrollableFrame(self.tab_files, label_text=\"\")\n        self.files_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_files_frame = ctk.CTkFrame(self.tab_files, fg_color=\"transparent\")\n        btn_files_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_files_frame, text=\"Add File\", command=self.add_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_files_frame, text=\"Clear Unpinned\", command=self.clear_files).pack(side=\"left\", padx=5)\n        \n        # --- Tab: AI Engines ---\n        ai_table_header = ctk.CTkFrame(self.tab_ai, fg_color=\"#222\")\n        ai_table_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        \n        ctk.CTkLabel(ai_table_header, text=\"URL\", font=(\"Inter\", 12, \"bold\"), width=400, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(ai_table_header, text=\"Description\", font=(\"Inter\", 12, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=35)\n        \n        self.ai_scroll = ctk.CTkScrollableFrame(self.tab_ai, label_text=\"\")\n        self.ai_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_ai_frame = ctk.CTkFrame(self.tab_ai, fg_color=\"transparent\")\n        btn_ai_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_ai_frame, text=\"Save Engines\", width=120, fg_color=\"#2fa572\", \n                     command=self.save_ai_engines).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Save As...\", width=100, \n                     command=self.save_ai_engines_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Load File\", width=100, \n                     command=self.load_ai_engines_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Add Row\", fg_color=\"#1f538d\", \n                     hover_color=\"darkgreen\", width=100, command=self.add_ai_row).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Clear All\", width=100, \n                     command=self.clear_ai_engines).pack(side=\"left\", padx=5)\n        \n        self.refresh_ai_list()\n        \n        # --- Tab: History ---\n        self.setup_history_header()\n        \n        self.history_scroll = ctk.CTkScrollableFrame(self.tab_history, \n                                                    label_text=\"Prompt History Log\", \n                                                    label_text_color=\"#3b8ed0\")\n        self.history_scroll.pack(fill=\"both\", expand=True, padx=12, pady=12)\n        \n        btn_hist_frame = ctk.CTkFrame(self.tab_history, fg_color=\"transparent\")\n        btn_hist_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        \n        ctk.CTkButton(btn_hist_frame, text=\"Clear All History\", \n                     command=self.clear_history).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_hist_frame, text=\"Save History As...\", \n                     command=self.save_history_as).pack(side=\"left\", padx=5)\n        \n        # Bottom Action Bar\n        self.bottom_frame = ctk.CTkFrame(self.root, height=80, border_width=1, \n                                        border_color=\"#444\", fg_color=\"#1a1a1a\")\n        self.bottom_frame.pack(fill=\"x\", side=\"bottom\", padx=20, pady=20)\n        \n        self.cb_rules = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Rules\", \n                                       variable=self.include_rules_var, \n                                       command=self.save_state)\n        self.cb_rules.pack(side=\"left\", padx=10)\n        \n        self.cb_context = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Context\", \n                                         variable=self.include_context_var, \n                                         command=self.save_state)\n        self.cb_context.pack(side=\"left\", padx=10)\n        \n        ctk.CTkButton(self.bottom_frame, text=\"\ud83d\ude80 GENERATE PROMPT & COPY TO CLIPBOARD\", \n                     fg_color=\"#2fa572\", hover_color=\"#218c59\", font=(\"Inter\", 14, \"bold\"), \n                     command=self.generate_prompt).pack(side=\"left\", padx=20)\n        \n        ctk.CTkButton(self.bottom_frame, text=\"EXIT\", fg_color=\"#b02a37\", \n                     hover_color=\"#8c1c27\", width=60, command=self.on_close).pack(side=\"right\", padx=10)\n        \n        self.theme_menu = ctk.CTkOptionMenu(self.bottom_frame, \n                                           values=[\"Dark\", \"Light\", \"System\"], \n                                           width=100, command=self.change_theme)\n        self.theme_menu.pack(side=\"right\", padx=10)\n        \n        self.status_label = ctk.CTkLabel(self.bottom_frame, text=\"Ready\", \n                                        font=(\"Inter\", 12), text_color=\"#aaa\")\n        self.status_label.pack(side=\"right\", padx=20)\n    \n    def add_proper_context_menu(self, widget):\n        \"\"\"Add proper tkinter context menu that works like normal desktop apps\"\"\"\n        # Create the menu\n        self.context_menu = tk.Menu(widget, tearoff=0, bg=\"#2b2b2b\", fg=\"white\", \n                                   activebackground=\"#3b8ed0\", borderwidth=0)\n        \n        # Add standard edit commands\n        self.context_menu.add_command(label=\"Cut\", \n                                     command=lambda: widget.event_generate(\"<<Cut>>\"))\n        self.context_menu.add_command(label=\"Copy\", \n                                     command=lambda: widget.event_generate(\"<<Copy>>\"))\n        self.context_menu.add_command(label=\"Paste\", \n                                     command=lambda: widget.event_generate(\"<<Paste>>\"))\n        self.context_menu.add_separator()\n        self.context_menu.add_command(label=\"Select All\", \n                                     command=lambda: widget.event_generate(\"<<SelectAll>>\"))\n        \n        # Enhanced commands for text widgets\n        if isinstance(widget, (tk.Text, ctk.CTkTextbox)):\n            self.context_menu.add_separator()\n            self.context_menu.add_command(label=\"Clear All\", \n                                         command=lambda: widget.delete(\"1.0\", tk.END))\n        \n        def show_menu(event):\n            \"\"\"Show context menu at cursor position - FIXED: No need to hold button\"\"\"\n            try:\n                widget.focus_set()  # Focus the widget first\n                self.context_menu.tk_popup(event.x_root, event.y_root)\n            finally:\n                self.context_menu.grab_release()\n        \n        # Bind right-click to show menu (normal behavior - click to show, click to select)\n        widget.bind(\"<Button-3>\", show_menu)\n        \n        # Add mouse wheel support for scrolling\n        widget.bind(\"<MouseWheel>\", lambda e: self.handle_mouse_wheel(e, widget))\n        widget.bind(\"<Button-4>\", lambda e: self.handle_mouse_wheel(e, widget))  # Linux\n        widget.bind(\"<Button-5>\", lambda e: self.handle_mouse_wheel(e, widget))  # Linux\n    \n    def handle_mouse_wheel(self, event, widget):\n        \"\"\"Handle mouse wheel scrolling properly\"\"\"\n        if hasattr(widget, 'yview'):\n            if event.delta:\n                # Windows/Mac\n                widget.yview_scroll(int(-1 * (event.delta / 120)), \"units\")\n            else:\n                # Linux\n                widget.yview_scroll(-1 if event.num == 4 else 1, \"units\")\n        return \"break\"\n    \n    def setup_history_header(self):\n        \"\"\"Setup history header\"\"\"\n        header_frame = ctk.CTkFrame(self.tab_history, fg_color=\"#222\", height=30)\n        header_frame.pack(fill=\"x\", padx=12, pady=(10, 0))\n        \n        ctk.CTkLabel(header_frame, text=\"TYPE\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(header_frame, text=\"PIN\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(header_frame, text=\"DATE/TIME\", font=(\"Inter\", 10, \"bold\"), width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(header_frame, text=\"TASK PREVIEW / CONTENT\", font=(\"Inter\", 10, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=20)\n    \n    def auto_load_default_files(self):\n        \"\"\"Carga archivos espec\u00edficos al contexto si no hay estado previo\"\"\"\n        defaults = [self.ai_engines_path, self.state_file, self.custom_prompt_default, self.prompt_md_path]\n        for path in defaults:\n            abs_path = os.path.abspath(path)\n            if not os.path.exists(abs_path): continue\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=True)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n                self.refresh_file_list_ui()\n    \n    def signal_handler(self, sig, frame):\n        \"\"\"Maneja CTRL+C salvando el estado antes de interrumpir\"\"\"\n        print(f\"\\n[{datetime.datetime.now()}] INTERRUPT (Ctrl+C). Saving state...\")\n        self.save_state()\n        sys.exit(0)\n    \n    def change_theme(self, new_theme):\n        \"\"\"Cambia el modo de apariencia.\"\"\"\n        ctk.set_appearance_mode(new_theme.lower())\n        self.save_state()\n    \n    def add_file(self):\n        \"\"\"Add file with proper mouse support\"\"\"\n        paths = filedialog.askopenfilenames()\n        for path in paths:\n            abs_path = os.path.abspath(path)\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=False)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n                self.refresh_file_list_ui()\n                self.save_state()\n    \n    def toggle_pin(self, path):\n        \"\"\"Toggle file pinning\"\"\"\n        self.save_state()\n        self.refresh_file_list_ui()\n    \n    def remove_file(self, path):\n        \"\"\"Remove file\"\"\"\n        self.files = [f for f in self.files if f['path'] != path]\n        self.refresh_file_list_ui()\n        self.save_state()\n    \n    def refresh_file_list_ui(self):\n        \"\"\"Refresh file list UI\"\"\"\n        for widget in self.files_scroll.winfo_children():\n            widget.destroy()\n        \n        for f_obj in self.files:\n            frame = ctk.CTkFrame(self.files_scroll, fg_color=\"transparent\")\n            frame.pack(fill=\"x\", pady=2)\n            \n            ctk.CTkCheckBox(frame, text=\"\", width=20, variable=f_obj['enabled'], \n                           command=self.save_state).pack(side=\"left\", padx=2)\n            ctk.CTkCheckBox(frame, text=\"\ud83d\udccc\", width=40, variable=f_obj['pinned'], \n                           command=lambda p=f_obj['path']: self.toggle_pin(p)).pack(side=\"left\", padx=5)\n            \n            name_color = \"#3b8ed0\" if f_obj['pinned'].get() else \"white\"\n            ctk.CTkLabel(frame, text=os.path.basename(f_obj['path']), \n                        font=(\"Inter\", 12, \"bold\"), text_color=name_color, \n                        width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n            ctk.CTkLabel(frame, text=f_obj['path'], font=(\"Inter\", 10), \n                        text_color=\"gray\").pack(side=\"left\", padx=10)\n            \n            ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", \n                         hover_color=\"#8c1c27\", command=lambda p=f_obj['path']: self.remove_file(p)).pack(side=\"right\", padx=5)\n    \n    def clear_files(self):\n        \"\"\"Clear unpinned files\"\"\"\n        self.files = [f for f in self.files if f['pinned'].get()]\n        self.refresh_file_list_ui()\n        self.save_state()\n    \n    def refresh_ai_list(self):\n        \"\"\"Refresh AI list\"\"\"\n        for widget in self.ai_scroll.winfo_children():\n            widget.destroy()\n        self.engine_rows = []\n        \n        for i, engine in enumerate(self.ai_engines_data):\n            self.create_ai_row_widgets(engine, i)\n    \n    def create_ai_row_widgets(self, data, index):\n        \"\"\"Create AI row widgets\"\"\"\n        frame = ctk.CTkFrame(self.ai_scroll, fg_color=\"transparent\")\n        frame.pack(fill=\"x\", pady=2)\n        \n        url_entry = ctk.CTkEntry(frame, width=400, font=(\"JetBrains Mono\", 12))\n        url_entry.insert(0, data.get('url', ''))\n        url_entry.pack(side=\"left\", padx=5)\n        \n        desc_entry = ctk.CTkEntry(frame, font=(\"Inter\", 12))\n        desc_entry.insert(0, data.get('description', ''))\n        desc_entry.pack(side=\"left\", fill=\"x\", expand=True, padx=5)\n        \n        ctk.CTkButton(frame, text=\"GO\", width=40, \n                     command=lambda u=url_entry: webbrowser.open(u.get())).pack(side=\"left\", padx=2)\n        ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", \n                     hover_color=\"#8c1c27\", command=lambda idx=index: self.remove_ai_row(idx)).pack(side=\"left\", padx=2)\n        \n        self.engine_rows.append({'url': url_entry, 'desc': desc_entry, 'frame': frame})\n    \n    def add_ai_row(self):\n        \"\"\"Add AI row\"\"\"\n        self.ai_engines_data.append({\"url\": \"\", \"description\": \"\"})\n        self.refresh_ai_list()\n    \n    def remove_ai_row(self, index):\n        \"\"\"Remove AI row\"\"\"\n        self.sync_engines_from_ui()\n        if 0 <= index < len(self.ai_engines_data):\n            self.ai_engines_data.pop(index)\n            self.refresh_ai_list()\n            self.save_state()\n    \n    def sync_engines_from_ui(self):\n        \"\"\"Sync engines from UI\"\"\"\n        new_data = []\n        for row in self.engine_rows:\n            new_data.append({\"url\": row['url'].get(), \"description\": row['desc'].get()})\n        self.ai_engines_data = new_data\n    \n    def save_ai_engines(self):\n        \"\"\"Save AI engines\"\"\"\n        self.sync_engines_from_ui()\n        with open(self.ai_engines_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.ai_engines_data, f, indent=4)\n        self.save_state()\n        self.set_status(\"AI Engines saved to JSON\")\n    \n    def save_ai_engines_as(self):\n        \"\"\"Save AI engines as\"\"\"\n        self.sync_engines_from_ui()\n        path = filedialog.asksaveasfilename(defaultextension=\".json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.ai_engines_data, f, indent=4)\n            self.set_status(f\"Saved to {os.path.basename(path)}\")\n    \n    def load_ai_engines_file(self):\n        \"\"\"Load AI engines file\"\"\"\n        path = filedialog.askopenfilename(filetypes=[(\"JSON\", \"*.json\")])\n        if path:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.ai_engines_data = json.load(f)\n            self.refresh_ai_list()\n            self.save_state()\n    \n    def clear_ai_engines(self):\n        \"\"\"Clear AI engines\"\"\"\n        self.ai_engines_data = []\n        self.refresh_ai_list()\n        self.save_state()\n    \n    def add_to_history(self, prompt_text):\n        \"\"\"Add to history\"\"\"\n        entry = {\n            'id': datetime.datetime.now().timestamp(),\n            'time': datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            'rules_used': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_used': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [f['path'] for f in self.files if f['enabled'].get()],\n            'full_content': prompt_text,\n            'pinned': False\n        }\n        self.history.insert(0, entry)\n        self.refresh_history_ui()\n        self.save_state()\n    \n    def toggle_history_pin(self, entry_id):\n        \"\"\"Toggle history pin\"\"\"\n        for item in self.history:\n            if item.get('id') == entry_id:\n                item['pinned'] = not item.get('pinned', False)\n                break\n        self.refresh_history_ui()\n        self.save_state()\n    \n    def remove_history_item(self, entry_id):\n        \"\"\"Remove history item\"\"\"\n        self.history = [item for item in self.history if item.get('id') != entry_id]\n        self.refresh_history_ui()\n        self.save_state()\n    \n    def clear_history(self):\n        \"\"\"Clear history\"\"\"\n        self.history = [h for h in self.history if h.get('pinned')]\n        self.refresh_history_ui()\n        self.save_state()\n    \n    def refresh_history_ui(self):\n        \"\"\"Refresh history UI\"\"\"\n        for widget in self.history_scroll.winfo_children():\n            widget.destroy()\n        \n        # Pinned first, then sorted by timestamp\n        sorted_history = sorted(self.history, key=lambda x: (not x.get('pinned', False), -x.get('id', 0)))\n        \n        for entry in sorted_history:\n            self.render_history_item(entry)\n    \n    def render_history_item(self, entry):\n        \"\"\"Render history item\"\"\"\n        entry_id = entry.get('id', datetime.datetime.now().timestamp())\n        is_pinned = entry.get('pinned', False)\n        \n        # Visual feedback for pinned items\n        bg_color = \"#1e3d2f\" if is_pinned else \"transparent\"\n        item_frame = ctk.CTkFrame(self.history_scroll, border_width=1, fg_color=bg_color)\n        item_frame.pack(fill=\"x\", pady=2, padx=5)\n        \n        header_frame = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        header_frame.pack(fill=\"x\", padx=5, pady=2)\n        \n        # TYPE icon\n        ctk.CTkLabel(header_frame, text=\"\ud83d\udcdc\", width=35).pack(side=\"left\", padx=5)\n        \n        # PIN Button\n        pin_text = \"\ud83d\udccc\" if is_pinned else \"\ud83d\udccd\"\n        ctk.CTkButton(header_frame, text=pin_text, width=35, height=24, fg_color=\"transparent\",\n                     command=lambda: self.toggle_history_pin(entry_id)).pack(side=\"left\", padx=2)\n        \n        # DATE\n        ctk.CTkLabel(header_frame, text=entry['time'], font=(\"Inter\", 11), \n                    width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # PREVIEW\n        summary = entry.get('custom_used', \"\").replace(\"\\n\", \" \")[:80]\n        ctk.CTkLabel(header_frame, text=summary, font=(\"Inter\", 11), \n                    text_color=\"#aaa\", anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # Buttons\n        ctk.CTkButton(header_frame, text=\"X\", width=30, height=24, fg_color=\"#b02a37\", \n                     hover_color=\"#8c1c27\", command=lambda: self.remove_history_item(entry_id)).pack(side=\"right\", padx=5)\n        ctk.CTkButton(header_frame, text=\"Copy\", width=60, height=24, \n                     command=lambda: self.copy_to_clipboard(entry.get('full_content', \"\"))).pack(side=\"right\", padx=5)\n        \n        # Tree Nodes Container\n        tree_container = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        main_expanded = tk.BooleanVar(value=False)\n        \n        def toggle_main():\n            if main_expanded.get():\n                tree_container.pack_forget()\n                btn_main_toggle.configure(text=\"\u25b6\")\n                main_expanded.set(False)\n            else:\n                tree_container.pack(fill=\"x\", padx=40, pady=(0, 10))\n                btn_main_toggle.configure(text=\"\u25bc\")\n                main_expanded.set(True)\n        \n        btn_main_toggle = ctk.CTkButton(header_frame, text=\"\u25b6\", width=30, fg_color=\"transparent\", command=toggle_main)\n        btn_main_toggle.pack(side=\"right\", padx=5)\n        \n        self.create_tree_node(tree_container, \"\ud83d\udcdc Prompt Rules\", entry.get('rules_used', \"\"))\n        self.create_tree_node(tree_container, \"\u270d Custom Prompt\", entry.get('custom_used', \"\"))\n        self.create_tree_node(tree_container, \"\ud83d\udcc1 Context Files\", \"\\n\".join(entry.get('context_files', [])) or \"No files.\")\n        self.create_tree_node(tree_container, \"\ud83d\ude80 Full Content\", entry.get('full_content', \"\"))\n    \n    def create_tree_node(self, parent, label, content):\n        \"\"\"Create tree node\"\"\"\n        node_frame = ctk.CTkFrame(parent, fg_color=\"transparent\")\n        node_frame.pack(fill=\"x\", pady=1)\n        \n        is_open = tk.BooleanVar(value=False)\n        content_box_container = [None]\n        \n        def toggle_node():\n            if is_open.get():\n                if content_box_container[0]: content_box_container[0].destroy()\n                btn_node.configure(text=f\" + {label}\")\n                is_open.set(False)\n            else:\n                tb = ctk.CTkTextbox(node_frame, height=150, font=(\"JetBrains Mono\", 11))\n                tb.insert(\"1.0\", content)\n                tb.configure(state=\"disabled\")\n                tb.pack(fill=\"x\", padx=20, pady=5)\n                content_box_container[0] = tb\n                btn_node.configure(text=f\" - {label}\")\n                is_open.set(True)\n                self.add_proper_context_menu(tb)\n        \n        btn_node = ctk.CTkButton(node_frame, text=f\" + {label}\", anchor=\"w\", fg_color=\"transparent\",\n                                text_color=\"#aaa\", hover_color=\"#222\", height=24, command=toggle_node)\n        btn_node.pack(fill=\"x\")\n    \n    def generate_prompt(self):\n        \"\"\"Generate prompt\"\"\"\n        parts = []\n        \n        # 1. Base Rules\n        if self.include_rules_var.get():\n            rules = self.prompt_editor.get(\"1.0\", tk.END).strip()\n            if rules:\n                parts.append(rules)\n        \n        # 2. Custom Prompt (Current Task)\n        custom = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        if custom:\n            parts.append(custom)\n        \n        # 3. Context Files\n        if self.include_context_var.get():\n            for f_obj in self.files:\n                if f_obj['enabled'].get():\n                    fpath = f_obj['path']\n                    if os.path.exists(fpath):\n                        try:\n                            with open(fpath, \"r\", encoding=\"utf-8\") as f:\n                                content = f.read()\n                            header = f\"\\n[Filename: {os.path.basename(fpath)}]\\n[Path: {fpath}]\"\n                            parts.append(header + \"\\n\" + content)\n                        except Exception as e:\n                            print(f\"Error reading {fpath}: {e}\")\n        \n        final_prompt = \"\\n\\n---\\n\\n\".join(parts)\n        \n        # Handle large prompts\n        if len(final_prompt) > 15000:\n            if messagebox.askyesno(\"Prompt Largo\", \n                                   f\"El prompt generado es muy grande ({len(final_prompt)} caracteres).\\n\"\n                                   \"\u00bfDeseas abrir GitHub Gist para subirlo all\u00ed?\"):\n                webbrowser.open(\"https://gist.github.com/\")\n            self.copy_to_clipboard(final_prompt)\n        else:\n            self.copy_to_clipboard(final_prompt)\n        \n        self.add_to_history(final_prompt)\n        self.set_status(\"\u2713 Prompt Copied to Clipboard\")\n    \n    def copy_to_clipboard(self, text):\n        \"\"\"Copy to clipboard\"\"\"\n        self.root.clipboard_clear()\n        self.root.clipboard_append(text)\n    \n    def set_status(self, text):\n        \"\"\"Set status\"\"\"\n        self.status_label.configure(text=text)\n        self.root.after(3000, lambda: self.status_label.configure(text=\"Ready\"))\n    \n    def save_state(self, *args):\n        \"\"\"Save state\"\"\"\n        self.sync_engines_from_ui()\n        state = {\n            'rules_file': self.current_rules_file,\n            'custom_file': self.current_custom_file,\n            'prompt_md_content': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_prompt_content': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [\n                {'path': f['path'], 'enabled': f['enabled'].get(), 'pinned': f['pinned'].get()}\n                for f in self.files\n            ],\n            'inc_rules': self.include_rules_var.get(),\n            'inc_context': self.include_context_var.get(),\n            'history': self.history,\n            'ai_engines': self.ai_engines_data\n        }\n        with open(self.state_file, 'w', encoding=\"utf-8\") as f:\n            json.dump(state, f, indent=4)\n    \n    def load_state(self):\n        \"\"\"Load state\"\"\"\n        if not os.path.exists(self.state_file):\n            return\n        \n        try:\n            with open(self.state_file, 'r', encoding=\"utf-8\") as f:\n                state = json.load(f)\n            \n            # Load editor content\n            self.prompt_editor.insert(\"1.0\", state.get('prompt_md_content', ''))\n            self.custom_prompt.insert(\"1.0\", state.get('custom_prompt_content', ''))\n            \n            # Load Flags\n            self.include_rules_var.set(state.get('inc_rules', True))\n            self.include_context_var.set(state.get('inc_context', True))\n            \n            # Load History\n            self.history = state.get('history', [])\n            \n            # Load Engines\n            self.ai_engines_data = state.get('ai_engines', [])\n            \n            # Load files\n            self.files = []\n            for f_data in state.get('context_files', []):\n                if os.path.exists(f_data['path']):\n                    self.files.append({\n                        'path': f_data['path'],\n                        'enabled': tk.BooleanVar(value=f_data['enabled']),\n                        'pinned': tk.BooleanVar(value=f_data['pinned'])\n                    })\n            \n            self.refresh_file_list_ui()\n            self.refresh_history_ui()\n            self.refresh_ai_list()\n        except Exception as e:\n            print(f\"Error loading state: {e}\")\n    \n    def auto_save(self):\n        \"\"\"Auto save\"\"\"\n        self.save_state()\n        self.root.after(300000, self.auto_save)\n    \n    def on_close(self):\n        \"\"\"On close\"\"\"\n        self.save_state()\n        self.root.destroy()\n    \n    # File manager methods\n    def save_prompt_md(self):\n        \"\"\"Save prompt md\"\"\"\n        content = self.prompt_editor.get(\"1.0\", tk.END).strip()\n        with open(self.current_rules_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Rules saved to {os.path.basename(self.current_rules_file)}\")\n    \n    def save_rules_as(self):\n        \"\"\"Save rules as\"\"\"\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"prompt.md\")\n        if path:\n            self.current_rules_file = path\n            self.save_prompt_md()\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n    \n    def load_rules_file(self):\n        \"\"\"Load rules file\"\"\"\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_rules_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_editor.delete(\"1.0\", tk.END)\n                self.prompt_editor.insert(\"1.0\", f.read())\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n    \n    def save_custom_prompt(self):\n        \"\"\"Save custom prompt\"\"\"\n        content = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        with open(self.current_custom_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Task saved to {os.path.basename(self.current_custom_file)}\")\n    \n    def save_custom_as(self):\n        \"\"\"Save custom as\"\"\"\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"custom.md\")\n        if path:\n            self.current_custom_file = path\n            self.save_custom_prompt()\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n    \n    def load_custom_file(self):\n        \"\"\"Load custom file\"\"\"\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_custom_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.custom_prompt.delete(\"1.0\", tk.END)\n                self.custom_prompt.insert(\"1.0\", f.read())\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n    \n    def save_history_as(self):\n        \"\"\"Save history as\"\"\"\n        path = filedialog.asksaveasfilename(defaultextension=\".json\", initialfile=\"history_export.json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.history, f, indent=4)\n            self.set_status(\"History exported.\")\n\nif __name__ == \"__main__\":\n    root = ctk.CTk()\n    app = ModernPromptGUI(root)\n    root.mainloop()\n",
            "pinned": false
        },
        {
            "id": 1768928624.879383,
            "time": "2026-01-20 11:03:44",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.",
            "custom_used": "Modify ask.py as follows:\nIntegrate Full mouse support, right click, left clicl, roller  wheel, ctrl + mouse, etc, like any regular dektop program do.\nLet the mouse able to work in all the program window, not only inside text-areas, but outsite like select buttoms text, etc.\nFix auto-scroll for all text-areas include full mouse support to them too.",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/ask-viejo/ask.py"
            ],
            "full_content": "[Aviso: El prompt es largo y se enviar\u00e1 por partes]\n\nYou are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.\n\n---\n\nModify ask.py as follows:\nIntegrate Full mouse support, right click, left clicl, roller  wheel, ctrl + mouse, etc, like any regular dektop program do.\nLet the mouse able to work in all the program window, not only inside text-areas, but outsite like select buttoms text, etc.\nFix auto-scroll for all text-areas include full mouse support to them too.\n\n---\n\n\n[Filename: ask.py]\n[Path: /home/deb/borednomore3/borednomore3/ask-viejo/ask.py]\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox\nimport customtkinter as ctk  # Libreria mas moderna solicitada\nimport os\nimport subprocess\nimport datetime\nimport json\nimport webbrowser\nimport signal\nimport sys\n\n# Configuraci\u00f3n inicial de apariencia\nctk.set_appearance_mode(\"dark\")\n# DEBUG: Color theme updated to 'blue' but components will be customized further\nctk.set_default_color_theme(\"blue\")\n\nclass ModernPromptGUI:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Prompt Engine \u2022 Ultra Modern\")\n        self.root.geometry(\"1280x850\")\n        self.root.minsize(1000, 750)\n\n        # DEBUG: Initialization started\n        print(f\"[{datetime.datetime.now()}] Initializing ModernPromptGUI...\")\n\n        # Captura de CTRL+C (SIGINT)\n        signal.signal(signal.SIGINT, self.signal_handler)\n\n        self.files = [] # Stores dicts: {'path': str, 'enabled': tk.BooleanVar, 'pinned': tk.BooleanVar}\n        self.history = [] # Stores dicts: {..., 'pinned': bool, 'id': float}\n\n        # Inclusion Switches Variables\n        self.include_rules_var = tk.BooleanVar(value=True)\n        self.include_context_var = tk.BooleanVar(value=True)\n\n        # Default Paths\n        self.prompt_md_path = \"prompt.md\"\n        self.custom_prompt_default = \"custom.md\"\n        self.state_file = \"app_state.json\"\n        \n        # Track current working files for tabs\n        self.current_rules_file = self.prompt_md_path\n        self.current_custom_file = self.custom_prompt_default\n\n        # AI Engines\n        self.ai_engines_path = \"ai_engines.json\"\n        self.ai_engines_data = []\n        # List to track entry widgets for the table\n        self.engine_rows = [] \n        \n        # Carga inicial de datos base si existen\n        self.load_initial_content()\n\n        self.create_widgets()\n        \n        # Seleccionar pesta\u00f1a Custom Prompt por defecto al iniciar\n        self.tabview.set(\"Custom Prompt\")\n\n        # Manejo de cierre de ventana\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n\n        # Cargar estado guardado (incluye archivos de contexto)\n        if os.path.exists(self.state_file):\n            self.load_state()\n        else:\n            # Si no hay estado, intentar auto-cargar los archivos por defecto adjuntos\n            self.auto_load_default_files()\n\n        # Timer de auto-salvado (5 minutos)\n        self.root.after(300000, self.auto_save)\n        \n        print(f\"[{datetime.datetime.now()}] GUI Ready and State Loaded.\")\n\n    def load_initial_content(self):\n        \"\"\"Carga contenido inicial de archivos base o los crea si no existen\"\"\"\n        # Asegurar existencia de archivos m\u00ednimos\n        for fpath in [self.prompt_md_path, self.custom_prompt_default]:\n            if not os.path.exists(fpath):\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(\"\") # Crear vac\u00edo\n\n        if os.path.exists(self.prompt_md_path):\n            with open(self.prompt_md_path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_md_content = f.read()\n\n        # Prioridad absoluta a ai_engines.json\n        if os.path.exists(self.ai_engines_path):\n            try:\n                with open(self.ai_engines_path, \"r\", encoding=\"utf-8\") as f:\n                    self.ai_engines_data = json.load(f)\n                    print(f\"[{datetime.datetime.now()}] Engines loaded from {self.ai_engines_path}\")\n            except Exception as e:\n                print(f\"DEBUG: Error loading ai_engines.json: {e}\")\n\n    def auto_load_default_files(self):\n        \"\"\"Carga archivos espec\u00edficos al contexto si no hay estado previo\"\"\"\n        defaults = [self.ai_engines_path, self.state_file, self.custom_prompt_default, self.prompt_md_path]\n        for path in defaults:\n            abs_path = os.path.abspath(path)\n            if not os.path.exists(abs_path): continue\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=True)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n        self.refresh_file_list_ui()\n\n    def signal_handler(self, sig, frame):\n        \"\"\"Maneja CTRL+C salvando el estado antes de interrumpir\"\"\"\n        print(f\"\\n[{datetime.datetime.now()}] INTERRUPT (Ctrl+C). Saving state...\")\n        self.save_state()\n        sys.exit(0)\n\n    def change_theme(self, new_theme):\n        \"\"\"Cambia el modo de apariencia.\"\"\"\n        ctk.set_appearance_mode(new_theme.lower())\n        self.save_state()\n\n    def create_widgets(self):\n        # Usamos un Tabview de CustomTkinter\n        self.tabview = ctk.CTkTabview(self.root, \n                                     segmented_button_selected_color=\"#3b8ed0\",\n                                     segmented_button_unselected_color=\"#222\",\n                                     segmented_button_selected_hover_color=\"#4fa3e0\")\n        self.tabview.pack(fill=\"both\", expand=True, padx=20, pady=20)\n\n        self.tab_rules = self.tabview.add(\"\u270f Prompt Rules\")\n        self.tab_custom = self.tabview.add(\"Custom Prompt\")\n        self.tab_files = self.tabview.add(\"Context Files\")\n        self.tab_ai = self.tabview.add(\"AI Engines\")\n        self.tab_history = self.tabview.add(\"History\")\n\n        # --- Tab: Prompt Rules ---\n        self.lbl_rules_file = ctk.CTkLabel(self.tab_rules, text=f\"Base System Prompt ({self.current_rules_file})\", font=(\"Inter\", 14, \"bold\"), text_color=\"#3b8ed0\")\n        self.lbl_rules_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.prompt_editor = ctk.CTkTextbox(self.tab_rules, font=(\"JetBrains Mono\", 13), border_width=2, border_color=\"#333\", undo=True)\n        self.prompt_editor.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        self.add_context_menu(self.prompt_editor)\n\n        btn_rules_frame = ctk.CTkFrame(self.tab_rules, fg_color=\"transparent\")\n        btn_rules_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_rules_frame, text=\"Save\", width=100, fg_color=\"#2fa572\", hover_color=\"#218c59\", command=self.save_prompt_md).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Save As...\", width=100, command=self.save_rules_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Load\", width=100, command=self.load_rules_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Clear\", width=100, command=lambda: self.prompt_editor.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Undo\", width=70, fg_color=\"#444\", command=lambda: self.prompt_editor.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Redo\", width=70, fg_color=\"#444\", command=lambda: self.prompt_editor.edit_redo()).pack(side=\"right\", padx=5)\n\n        # --- Tab: Custom Prompt ---\n        self.tab_custom.configure(fg_color=\"#1e1e1e\")\n        self.lbl_custom_file = ctk.CTkLabel(self.tab_custom, text=f\"Current Task ({self.current_custom_file})\", font=(\"Inter\", 14, \"bold\"), text_color=\"#2fa572\")\n        self.lbl_custom_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.custom_prompt = ctk.CTkTextbox(self.tab_custom, font=(\"JetBrains Mono\", 14), border_width=2, border_color=\"#2fa572\", undo=True, fg_color=\"#121212\")\n        self.custom_prompt.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        self.add_context_menu(self.custom_prompt)\n\n        btn_custom_frame = ctk.CTkFrame(self.tab_custom, fg_color=\"transparent\")\n        btn_custom_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_custom_frame, text=\"Save Task\", width=120, fg_color=\"#2fa572\", hover_color=\"#218c59\", font=(\"Inter\", 12, \"bold\"), command=self.save_custom_prompt).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Save As...\", width=100, command=self.save_custom_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Load\", width=100, command=self.load_custom_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Clear\", width=100, command=lambda: self.custom_prompt.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Undo\", width=70, fg_color=\"#444\", command=lambda: self.custom_prompt.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Redo\", width=70, fg_color=\"#444\", command=lambda: self.custom_prompt.edit_redo()).pack(side=\"right\", padx=5)\n\n        # --- Tab: Context Files ---\n        files_header = ctk.CTkFrame(self.tab_files, fg_color=\"#222\")\n        files_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        ctk.CTkLabel(files_header, text=\"INC\", font=(\"Inter\", 11, \"bold\"), width=30).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(files_header, text=\"PIN\", font=(\"Inter\", 11, \"bold\"), width=40).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FILENAME\", font=(\"Inter\", 11, \"bold\"), width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FULL SYSTEM PATH\", font=(\"Inter\", 11, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=10)\n\n        self.files_scroll = ctk.CTkScrollableFrame(self.tab_files, label_text=\"\")\n        self.files_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_files_frame = ctk.CTkFrame(self.tab_files, fg_color=\"transparent\")\n        btn_files_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_files_frame, text=\"Add File\", command=self.add_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_files_frame, text=\"Clear Unpinned\", command=self.clear_files).pack(side=\"left\", padx=5)\n\n        # --- Tab: AI Engines ---\n        ai_table_header = ctk.CTkFrame(self.tab_ai, fg_color=\"#222\")\n        ai_table_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        ctk.CTkLabel(ai_table_header, text=\"URL\", font=(\"Inter\", 12, \"bold\"), width=400, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(ai_table_header, text=\"Description\", font=(\"Inter\", 12, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=35)\n\n        self.ai_scroll = ctk.CTkScrollableFrame(self.tab_ai, label_text=\"\")\n        self.ai_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_ai_frame = ctk.CTkFrame(self.tab_ai, fg_color=\"transparent\")\n        btn_ai_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_ai_frame, text=\"Save Engines\", width=120, fg_color=\"#2fa572\", command=self.save_ai_engines).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Save As...\", width=100, command=self.save_ai_engines_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Load File\", width=100, command=self.load_ai_engines_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Add Row\", fg_color=\"#1f538d\", hover_color=\"darkgreen\", width=100, command=self.add_ai_row).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Clear All\", width=100, command=self.clear_ai_engines).pack(side=\"left\", padx=5)\n        \n        self.refresh_ai_list()\n\n        # --- Tab: History ---\n        # NUEVO: Cabecera para identificar campos del historial\n        self.setup_history_header()\n\n        self.history_scroll = ctk.CTkScrollableFrame(self.tab_history, label_text=\"Prompt History Log\", label_text_color=\"#3b8ed0\")\n        self.history_scroll.pack(fill=\"both\", expand=True, padx=12, pady=12)\n        \n        btn_hist_frame = ctk.CTkFrame(self.tab_history, fg_color=\"transparent\")\n        btn_hist_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_hist_frame, text=\"Clear All History\", command=self.clear_history).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_hist_frame, text=\"Save History As...\", command=self.save_history_as).pack(side=\"left\", padx=5)\n\n        # Bottom Action Bar\n        self.bottom_frame = ctk.CTkFrame(self.root, height=80, border_width=1, border_color=\"#444\", fg_color=\"#1a1a1a\")\n        self.bottom_frame.pack(fill=\"x\", side=\"bottom\", padx=20, pady=20)\n\n        self.cb_rules = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Rules\", variable=self.include_rules_var, command=self.save_state)\n        self.cb_rules.pack(side=\"left\", padx=10)\n        \n        self.cb_context = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Context\", variable=self.include_context_var, command=self.save_state)\n        self.cb_context.pack(side=\"left\", padx=10)\n\n        ctk.CTkButton(self.bottom_frame, text=\"\ud83d\ude80 GENERATE PROMPT & COPY TO CLIPBOARD\", fg_color=\"#2fa572\", hover_color=\"#218c59\", font=(\"Inter\", 14, \"bold\"), command=self.generate_prompt).pack(side=\"left\", padx=20)\n        \n        ctk.CTkButton(self.bottom_frame, text=\"EXIT\", fg_color=\"#b02a37\", hover_color=\"#8c1c27\", width=60, command=self.on_close).pack(side=\"right\", padx=10)\n\n        self.theme_menu = ctk.CTkOptionMenu(self.bottom_frame, values=[\"Dark\", \"Light\", \"System\"], width=100, command=self.change_theme)\n        self.theme_menu.pack(side=\"right\", padx=10)\n\n        self.status_label = ctk.CTkLabel(self.bottom_frame, text=\"Ready\", font=(\"Inter\", 12), text_color=\"#aaa\")\n        self.status_label.pack(side=\"right\", padx=20)\n\n    # NUEVO: Titulos de cabecera para el historial\n    def setup_history_header(self):\n        header_frame = ctk.CTkFrame(self.tab_history, fg_color=\"#222\", height=30)\n        header_frame.pack(fill=\"x\", padx=12, pady=(10, 0))\n        \n        ctk.CTkLabel(header_frame, text=\"TYPE\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(header_frame, text=\"PIN\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(header_frame, text=\"DATE/TIME\", font=(\"Inter\", 10, \"bold\"), width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(header_frame, text=\"TASK PREVIEW / CONTENT\", font=(\"Inter\", 10, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=20)\n\n    # --- Mouse Context Menu - MEJORADO PARA FUNCIONAR CON RATON ---\n    def add_context_menu(self, widget):\n        \"\"\"Adds a standard right-click context menu with internal mapping fix\"\"\"\n        menu = tk.Menu(widget, tearoff=0, bg=\"#2b2b2b\", fg=\"white\", activebackground=\"#3b8ed0\", borderwidth=0)\n        \n        # Mapeo explicito para que el raton funcione sobre el foco actual\n        menu.add_command(label=\"Cut\", command=lambda: widget.event_generate(\"<<Cut>>\"))\n        menu.add_command(label=\"Copy\", command=lambda: widget.event_generate(\"<<Copy>>\"))\n        menu.add_command(label=\"Paste\", command=lambda: widget.event_generate(\"<<Paste>>\"))\n        menu.add_separator()\n        menu.add_command(label=\"Select All\", command=lambda: widget.event_generate(\"<<SelectAll>>\"))\n\n        def show_menu(event):\n            widget.focus_set() # FIX: Asegura que el foco este en el widget antes de popup\n            try:\n                menu.tk_popup(event.x_root, event.y_root)\n            finally:\n                menu.grab_release()\n\n        widget.bind(\"<Button-3>\", show_menu)\n\n    # --- Funcionalidades de Archivos ---\n\n    def add_file(self):\n        paths = filedialog.askopenfilenames()\n        for path in paths:\n            abs_path = os.path.abspath(path)\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=False)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    def toggle_pin(self, path):\n        self.save_state()\n        self.refresh_file_list_ui()\n\n    def remove_file(self, path):\n        self.files = [f for f in self.files if f['path'] != path]\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    def refresh_file_list_ui(self):\n        for widget in self.files_scroll.winfo_children():\n            widget.destroy()\n        \n        for f_obj in self.files:\n            frame = ctk.CTkFrame(self.files_scroll, fg_color=\"transparent\")\n            frame.pack(fill=\"x\", pady=2)\n\n            ctk.CTkCheckBox(frame, text=\"\", width=20, variable=f_obj['enabled'], command=self.save_state).pack(side=\"left\", padx=2)\n            ctk.CTkCheckBox(frame, text=\"\ud83d\udccc\", width=40, variable=f_obj['pinned'], command=lambda p=f_obj['path']: self.toggle_pin(p)).pack(side=\"left\", padx=5)\n            \n            name_color = \"#3b8ed0\" if f_obj['pinned'].get() else \"white\"\n            ctk.CTkLabel(frame, text=os.path.basename(f_obj['path']), font=(\"Inter\", 12, \"bold\"), text_color=name_color, width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n            ctk.CTkLabel(frame, text=f_obj['path'], font=(\"Inter\", 10), text_color=\"gray\").pack(side=\"left\", padx=10)\n            \n            ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", hover_color=\"#8c1c27\", command=lambda p=f_obj['path']: self.remove_file(p)).pack(side=\"right\", padx=5)\n\n    def clear_files(self):\n        self.files = [f for f in self.files if f['pinned'].get()]\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    # --- AI Engines Logic ---\n\n    def refresh_ai_list(self):\n        for widget in self.ai_scroll.winfo_children():\n            widget.destroy()\n        self.engine_rows = []\n        for i, engine in enumerate(self.ai_engines_data):\n            self.create_ai_row_widgets(engine, i)\n\n    def create_ai_row_widgets(self, data, index):\n        frame = ctk.CTkFrame(self.ai_scroll, fg_color=\"transparent\")\n        frame.pack(fill=\"x\", pady=2)\n        \n        url_entry = ctk.CTkEntry(frame, width=400, font=(\"JetBrains Mono\", 12))\n        url_entry.insert(0, data.get('url', ''))\n        url_entry.pack(side=\"left\", padx=5)\n        self.add_context_menu(url_entry)\n\n        desc_entry = ctk.CTkEntry(frame, font=(\"Inter\", 12))\n        desc_entry.insert(0, data.get('description', ''))\n        desc_entry.pack(side=\"left\", fill=\"x\", expand=True, padx=5)\n        self.add_context_menu(desc_entry)\n\n        ctk.CTkButton(frame, text=\"GO\", width=40, command=lambda u=url_entry: webbrowser.open(u.get())).pack(side=\"left\", padx=2)\n        ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", hover_color=\"#8c1c27\", command=lambda idx=index: self.remove_ai_row(idx)).pack(side=\"left\", padx=2)\n        \n        self.engine_rows.append({'url': url_entry, 'desc': desc_entry, 'frame': frame})\n\n    def add_ai_row(self):\n        self.ai_engines_data.append({\"url\": \"\", \"description\": \"\"})\n        self.refresh_ai_list()\n\n    def remove_ai_row(self, index):\n        self.sync_engines_from_ui()\n        if 0 <= index < len(self.ai_engines_data):\n            self.ai_engines_data.pop(index)\n        self.refresh_ai_list()\n        self.save_state()\n\n    def sync_engines_from_ui(self):\n        new_data = []\n        for row in self.engine_rows:\n            new_data.append({\"url\": row['url'].get(), \"description\": row['desc'].get()})\n        self.ai_engines_data = new_data\n\n    def save_ai_engines(self):\n        self.sync_engines_from_ui()\n        with open(self.ai_engines_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.ai_engines_data, f, indent=4)\n        self.save_state()\n        self.set_status(\"AI Engines saved to JSON\")\n\n    def save_ai_engines_as(self):\n        self.sync_engines_from_ui()\n        path = filedialog.asksaveasfilename(defaultextension=\".json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.ai_engines_data, f, indent=4)\n            self.set_status(f\"Saved to {os.path.basename(path)}\")\n\n    def load_ai_engines_file(self):\n        path = filedialog.askopenfilename(filetypes=[(\"JSON\", \"*.json\")])\n        if path:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.ai_engines_data = json.load(f)\n            self.refresh_ai_list()\n            self.save_state()\n\n    def clear_ai_engines(self):\n        self.ai_engines_data = []\n        self.refresh_ai_list()\n        self.save_state()\n\n    # --- Historia Logic ---\n\n    def add_to_history(self, prompt_text):\n        entry = {\n            'id': datetime.datetime.now().timestamp(),\n            'time': datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            'rules_used': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_used': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [f['path'] for f in self.files if f['enabled'].get()],\n            'full_content': prompt_text,\n            'pinned': False\n        }\n        self.history.insert(0, entry)\n        self.refresh_history_ui()\n        self.save_state()\n\n    def toggle_history_pin(self, entry_id):\n        for item in self.history:\n            if item.get('id') == entry_id:\n                item['pinned'] = not item.get('pinned', False)\n                break\n        self.refresh_history_ui()\n        self.save_state()\n\n    def remove_history_item(self, entry_id):\n        self.history = [item for item in self.history if item.get('id') != entry_id]\n        self.refresh_history_ui()\n        self.save_state()\n\n    def clear_history(self):\n        self.history = [h for h in self.history if h.get('pinned')]\n        self.refresh_history_ui()\n        self.save_state()\n\n    def refresh_history_ui(self):\n        for widget in self.history_scroll.winfo_children():\n            widget.destroy()\n        \n        # Pinned first, then sorted by timestamp\n        sorted_history = sorted(self.history, key=lambda x: (not x.get('pinned', False), -x.get('id', 0)))\n        \n        for entry in sorted_history:\n            self.render_history_item(entry)\n\n    def render_history_item(self, entry):\n        entry_id = entry.get('id', datetime.datetime.now().timestamp())\n        is_pinned = entry.get('pinned', False)\n        \n        # Feedback visual para items anclados\n        bg_color = \"#1e3d2f\" if is_pinned else \"transparent\"\n        item_frame = ctk.CTkFrame(self.history_scroll, border_width=1, fg_color=bg_color)\n        item_frame.pack(fill=\"x\", pady=2, padx=5)\n        \n        header_frame = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        header_frame.pack(fill=\"x\", padx=5, pady=2)\n        \n        # TYPE icon\n        ctk.CTkLabel(header_frame, text=\"\ud83d\udcdc\", width=35).pack(side=\"left\", padx=5)\n        \n        # PIN Button\n        pin_text = \"\ud83d\udccc\" if is_pinned else \"\ud83d\udccd\"\n        ctk.CTkButton(header_frame, text=pin_text, width=35, height=24, fg_color=\"transparent\", \n                      command=lambda: self.toggle_history_pin(entry_id)).pack(side=\"left\", padx=2)\n\n        # DATE\n        ctk.CTkLabel(header_frame, text=entry['time'], font=(\"Inter\", 11), width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # PREVIEW (Alineado con cabecera)\n        summary = entry.get('custom_used', \"\").replace(\"\\n\", \" \")[:80]\n        ctk.CTkLabel(header_frame, text=summary, font=(\"Inter\", 11), text_color=\"#aaa\", anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # Botones finales\n        ctk.CTkButton(header_frame, text=\"X\", width=30, height=24, fg_color=\"#b02a37\", command=lambda: self.remove_history_item(entry_id)).pack(side=\"right\", padx=5)\n        ctk.CTkButton(header_frame, text=\"Copy\", width=60, height=24, command=lambda: self.copy_to_clipboard(entry.get('full_content', \"\"))).pack(side=\"right\", padx=5)\n\n        # Tree Nodes Container\n        tree_container = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        main_expanded = tk.BooleanVar(value=False)\n        \n        def toggle_main():\n            if main_expanded.get():\n                tree_container.pack_forget()\n                btn_main_toggle.configure(text=\"\u25b6\")\n                main_expanded.set(False)\n            else:\n                tree_container.pack(fill=\"x\", padx=40, pady=(0, 10))\n                btn_main_toggle.configure(text=\"\u25bc\")\n                main_expanded.set(True)\n\n        btn_main_toggle = ctk.CTkButton(header_frame, text=\"\u25b6\", width=30, fg_color=\"transparent\", command=toggle_main)\n        btn_main_toggle.pack(side=\"right\", padx=5)\n\n        self.create_tree_node(tree_container, \"\ud83d\udcdc Prompt Rules\", entry.get('rules_used', \"\"))\n        self.create_tree_node(tree_container, \"\u270d Custom Prompt\", entry.get('custom_used', \"\"))\n        self.create_tree_node(tree_container, \"\ud83d\udcc1 Context Files\", \"\\n\".join(entry.get('context_files', [])) or \"No files.\")\n        self.create_tree_node(tree_container, \"\ud83d\ude80 Full Content\", entry.get('full_content', \"\"))\n\n    def create_tree_node(self, parent, label, content):\n        node_frame = ctk.CTkFrame(parent, fg_color=\"transparent\")\n        node_frame.pack(fill=\"x\", pady=1)\n        is_open = tk.BooleanVar(value=False)\n        content_box_container = [None] \n\n        def toggle_node():\n            if is_open.get():\n                if content_box_container[0]: content_box_container[0].destroy()\n                btn_node.configure(text=f\"  + {label}\")\n                is_open.set(False)\n            else:\n                tb = ctk.CTkTextbox(node_frame, height=150, font=(\"JetBrains Mono\", 11))\n                tb.insert(\"1.0\", content)\n                tb.configure(state=\"disabled\")\n                tb.pack(fill=\"x\", padx=20, pady=5)\n                content_box_container[0] = tb\n                btn_node.configure(text=f\"  - {label}\")\n                is_open.set(True)\n                self.add_context_menu(tb)\n\n        btn_node = ctk.CTkButton(node_frame, text=f\"  + {label}\", anchor=\"w\", fg_color=\"transparent\", \n                                 text_color=\"#aaa\", hover_color=\"#222\", height=24, command=toggle_node)\n        btn_node.pack(fill=\"x\")\n\n    # --- Core Logic ---\n\n    def generate_prompt(self):\n        parts = []\n        \n        # 1. Base Rules\n        if self.include_rules_var.get():\n            rules = self.prompt_editor.get(\"1.0\", tk.END).strip()\n            if rules:\n                parts.append(rules)\n        \n        # 2. Custom Prompt (Current Task)\n        custom = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        if custom:\n            parts.append(custom)\n        \n        # 3. Context Files\n        if self.include_context_var.get():\n            for f_obj in self.files:\n                if f_obj['enabled'].get():\n                    fpath = f_obj['path']\n                    if os.path.exists(fpath):\n                        try:\n                            with open(fpath, \"r\", encoding=\"utf-8\") as f:\n                                content = f.read()\n                                header = f\"\\n[Filename: {os.path.basename(fpath)}]\\n[Path: {fpath}]\"\n                                parts.append(header + \"\\n\" + content)\n                        except Exception as e:\n                            print(f\"Error reading {fpath}: {e}\")\n\n        final_prompt = \"\\n\\n---\\n\\n\".join(parts)\n        \n        # L\u00f3gica de Prompt Largo\n        if len(final_prompt) > 15000:\n            if messagebox.askyesno(\"Prompt Largo\", f\"El prompt generado es muy grande ({len(final_prompt)} caracteres).\\n\u00bfDeseas abrir GitHub Gist para subirlo all\u00ed?\"):\n                webbrowser.open(\"https://gist.github.com/\")\n                self.copy_to_clipboard(final_prompt)\n            else:\n                final_prompt = \"[Aviso: El prompt es largo y se enviar\u00e1 por partes]\\n\\n\" + final_prompt\n                self.copy_to_clipboard(final_prompt)\n        else:\n            self.copy_to_clipboard(final_prompt)\n            \n        self.add_to_history(final_prompt)\n        self.set_status(\"\u2713 Prompt Copied to Clipboard\")\n\n    # --- Persistence ---\n\n    def copy_to_clipboard(self, text):\n        self.root.clipboard_clear()\n        self.root.clipboard_append(text)\n\n    def set_status(self, text):\n        self.status_label.configure(text=text)\n        self.root.after(3000, lambda: self.status_label.configure(text=\"Ready\"))\n\n    def save_state(self, *args):\n        self.sync_engines_from_ui() \n        state = {\n            'rules_file': self.current_rules_file,\n            'custom_file': self.current_custom_file,\n            'prompt_md_content': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_prompt_content': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [\n                {'path': f['path'], 'enabled': f['enabled'].get(), 'pinned': f['pinned'].get()} \n                for f in self.files\n            ],\n            'inc_rules': self.include_rules_var.get(),\n            'inc_context': self.include_context_var.get(),\n            'history': self.history,\n            'ai_engines': self.ai_engines_data\n        }\n        with open(self.state_file, 'w', encoding=\"utf-8\") as f:\n            json.dump(state, f, indent=4)\n\n    def load_state(self):\n        if not os.path.exists(self.state_file):\n            return\n        \n        try:\n            with open(self.state_file, 'r', encoding=\"utf-8\") as f:\n                state = json.load(f)\n                \n                # Load editor content\n                self.prompt_editor.insert(\"1.0\", state.get('prompt_md_content', ''))\n                self.custom_prompt.insert(\"1.0\", state.get('custom_prompt_content', ''))\n                \n                # Load Flags\n                self.include_rules_var.set(state.get('inc_rules', True))\n                self.include_context_var.set(state.get('inc_context', True))\n                \n                # Load History\n                self.history = state.get('history', [])\n                \n                # Load Engines\n                self.ai_engines_data = state.get('ai_engines', [])\n                \n                # Load files\n                self.files = []\n                for f_data in state.get('context_files', []):\n                    if os.path.exists(f_data['path']):\n                        self.files.append({\n                            'path': f_data['path'],\n                            'enabled': tk.BooleanVar(value=f_data['enabled']),\n                            'pinned': tk.BooleanVar(value=f_data['pinned'])\n                        })\n                \n                self.refresh_file_list_ui()\n                self.refresh_history_ui()\n                self.refresh_ai_list()\n        except Exception as e:\n            print(f\"Error loading state: {e}\")\n\n    def auto_save(self):\n        self.save_state()\n        self.root.after(300000, self.auto_save)\n\n    def on_close(self):\n        self.save_state()\n        self.root.destroy()\n\n    # --- File Manager Methods ---\n\n    def save_prompt_md(self):\n        content = self.prompt_editor.get(\"1.0\", tk.END).strip()\n        with open(self.current_rules_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Rules saved to {os.path.basename(self.current_rules_file)}\")\n\n    def save_rules_as(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"prompt.md\")\n        if path:\n            self.current_rules_file = path\n            self.save_prompt_md()\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n\n    def load_rules_file(self):\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_rules_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_editor.delete(\"1.0\", tk.END)\n                self.prompt_editor.insert(\"1.0\", f.read())\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n\n    def save_custom_prompt(self):\n        content = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        with open(self.current_custom_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Task saved to {os.path.basename(self.current_custom_file)}\")\n\n    def save_custom_as(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"custom.md\")\n        if path:\n            self.current_custom_file = path\n            self.save_custom_prompt()\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n\n    def load_custom_file(self):\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_custom_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.custom_prompt.delete(\"1.0\", tk.END)\n                self.custom_prompt.insert(\"1.0\", f.read())\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n\n    def save_history_as(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".json\", initialfile=\"history_export.json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.history, f, indent=4)\n            self.set_status(\"History exported.\")\n\nif __name__ == \"__main__\":\n    root = ctk.CTk()\n    app = ModernPromptGUI(root)\n    root.mainloop()\n",
            "pinned": false
        },
        {
            "id": 1768928462.104202,
            "time": "2026-01-20 11:01:02",
            "rules_used": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.",
            "custom_used": "Modify ask.py as follows:\nIntegrate Full mouse support, right click, left clicl, roller  wheel, ctrl + mouse, etc, like any regular dektop program do.\nLet the mouse able to work in all the program window, not only inside text-areas, but outsite like select buttoms text, etc.\nFix auto-scroll for all text-areas include full mouse support to them too.",
            "context_files": [
                "/home/deb/borednomore3/borednomore3/ask-viejo/ask.py"
            ],
            "full_content": "You are a programming assistant with persistent memory.\n\nMandatory rules:\n1. Never delete, overwrite, or optimize existing functions. The original code must remain untouched.\n2. Do not remove or alter comments, docstrings, or formatting in the original source files.\n3. Only add or adapt the specific function or section explicitly assigned. Never modify unrelated code.\n4. Always preserve previous code and show it fully before modifying.\n5. Every change must be incremental, auditable, and reversible.\n6. Keep debug output visible at every stage.\n7. If you lose context, ask for confirmation before acting.\n8. Do not invent new functions unrelated to the current flow.\n9. Always use clear comments in English to document each adjustment.\n10. Maintain consistency in file names, functions, and variables.\n11. Each response must include the full updated source code, not just fragments.\n12. Always show the filename and full absolute path before presenting any code.\n13. Do not provide snippets, summaries, or partial explanations \u2014 only complete code listings with context.\n14. If modifications are requested, reprint the entire file with changes applied, never partial diffs.\n15. If a rule conflicts, prioritize showing complete source code with filename and path.\n16. Warn explicitly if any requested change could cause loss of existing functionality.\n17. If a file is too large to fit in a single response, deliver the entire file in sequential parts, clearly labeled (e.g., \"Part 1 of N\"), until the full source code has been shown. Never omit or skip sections.\n18. Never attempt to optimize or refactor existing code unless explicitly instructed. Focus only on the assigned addition/adaptation.\n\n---\n\nModify ask.py as follows:\nIntegrate Full mouse support, right click, left clicl, roller  wheel, ctrl + mouse, etc, like any regular dektop program do.\nLet the mouse able to work in all the program window, not only inside text-areas, but outsite like select buttoms text, etc.\nFix auto-scroll for all text-areas include full mouse support to them too.\n\n---\n\n\n[Filename: ask.py]\n[Path: /home/deb/borednomore3/borednomore3/ask-viejo/ask.py]\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox\nimport customtkinter as ctk  # Libreria mas moderna solicitada\nimport os\nimport subprocess\nimport datetime\nimport json\nimport webbrowser\nimport signal\nimport sys\n\n# Configuraci\u00f3n inicial de apariencia\nctk.set_appearance_mode(\"dark\")\n# DEBUG: Color theme updated to 'blue' but components will be customized further\nctk.set_default_color_theme(\"blue\")\n\nclass ModernPromptGUI:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Prompt Engine \u2022 Ultra Modern\")\n        self.root.geometry(\"1280x850\")\n        self.root.minsize(1000, 750)\n\n        # DEBUG: Initialization started\n        print(f\"[{datetime.datetime.now()}] Initializing ModernPromptGUI...\")\n\n        # Captura de CTRL+C (SIGINT)\n        signal.signal(signal.SIGINT, self.signal_handler)\n\n        self.files = [] # Stores dicts: {'path': str, 'enabled': tk.BooleanVar, 'pinned': tk.BooleanVar}\n        self.history = [] # Stores dicts: {..., 'pinned': bool, 'id': float}\n\n        # Inclusion Switches Variables\n        self.include_rules_var = tk.BooleanVar(value=True)\n        self.include_context_var = tk.BooleanVar(value=True)\n\n        # Default Paths\n        self.prompt_md_path = \"prompt.md\"\n        self.custom_prompt_default = \"custom.md\"\n        self.state_file = \"app_state.json\"\n        \n        # Track current working files for tabs\n        self.current_rules_file = self.prompt_md_path\n        self.current_custom_file = self.custom_prompt_default\n\n        # AI Engines\n        self.ai_engines_path = \"ai_engines.json\"\n        self.ai_engines_data = []\n        # List to track entry widgets for the table\n        self.engine_rows = [] \n        \n        # Carga inicial de datos base si existen\n        self.load_initial_content()\n\n        self.create_widgets()\n        \n        # Seleccionar pesta\u00f1a Custom Prompt por defecto al iniciar\n        self.tabview.set(\"Custom Prompt\")\n\n        # Manejo de cierre de ventana\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_close)\n\n        # Cargar estado guardado (incluye archivos de contexto)\n        if os.path.exists(self.state_file):\n            self.load_state()\n        else:\n            # Si no hay estado, intentar auto-cargar los archivos por defecto adjuntos\n            self.auto_load_default_files()\n\n        # Timer de auto-salvado (5 minutos)\n        self.root.after(300000, self.auto_save)\n        \n        print(f\"[{datetime.datetime.now()}] GUI Ready and State Loaded.\")\n\n    def load_initial_content(self):\n        \"\"\"Carga contenido inicial de archivos base o los crea si no existen\"\"\"\n        # Asegurar existencia de archivos m\u00ednimos\n        for fpath in [self.prompt_md_path, self.custom_prompt_default]:\n            if not os.path.exists(fpath):\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(\"\") # Crear vac\u00edo\n\n        if os.path.exists(self.prompt_md_path):\n            with open(self.prompt_md_path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_md_content = f.read()\n\n        # Prioridad absoluta a ai_engines.json\n        if os.path.exists(self.ai_engines_path):\n            try:\n                with open(self.ai_engines_path, \"r\", encoding=\"utf-8\") as f:\n                    self.ai_engines_data = json.load(f)\n                    print(f\"[{datetime.datetime.now()}] Engines loaded from {self.ai_engines_path}\")\n            except Exception as e:\n                print(f\"DEBUG: Error loading ai_engines.json: {e}\")\n\n    def auto_load_default_files(self):\n        \"\"\"Carga archivos espec\u00edficos al contexto si no hay estado previo\"\"\"\n        defaults = [self.ai_engines_path, self.state_file, self.custom_prompt_default, self.prompt_md_path]\n        for path in defaults:\n            abs_path = os.path.abspath(path)\n            if not os.path.exists(abs_path): continue\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=True)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n        self.refresh_file_list_ui()\n\n    def signal_handler(self, sig, frame):\n        \"\"\"Maneja CTRL+C salvando el estado antes de interrumpir\"\"\"\n        print(f\"\\n[{datetime.datetime.now()}] INTERRUPT (Ctrl+C). Saving state...\")\n        self.save_state()\n        sys.exit(0)\n\n    def change_theme(self, new_theme):\n        \"\"\"Cambia el modo de apariencia.\"\"\"\n        ctk.set_appearance_mode(new_theme.lower())\n        self.save_state()\n\n    def create_widgets(self):\n        # Usamos un Tabview de CustomTkinter\n        self.tabview = ctk.CTkTabview(self.root, \n                                     segmented_button_selected_color=\"#3b8ed0\",\n                                     segmented_button_unselected_color=\"#222\",\n                                     segmented_button_selected_hover_color=\"#4fa3e0\")\n        self.tabview.pack(fill=\"both\", expand=True, padx=20, pady=20)\n\n        self.tab_rules = self.tabview.add(\"\u270f Prompt Rules\")\n        self.tab_custom = self.tabview.add(\"Custom Prompt\")\n        self.tab_files = self.tabview.add(\"Context Files\")\n        self.tab_ai = self.tabview.add(\"AI Engines\")\n        self.tab_history = self.tabview.add(\"History\")\n\n        # --- Tab: Prompt Rules ---\n        self.lbl_rules_file = ctk.CTkLabel(self.tab_rules, text=f\"Base System Prompt ({self.current_rules_file})\", font=(\"Inter\", 14, \"bold\"), text_color=\"#3b8ed0\")\n        self.lbl_rules_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.prompt_editor = ctk.CTkTextbox(self.tab_rules, font=(\"JetBrains Mono\", 13), border_width=2, border_color=\"#333\", undo=True)\n        self.prompt_editor.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        self.add_context_menu(self.prompt_editor)\n\n        btn_rules_frame = ctk.CTkFrame(self.tab_rules, fg_color=\"transparent\")\n        btn_rules_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_rules_frame, text=\"Save\", width=100, fg_color=\"#2fa572\", hover_color=\"#218c59\", command=self.save_prompt_md).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Save As...\", width=100, command=self.save_rules_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Load\", width=100, command=self.load_rules_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Clear\", width=100, command=lambda: self.prompt_editor.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Undo\", width=70, fg_color=\"#444\", command=lambda: self.prompt_editor.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_rules_frame, text=\"Redo\", width=70, fg_color=\"#444\", command=lambda: self.prompt_editor.edit_redo()).pack(side=\"right\", padx=5)\n\n        # --- Tab: Custom Prompt ---\n        self.tab_custom.configure(fg_color=\"#1e1e1e\")\n        self.lbl_custom_file = ctk.CTkLabel(self.tab_custom, text=f\"Current Task ({self.current_custom_file})\", font=(\"Inter\", 14, \"bold\"), text_color=\"#2fa572\")\n        self.lbl_custom_file.pack(anchor=\"w\", padx=12, pady=(12,6))\n        \n        self.custom_prompt = ctk.CTkTextbox(self.tab_custom, font=(\"JetBrains Mono\", 14), border_width=2, border_color=\"#2fa572\", undo=True, fg_color=\"#121212\")\n        self.custom_prompt.pack(fill=\"both\", expand=True, padx=12, pady=(0,12))\n        self.add_context_menu(self.custom_prompt)\n\n        btn_custom_frame = ctk.CTkFrame(self.tab_custom, fg_color=\"transparent\")\n        btn_custom_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_custom_frame, text=\"Save Task\", width=120, fg_color=\"#2fa572\", hover_color=\"#218c59\", font=(\"Inter\", 12, \"bold\"), command=self.save_custom_prompt).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Save As...\", width=100, command=self.save_custom_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Load\", width=100, command=self.load_custom_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Clear\", width=100, command=lambda: self.custom_prompt.delete(\"1.0\", tk.END)).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Undo\", width=70, fg_color=\"#444\", command=lambda: self.custom_prompt.edit_undo()).pack(side=\"right\", padx=5)\n        ctk.CTkButton(btn_custom_frame, text=\"Redo\", width=70, fg_color=\"#444\", command=lambda: self.custom_prompt.edit_redo()).pack(side=\"right\", padx=5)\n\n        # --- Tab: Context Files ---\n        files_header = ctk.CTkFrame(self.tab_files, fg_color=\"#222\")\n        files_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        ctk.CTkLabel(files_header, text=\"INC\", font=(\"Inter\", 11, \"bold\"), width=30).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(files_header, text=\"PIN\", font=(\"Inter\", 11, \"bold\"), width=40).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FILENAME\", font=(\"Inter\", 11, \"bold\"), width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n        ctk.CTkLabel(files_header, text=\"FULL SYSTEM PATH\", font=(\"Inter\", 11, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=10)\n\n        self.files_scroll = ctk.CTkScrollableFrame(self.tab_files, label_text=\"\")\n        self.files_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_files_frame = ctk.CTkFrame(self.tab_files, fg_color=\"transparent\")\n        btn_files_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_files_frame, text=\"Add File\", command=self.add_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_files_frame, text=\"Clear Unpinned\", command=self.clear_files).pack(side=\"left\", padx=5)\n\n        # --- Tab: AI Engines ---\n        ai_table_header = ctk.CTkFrame(self.tab_ai, fg_color=\"#222\")\n        ai_table_header.pack(fill=\"x\", padx=15, pady=(10, 0))\n        ctk.CTkLabel(ai_table_header, text=\"URL\", font=(\"Inter\", 12, \"bold\"), width=400, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(ai_table_header, text=\"Description\", font=(\"Inter\", 12, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=35)\n\n        self.ai_scroll = ctk.CTkScrollableFrame(self.tab_ai, label_text=\"\")\n        self.ai_scroll.pack(fill=\"both\", expand=True, padx=12, pady=(0, 12))\n        \n        btn_ai_frame = ctk.CTkFrame(self.tab_ai, fg_color=\"transparent\")\n        btn_ai_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_ai_frame, text=\"Save Engines\", width=120, fg_color=\"#2fa572\", command=self.save_ai_engines).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Save As...\", width=100, command=self.save_ai_engines_as).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Load File\", width=100, command=self.load_ai_engines_file).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Add Row\", fg_color=\"#1f538d\", hover_color=\"darkgreen\", width=100, command=self.add_ai_row).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_ai_frame, text=\"Clear All\", width=100, command=self.clear_ai_engines).pack(side=\"left\", padx=5)\n        \n        self.refresh_ai_list()\n\n        # --- Tab: History ---\n        # NUEVO: Cabecera para identificar campos del historial\n        self.setup_history_header()\n\n        self.history_scroll = ctk.CTkScrollableFrame(self.tab_history, label_text=\"Prompt History Log\", label_text_color=\"#3b8ed0\")\n        self.history_scroll.pack(fill=\"both\", expand=True, padx=12, pady=12)\n        \n        btn_hist_frame = ctk.CTkFrame(self.tab_history, fg_color=\"transparent\")\n        btn_hist_frame.pack(fill=\"x\", padx=12, pady=(0,12))\n        ctk.CTkButton(btn_hist_frame, text=\"Clear All History\", command=self.clear_history).pack(side=\"left\", padx=5)\n        ctk.CTkButton(btn_hist_frame, text=\"Save History As...\", command=self.save_history_as).pack(side=\"left\", padx=5)\n\n        # Bottom Action Bar\n        self.bottom_frame = ctk.CTkFrame(self.root, height=80, border_width=1, border_color=\"#444\", fg_color=\"#1a1a1a\")\n        self.bottom_frame.pack(fill=\"x\", side=\"bottom\", padx=20, pady=20)\n\n        self.cb_rules = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Rules\", variable=self.include_rules_var, command=self.save_state)\n        self.cb_rules.pack(side=\"left\", padx=10)\n        \n        self.cb_context = ctk.CTkCheckBox(self.bottom_frame, text=\"Include Context\", variable=self.include_context_var, command=self.save_state)\n        self.cb_context.pack(side=\"left\", padx=10)\n\n        ctk.CTkButton(self.bottom_frame, text=\"\ud83d\ude80 GENERATE PROMPT & COPY TO CLIPBOARD\", fg_color=\"#2fa572\", hover_color=\"#218c59\", font=(\"Inter\", 14, \"bold\"), command=self.generate_prompt).pack(side=\"left\", padx=20)\n        \n        ctk.CTkButton(self.bottom_frame, text=\"EXIT\", fg_color=\"#b02a37\", hover_color=\"#8c1c27\", width=60, command=self.on_close).pack(side=\"right\", padx=10)\n\n        self.theme_menu = ctk.CTkOptionMenu(self.bottom_frame, values=[\"Dark\", \"Light\", \"System\"], width=100, command=self.change_theme)\n        self.theme_menu.pack(side=\"right\", padx=10)\n\n        self.status_label = ctk.CTkLabel(self.bottom_frame, text=\"Ready\", font=(\"Inter\", 12), text_color=\"#aaa\")\n        self.status_label.pack(side=\"right\", padx=20)\n\n    # NUEVO: Titulos de cabecera para el historial\n    def setup_history_header(self):\n        header_frame = ctk.CTkFrame(self.tab_history, fg_color=\"#222\", height=30)\n        header_frame.pack(fill=\"x\", padx=12, pady=(10, 0))\n        \n        ctk.CTkLabel(header_frame, text=\"TYPE\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=5)\n        ctk.CTkLabel(header_frame, text=\"PIN\", font=(\"Inter\", 10, \"bold\"), width=35).pack(side=\"left\", padx=2)\n        ctk.CTkLabel(header_frame, text=\"DATE/TIME\", font=(\"Inter\", 10, \"bold\"), width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        ctk.CTkLabel(header_frame, text=\"TASK PREVIEW / CONTENT\", font=(\"Inter\", 10, \"bold\"), anchor=\"w\").pack(side=\"left\", padx=20)\n\n    # --- Mouse Context Menu - MEJORADO PARA FUNCIONAR CON RATON ---\n    def add_context_menu(self, widget):\n        \"\"\"Adds a standard right-click context menu with internal mapping fix\"\"\"\n        menu = tk.Menu(widget, tearoff=0, bg=\"#2b2b2b\", fg=\"white\", activebackground=\"#3b8ed0\", borderwidth=0)\n        \n        # Mapeo explicito para que el raton funcione sobre el foco actual\n        menu.add_command(label=\"Cut\", command=lambda: widget.event_generate(\"<<Cut>>\"))\n        menu.add_command(label=\"Copy\", command=lambda: widget.event_generate(\"<<Copy>>\"))\n        menu.add_command(label=\"Paste\", command=lambda: widget.event_generate(\"<<Paste>>\"))\n        menu.add_separator()\n        menu.add_command(label=\"Select All\", command=lambda: widget.event_generate(\"<<SelectAll>>\"))\n\n        def show_menu(event):\n            widget.focus_set() # FIX: Asegura que el foco este en el widget antes de popup\n            try:\n                menu.tk_popup(event.x_root, event.y_root)\n            finally:\n                menu.grab_release()\n\n        widget.bind(\"<Button-3>\", show_menu)\n\n    # --- Funcionalidades de Archivos ---\n\n    def add_file(self):\n        paths = filedialog.askopenfilenames()\n        for path in paths:\n            abs_path = os.path.abspath(path)\n            if not any(f['path'] == abs_path for f in self.files):\n                var = tk.BooleanVar(value=True)\n                pin_var = tk.BooleanVar(value=False)\n                self.files.append({'path': abs_path, 'enabled': var, 'pinned': pin_var})\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    def toggle_pin(self, path):\n        self.save_state()\n        self.refresh_file_list_ui()\n\n    def remove_file(self, path):\n        self.files = [f for f in self.files if f['path'] != path]\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    def refresh_file_list_ui(self):\n        for widget in self.files_scroll.winfo_children():\n            widget.destroy()\n        \n        for f_obj in self.files:\n            frame = ctk.CTkFrame(self.files_scroll, fg_color=\"transparent\")\n            frame.pack(fill=\"x\", pady=2)\n\n            ctk.CTkCheckBox(frame, text=\"\", width=20, variable=f_obj['enabled'], command=self.save_state).pack(side=\"left\", padx=2)\n            ctk.CTkCheckBox(frame, text=\"\ud83d\udccc\", width=40, variable=f_obj['pinned'], command=lambda p=f_obj['path']: self.toggle_pin(p)).pack(side=\"left\", padx=5)\n            \n            name_color = \"#3b8ed0\" if f_obj['pinned'].get() else \"white\"\n            ctk.CTkLabel(frame, text=os.path.basename(f_obj['path']), font=(\"Inter\", 12, \"bold\"), text_color=name_color, width=150, anchor=\"w\").pack(side=\"left\", padx=5)\n            ctk.CTkLabel(frame, text=f_obj['path'], font=(\"Inter\", 10), text_color=\"gray\").pack(side=\"left\", padx=10)\n            \n            ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", hover_color=\"#8c1c27\", command=lambda p=f_obj['path']: self.remove_file(p)).pack(side=\"right\", padx=5)\n\n    def clear_files(self):\n        self.files = [f for f in self.files if f['pinned'].get()]\n        self.refresh_file_list_ui()\n        self.save_state()\n\n    # --- AI Engines Logic ---\n\n    def refresh_ai_list(self):\n        for widget in self.ai_scroll.winfo_children():\n            widget.destroy()\n        self.engine_rows = []\n        for i, engine in enumerate(self.ai_engines_data):\n            self.create_ai_row_widgets(engine, i)\n\n    def create_ai_row_widgets(self, data, index):\n        frame = ctk.CTkFrame(self.ai_scroll, fg_color=\"transparent\")\n        frame.pack(fill=\"x\", pady=2)\n        \n        url_entry = ctk.CTkEntry(frame, width=400, font=(\"JetBrains Mono\", 12))\n        url_entry.insert(0, data.get('url', ''))\n        url_entry.pack(side=\"left\", padx=5)\n        self.add_context_menu(url_entry)\n\n        desc_entry = ctk.CTkEntry(frame, font=(\"Inter\", 12))\n        desc_entry.insert(0, data.get('description', ''))\n        desc_entry.pack(side=\"left\", fill=\"x\", expand=True, padx=5)\n        self.add_context_menu(desc_entry)\n\n        ctk.CTkButton(frame, text=\"GO\", width=40, command=lambda u=url_entry: webbrowser.open(u.get())).pack(side=\"left\", padx=2)\n        ctk.CTkButton(frame, text=\"X\", width=30, fg_color=\"#b02a37\", hover_color=\"#8c1c27\", command=lambda idx=index: self.remove_ai_row(idx)).pack(side=\"left\", padx=2)\n        \n        self.engine_rows.append({'url': url_entry, 'desc': desc_entry, 'frame': frame})\n\n    def add_ai_row(self):\n        self.ai_engines_data.append({\"url\": \"\", \"description\": \"\"})\n        self.refresh_ai_list()\n\n    def remove_ai_row(self, index):\n        self.sync_engines_from_ui()\n        if 0 <= index < len(self.ai_engines_data):\n            self.ai_engines_data.pop(index)\n        self.refresh_ai_list()\n        self.save_state()\n\n    def sync_engines_from_ui(self):\n        new_data = []\n        for row in self.engine_rows:\n            new_data.append({\"url\": row['url'].get(), \"description\": row['desc'].get()})\n        self.ai_engines_data = new_data\n\n    def save_ai_engines(self):\n        self.sync_engines_from_ui()\n        with open(self.ai_engines_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.ai_engines_data, f, indent=4)\n        self.save_state()\n        self.set_status(\"AI Engines saved to JSON\")\n\n    def save_ai_engines_as(self):\n        self.sync_engines_from_ui()\n        path = filedialog.asksaveasfilename(defaultextension=\".json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.ai_engines_data, f, indent=4)\n            self.set_status(f\"Saved to {os.path.basename(path)}\")\n\n    def load_ai_engines_file(self):\n        path = filedialog.askopenfilename(filetypes=[(\"JSON\", \"*.json\")])\n        if path:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.ai_engines_data = json.load(f)\n            self.refresh_ai_list()\n            self.save_state()\n\n    def clear_ai_engines(self):\n        self.ai_engines_data = []\n        self.refresh_ai_list()\n        self.save_state()\n\n    # --- Historia Logic ---\n\n    def add_to_history(self, prompt_text):\n        entry = {\n            'id': datetime.datetime.now().timestamp(),\n            'time': datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            'rules_used': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_used': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [f['path'] for f in self.files if f['enabled'].get()],\n            'full_content': prompt_text,\n            'pinned': False\n        }\n        self.history.insert(0, entry)\n        self.refresh_history_ui()\n        self.save_state()\n\n    def toggle_history_pin(self, entry_id):\n        for item in self.history:\n            if item.get('id') == entry_id:\n                item['pinned'] = not item.get('pinned', False)\n                break\n        self.refresh_history_ui()\n        self.save_state()\n\n    def remove_history_item(self, entry_id):\n        self.history = [item for item in self.history if item.get('id') != entry_id]\n        self.refresh_history_ui()\n        self.save_state()\n\n    def clear_history(self):\n        self.history = [h for h in self.history if h.get('pinned')]\n        self.refresh_history_ui()\n        self.save_state()\n\n    def refresh_history_ui(self):\n        for widget in self.history_scroll.winfo_children():\n            widget.destroy()\n        \n        # Pinned first, then sorted by timestamp\n        sorted_history = sorted(self.history, key=lambda x: (not x.get('pinned', False), -x.get('id', 0)))\n        \n        for entry in sorted_history:\n            self.render_history_item(entry)\n\n    def render_history_item(self, entry):\n        entry_id = entry.get('id', datetime.datetime.now().timestamp())\n        is_pinned = entry.get('pinned', False)\n        \n        # Feedback visual para items anclados\n        bg_color = \"#1e3d2f\" if is_pinned else \"transparent\"\n        item_frame = ctk.CTkFrame(self.history_scroll, border_width=1, fg_color=bg_color)\n        item_frame.pack(fill=\"x\", pady=2, padx=5)\n        \n        header_frame = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        header_frame.pack(fill=\"x\", padx=5, pady=2)\n        \n        # TYPE icon\n        ctk.CTkLabel(header_frame, text=\"\ud83d\udcdc\", width=35).pack(side=\"left\", padx=5)\n        \n        # PIN Button\n        pin_text = \"\ud83d\udccc\" if is_pinned else \"\ud83d\udccd\"\n        ctk.CTkButton(header_frame, text=pin_text, width=35, height=24, fg_color=\"transparent\", \n                      command=lambda: self.toggle_history_pin(entry_id)).pack(side=\"left\", padx=2)\n\n        # DATE\n        ctk.CTkLabel(header_frame, text=entry['time'], font=(\"Inter\", 11), width=120, anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # PREVIEW (Alineado con cabecera)\n        summary = entry.get('custom_used', \"\").replace(\"\\n\", \" \")[:80]\n        ctk.CTkLabel(header_frame, text=summary, font=(\"Inter\", 11), text_color=\"#aaa\", anchor=\"w\").pack(side=\"left\", padx=10)\n        \n        # Botones finales\n        ctk.CTkButton(header_frame, text=\"X\", width=30, height=24, fg_color=\"#b02a37\", command=lambda: self.remove_history_item(entry_id)).pack(side=\"right\", padx=5)\n        ctk.CTkButton(header_frame, text=\"Copy\", width=60, height=24, command=lambda: self.copy_to_clipboard(entry.get('full_content', \"\"))).pack(side=\"right\", padx=5)\n\n        # Tree Nodes Container\n        tree_container = ctk.CTkFrame(item_frame, fg_color=\"transparent\")\n        main_expanded = tk.BooleanVar(value=False)\n        \n        def toggle_main():\n            if main_expanded.get():\n                tree_container.pack_forget()\n                btn_main_toggle.configure(text=\"\u25b6\")\n                main_expanded.set(False)\n            else:\n                tree_container.pack(fill=\"x\", padx=40, pady=(0, 10))\n                btn_main_toggle.configure(text=\"\u25bc\")\n                main_expanded.set(True)\n\n        btn_main_toggle = ctk.CTkButton(header_frame, text=\"\u25b6\", width=30, fg_color=\"transparent\", command=toggle_main)\n        btn_main_toggle.pack(side=\"right\", padx=5)\n\n        self.create_tree_node(tree_container, \"\ud83d\udcdc Prompt Rules\", entry.get('rules_used', \"\"))\n        self.create_tree_node(tree_container, \"\u270d Custom Prompt\", entry.get('custom_used', \"\"))\n        self.create_tree_node(tree_container, \"\ud83d\udcc1 Context Files\", \"\\n\".join(entry.get('context_files', [])) or \"No files.\")\n        self.create_tree_node(tree_container, \"\ud83d\ude80 Full Content\", entry.get('full_content', \"\"))\n\n    def create_tree_node(self, parent, label, content):\n        node_frame = ctk.CTkFrame(parent, fg_color=\"transparent\")\n        node_frame.pack(fill=\"x\", pady=1)\n        is_open = tk.BooleanVar(value=False)\n        content_box_container = [None] \n\n        def toggle_node():\n            if is_open.get():\n                if content_box_container[0]: content_box_container[0].destroy()\n                btn_node.configure(text=f\"  + {label}\")\n                is_open.set(False)\n            else:\n                tb = ctk.CTkTextbox(node_frame, height=150, font=(\"JetBrains Mono\", 11))\n                tb.insert(\"1.0\", content)\n                tb.configure(state=\"disabled\")\n                tb.pack(fill=\"x\", padx=20, pady=5)\n                content_box_container[0] = tb\n                btn_node.configure(text=f\"  - {label}\")\n                is_open.set(True)\n                self.add_context_menu(tb)\n\n        btn_node = ctk.CTkButton(node_frame, text=f\"  + {label}\", anchor=\"w\", fg_color=\"transparent\", \n                                 text_color=\"#aaa\", hover_color=\"#222\", height=24, command=toggle_node)\n        btn_node.pack(fill=\"x\")\n\n    # --- Core Logic ---\n\n    def generate_prompt(self):\n        parts = []\n        \n        # 1. Base Rules\n        if self.include_rules_var.get():\n            rules = self.prompt_editor.get(\"1.0\", tk.END).strip()\n            if rules:\n                parts.append(rules)\n        \n        # 2. Custom Prompt (Current Task)\n        custom = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        if custom:\n            parts.append(custom)\n        \n        # 3. Context Files\n        if self.include_context_var.get():\n            for f_obj in self.files:\n                if f_obj['enabled'].get():\n                    fpath = f_obj['path']\n                    if os.path.exists(fpath):\n                        try:\n                            with open(fpath, \"r\", encoding=\"utf-8\") as f:\n                                content = f.read()\n                                header = f\"\\n[Filename: {os.path.basename(fpath)}]\\n[Path: {fpath}]\"\n                                parts.append(header + \"\\n\" + content)\n                        except Exception as e:\n                            print(f\"Error reading {fpath}: {e}\")\n\n        final_prompt = \"\\n\\n---\\n\\n\".join(parts)\n        \n        # L\u00f3gica de Prompt Largo\n        if len(final_prompt) > 15000:\n            if messagebox.askyesno(\"Prompt Largo\", f\"El prompt generado es muy grande ({len(final_prompt)} caracteres).\\n\u00bfDeseas abrir GitHub Gist para subirlo all\u00ed?\"):\n                webbrowser.open(\"https://gist.github.com/\")\n                self.copy_to_clipboard(final_prompt)\n            else:\n                final_prompt = \"[Aviso: El prompt es largo y se enviar\u00e1 por partes]\\n\\n\" + final_prompt\n                self.copy_to_clipboard(final_prompt)\n        else:\n            self.copy_to_clipboard(final_prompt)\n            \n        self.add_to_history(final_prompt)\n        self.set_status(\"\u2713 Prompt Copied to Clipboard\")\n\n    # --- Persistence ---\n\n    def copy_to_clipboard(self, text):\n        self.root.clipboard_clear()\n        self.root.clipboard_append(text)\n\n    def set_status(self, text):\n        self.status_label.configure(text=text)\n        self.root.after(3000, lambda: self.status_label.configure(text=\"Ready\"))\n\n    def save_state(self, *args):\n        self.sync_engines_from_ui() \n        state = {\n            'rules_file': self.current_rules_file,\n            'custom_file': self.current_custom_file,\n            'prompt_md_content': self.prompt_editor.get(\"1.0\", tk.END).strip(),\n            'custom_prompt_content': self.custom_prompt.get(\"1.0\", tk.END).strip(),\n            'context_files': [\n                {'path': f['path'], 'enabled': f['enabled'].get(), 'pinned': f['pinned'].get()} \n                for f in self.files\n            ],\n            'inc_rules': self.include_rules_var.get(),\n            'inc_context': self.include_context_var.get(),\n            'history': self.history,\n            'ai_engines': self.ai_engines_data\n        }\n        with open(self.state_file, 'w', encoding=\"utf-8\") as f:\n            json.dump(state, f, indent=4)\n\n    def load_state(self):\n        if not os.path.exists(self.state_file):\n            return\n        \n        try:\n            with open(self.state_file, 'r', encoding=\"utf-8\") as f:\n                state = json.load(f)\n                \n                # Load editor content\n                self.prompt_editor.insert(\"1.0\", state.get('prompt_md_content', ''))\n                self.custom_prompt.insert(\"1.0\", state.get('custom_prompt_content', ''))\n                \n                # Load Flags\n                self.include_rules_var.set(state.get('inc_rules', True))\n                self.include_context_var.set(state.get('inc_context', True))\n                \n                # Load History\n                self.history = state.get('history', [])\n                \n                # Load Engines\n                self.ai_engines_data = state.get('ai_engines', [])\n                \n                # Load files\n                self.files = []\n                for f_data in state.get('context_files', []):\n                    if os.path.exists(f_data['path']):\n                        self.files.append({\n                            'path': f_data['path'],\n                            'enabled': tk.BooleanVar(value=f_data['enabled']),\n                            'pinned': tk.BooleanVar(value=f_data['pinned'])\n                        })\n                \n                self.refresh_file_list_ui()\n                self.refresh_history_ui()\n                self.refresh_ai_list()\n        except Exception as e:\n            print(f\"Error loading state: {e}\")\n\n    def auto_save(self):\n        self.save_state()\n        self.root.after(300000, self.auto_save)\n\n    def on_close(self):\n        self.save_state()\n        self.root.destroy()\n\n    # --- File Manager Methods ---\n\n    def save_prompt_md(self):\n        content = self.prompt_editor.get(\"1.0\", tk.END).strip()\n        with open(self.current_rules_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Rules saved to {os.path.basename(self.current_rules_file)}\")\n\n    def save_rules_as(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"prompt.md\")\n        if path:\n            self.current_rules_file = path\n            self.save_prompt_md()\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n\n    def load_rules_file(self):\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_rules_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.prompt_editor.delete(\"1.0\", tk.END)\n                self.prompt_editor.insert(\"1.0\", f.read())\n            self.lbl_rules_file.configure(text=f\"Base System Prompt ({os.path.basename(path)})\")\n\n    def save_custom_prompt(self):\n        content = self.custom_prompt.get(\"1.0\", tk.END).strip()\n        with open(self.current_custom_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        self.set_status(f\"Task saved to {os.path.basename(self.current_custom_file)}\")\n\n    def save_custom_as(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".md\", initialfile=\"custom.md\")\n        if path:\n            self.current_custom_file = path\n            self.save_custom_prompt()\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n\n    def load_custom_file(self):\n        path = filedialog.askopenfilename(filetypes=[(\"Markdown\", \"*.md\"), (\"Text\", \"*.txt\")])\n        if path:\n            self.current_custom_file = path\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                self.custom_prompt.delete(\"1.0\", tk.END)\n                self.custom_prompt.insert(\"1.0\", f.read())\n            self.lbl_custom_file.configure(text=f\"Current Task ({os.path.basename(path)})\")\n\n    def save_history_as(self):\n        path = filedialog.asksaveasfilename(defaultextension=\".json\", initialfile=\"history_export.json\")\n        if path:\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.history, f, indent=4)\n            self.set_status(\"History exported.\")\n\nif __name__ == \"__main__\":\n    root = ctk.CTk()\n    app = ModernPromptGUI(root)\n    root.mainloop()\n",
            "pinned": false
        }
    ],
    "ai_engines": [
        {
            "url": "https://github.com/copilot",
            "description": "GitHub Copilot - Asistente de c\u00f3digo integrado en VS Code y GitHub"
        },
        {
            "url": "https://claude.ai/chat",
            "description": "Claude - Chatbot avanzado de Anthropic"
        },
        {
            "url": "https://cursor.com",
            "description": "Cursor - IDE completo basado en IA (fork de VS Code)"
        },
        {
            "url": "https://chatgpt.com",
            "description": "ChatGPT - El cl\u00e1sico de OpenAI (GPT-4o, o1, etc.)"
        },
        {
            "url": "https://replit.com/ai",
            "description": "Replit AI - Entorno de desarrollo online con IA integrada"
        },
        {
            "url": "https://codeium.com/live",
            "description": "Codeium - Asistente de c\u00f3digo gratuito y muy r\u00e1pido"
        },
        {
            "url": "https://www.tabnine.com",
            "description": "Tabnine - Autocompletado IA con modelos locales y en la nube"
        },
        {
            "url": "https://aws.amazon.com/codewhisperer",
            "description": "Amazon CodeWhisperer - Asistente de c\u00f3digo de AWS (enterprise)"
        },
        {
            "url": "https://aider.chat",
            "description": "Aider - Herramienta CLI para editar c\u00f3digo con IA en terminal"
        },
        {
            "url": "https://comate.baidu.com",
            "description": "Comate (Baidu) - Asistente de c\u00f3digo chino"
        },
        {
            "url": "https://trae.ai",
            "description": "Trae - Nueva IA para desarrollo y productividad"
        },
        {
            "url": "https://kimi.moonshot.cn",
            "description": "Kimi (Moonshot) - IA china potente para c\u00f3digo y chat largo"
        },
        {
            "url": "https://xinghuo.xfyun.cn/desk",
            "description": "Xinghuo (iFlyTek) - IA fuerte en lenguaje chino y c\u00f3digo"
        },
        {
            "url": "https://codegeex.cn",
            "description": "CodeGeeX - Asistente de c\u00f3digo chino de gran tama\u00f1o"
        },
        {
            "url": "https://phind.com",
            "description": "Phind - Motor de b\u00fasqueda especializado en programaci\u00f3n"
        },
        {
            "url": "https://chat.deepseek.com",
            "description": "DeepSeek - Modelos potentes y econ\u00f3micos para c\u00f3digo"
        },
        {
            "url": "https://www.blackbox.ai",
            "description": "Blackbox AI - Especializado en preguntas de c\u00f3digo"
        },
        {
            "url": "https://cogram.com",
            "description": "Cogram - IA para generar documentaci\u00f3n y c\u00f3digo"
        }
    ]
}