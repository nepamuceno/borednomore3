You are a programming assistant with persistent memory. 
Mandatory rules:
1. Never delete or overwrite functions that are already correct. 
2. Always preserve previous code and show it fully before modifying. 
3. Every change must be incremental, auditable, and reversible. 
4. Keep debug output visible at every stage. 
5. If you lose context, ask for confirmation before acting. 
6. Do not invent new functions unrelated to the current flow. 
7. Always use clear comments in English to document each adjustment. 
8. Maintain consistency in file names, functions, and variables. 
9. Each response must include the full updated code, not just fragments. 
10. If you detect risk of losing functions, warn in text before executing changes.


adapta borednomore3_transitiones.py para que trabaje con borednomore3.py


[Archivo: /home/deb/borednomore3/borednomore3/debian/gist.txt]
=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/debian/borednomore3-downloader-gui.1 ===

.TH BOREDNOMORE3-DOWNLOADER-GUI 1 "January 2026" "3.0" "BoredNoMore3 Manual"
.SH NAME
borednomore3-downloader-gui \- graphical interface for bulk wallpaper scraping
.SH SYNOPSIS
.B borednomore3-downloader-gui
.SH DESCRIPTION
.B borednomore3-downloader-gui
is a specialized tool designed to scrape high-resolution images from multiple web sources simultaneously. It provides a visual dashboard to manage search queries, download limits, and source selection without requiring command-line knowledge.

The application features a modern "Dark" appearance mode and utilizes a threaded backend to ensure the UI remains responsive during network-intensive operations.

.SH GUI COMPONENTS
.TP
.B Search Keywords
Primary input for the scraping engine (e.g., "mountain landscape", "minimalist 4k").
.TP
.B Select Folder
A directory picker to set the destination for downloaded .jpg files.
.TP
.B Source Checkboxes
Allows the user to enable or disable specific scraping engines including:
\fIUnsplash, Pexels, Pixabay, Picsum, Wallhaven, Google,\fR and \fIBing\fR.
.TP
.B Deep Search
When enabled, the engine will traverse multiple result pages (up to 10) for supported sources (Bing, Pexels, etc.).
.TP
.B Random Engines
Ignores manual checkbox selection and chooses a single engine at random for the current mission.
.TP
.B Global Download Limit
A slider to cap the total number of images saved during the session.
.TP
.B Overwrite ID
If a number is entered, the engine will start naming files from that index, potentially overwriting existing files in the directory.
.TP
.B Console Box
A real-time log window that captures standard output from the scraping thread, displaying [OK] status for successful downloads.

.SH SIDEBAR TOOLS
The sidebar contains buttons that interface with the CLI version of the downloader to provide metadata:
.IP \(bu 2
\fBHelp\fR: Spawns the command-line help documentation.
.IP \(bu 2
\fBCredits\fR: Shows authorship information.
.IP \(bu 2
\fBVersion\fR: Displays the current build version.

.SH TECHNICAL NOTES
.SS File Naming
Images are automatically saved with the format \fIwallpaper_NNNNN.jpg\fR.
.SS Deduplication
The engine performs a SHA-256 hash check on every downloaded image. If a file with an identical hash already exists in the target folder, the download is discarded to save space.

.SH AUTHOR
Nepamuceno Bartolo

.SH SEE ALSO
.BR borednomore3-gui (1),
.BR borednomore3-downloader (1)



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/debian/borednomore3-gui.1 ===

.TH BOREDNOMORE3-GUI 1 "January 2026" "3.1.5" "BoredNoMore3 Manual"
.SH NAME
borednomore3-gui \- Advanced Mission Control for the BoredNoMore3 Wallpaper Engine
.SH SYNOPSIS
.B borednomore3-gui
.SH DESCRIPTION
.B borednomore3-gui
is a high-performance graphical interface built with \fICustomTkinter\fR. It acts as a wrapper for the \fBborednomore3\fR backend, allowing real-time monitoring of the wallpaper engine, transition selection, and engine parameter tuning through a "Mission Control" style dashboard.

The GUI utilizes a dedicated threading model to ensure the interface remains responsive even while the heavy image-processing transition matrix is active.
.SH SIDEBAR CONTROLS
The sidebar provides the primary engine configuration:
.TP
.B System Ready / Uptime
Displays the current engine status and a live clock showing how long the engine has been active.
.TP
.B Interval (Sec)
Numerical input to set the delay between wallpaper changes.
.TP
.B Animation Density
Controls the number of frames used during transitions (Higher = smoother but more CPU intensive).
.TP
.B Transition Speed
Adjusts the floating-point delay between frames. Recommended range: 0.0001 to 0.01.
.TP
.B Randomize Sequence
Toggle switch to choose between sequential or shuffled wallpaper transitions.
.TP
.B Initialize / Stop Engine
Primary triggers to spawn or terminate the background engine thread.
.SH TRANSITION MATRIX
The central panel features a grid of 40 checkboxes. Each corresponds to a specific OpenCV-powered transition effect (e.g., crossfade, slide, pixelate).
.IP \(bu 2
\fBSelect All\fR: Mass-enables all available transitions.
.IP \(bu 2
\fBClear\fR: Disables all transitions (at least one must be selected for the engine to start).
.SH ENGINE CONSOLE
A read-only, green-text terminal at the bottom of the window.
.TP
.B Output
Displays real-time logging from the core engine, including file paths of loaded images and transition metadata.
.TP
.B Export Log
Saves the current console buffer to \fIengine_log.txt\fR in the current working directory.
.SH FILES
.TP
.I borednomore3.py
The required backend logic file containing the \fBBoredNoMore3\fR class.
.TP
.I borednomore3_transitions.py
Metadata file containing the names and IDs of the transition effects.
.SH AUTHOR
Deb (Original Author)
.SH BUGS
Report GUI layout issues to the project repository. Ensure OpenCV and CustomTkinter are correctly installed via pip.
.SH SEE ALSO
.BR borednomore3 (1)



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/debian/borednomore3.1 ===

.TH BOREDNOMORE3 1 "January 2026" "0.5.0" "BoredNoMore3 Manual"
.SH NAME
borednomore3 \- dynamic wallpaper changer for Lubuntu/LXQt with smooth transitions
.SH SYNOPSIS
.B borednomore3
[\fIOPTIONS\fR]
.SH DESCRIPTION
.B borednomore3
is a sophisticated wallpaper management daemon designed for Lubuntu and LXQt environments.
It uses a professional transition library to change desktop backgrounds with high-quality visual effects.
The tool calculates transitions in real-time, supports global keyboard interrupts, and integrates
directly with desktop managers like \fBpcmanfm-qt\fR or \fBfeh\fR.
.SH OPTIONS
.TP
.BI \-i, \-\-interval " seconds"
Time between wallpaper changes. Default is \fB300\fR (5 minutes).
.TP
.BI \-d, \-\-directory " path"
Directory containing JPG wallpapers. Default is the current directory (\fB.\fR).
.TP
.BI \-f, \-\-frames " number"
Number of transition frames. Higher values (up to 100) create smoother animations. Default: \fB10\fR.
.TP
.BI \-s, \-\-speed " seconds"
Seconds per frame. Controls the speed of the effect. Range: \fB0.0001\fR to \fB1.0\fR. Default: \fB0.001\fR.
.TP
.BI \-t, \-\-transitions " list"
Comma-separated list of transition IDs (1-40) to use.
.TP
.B \-r, \-\-randomize
Randomize the order of transitions. If used with \fB\-t\fR, randomizes only the specified list.
.TP
.B \-h, \-\-help
Display the comprehensive help message including the full transition library list.
.TP
.B \-v, \-\-version
Display version information and exit.
.TP
.B \-c, \-\-credits
Display credits and author information.
.SH CONTROLS
.TP
.B q, Q
Global Exit. Pressing 'q' anywhere on the desktop will stop the wallpaper changer immediately.
.TP
.B Ctrl+C
Standard terminal interrupt to stop the daemon.
.SH TRANSITION MODES
The suite includes 40 transitions. Some popular IDs are:
.IP \(bu 2
\fB1-5\fR: Fades and Dissolves
.IP \(bu 2
\fB10-12\fR: Wipes and Iris effects
.IP \(bu 2
\fB23\fR: Glitch effect
.IP \(bu 2
\fB37\fR: Pixelate effect
.IP \(bu 2
\fB40\fR: Horizontal Split
.SH TECHNICAL NOTES
Images are automatically resized to match the current screen resolution (detected via \fBxrandr\fR)
before applying transitions to ensure desktop icons remain usable.
.SH AUTHOR
Nepamuceno Bartolo <zzerver@gmail.com>
.SH SEE ALSO
.BR pcmanfm-qt (1),
.BR feh (1)



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/debian/borednomore3-downloader.desktop ===

[Desktop Entry]
Name=BNM3 Downloader
Comment=Bulk download high-res wallpapers
Exec=borednomore3-downloader-gui
Icon=folder-download
Terminal=false
Type=Application
Categories=Network;FileTransfer;



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/debian/borednomore3-downloader.1 ===

.TH BOREDNOMORE3-DOWNLOADER 1 "January 2026" "0.5.0" "BoredNoMore3 Manual"
.SH NAME
borednomore3-downloader \- advanced wallpaper fetcher with smart numbering and duplicate detection
.SH SYNOPSIS
.B borednomore3-downloader
[\fIOPTIONS\fR]
.SH DESCRIPTION
.B borednomore3-downloader
is a powerful utility designed to fetch high-quality wallpapers from multiple online sources. It features a smart sequential numbering system that prevents filename collisions and utilizes SHA256 hashing to ensure no duplicate images are saved, even when sourced from different websites.
.SH OPTIONS
.TP
.BI \-d, \-\-directory " path"
Directory where wallpapers will be saved. The script automatically scans this directory to determine the next sequential number. Default: \fB.\fR (current directory).
.TP
.BI \-s, \-\-search " query"
The search term used to find relevant images across all sources. Use quotes for multi-word queries. Default: \fB"dark wallpaper"\fR.
.TP
.BI \-n, \-\-number " count"
Total number of wallpapers to attempt to download. Default: \fB10\fR.
.TP
.B \-D, \-\-deep
Enable deep search mode. The downloader will traverse multiple pages and deeper search results. This increases variety but takes longer.
.TP
.BI \-w, \-\-websites " sources"
Comma-separated list of sources to use. 
Available: \fBunsplash, pexels, pixabay, picsum, wallhaven, google, bing, all\fR. Default: \fBbing\fR.
.TP
.BI \-o, \-\-overwrite " number"
Force the downloader to start saving files beginning at the specified number, overwriting existing files. \fBNote:\fR Duplicate detection is disabled in this mode.
.TP
.B \-R, \-\-random-source
Randomly select one source from the available library. If \fB\-w\fR is also provided, \fB\-w\fR takes precedence.
.TP
.B \-h, \-\-help
Display the built-in help text and exit.
.TP
.B \-v, \-\-version
Display version information and exit.
.SH FEATURES
.TP
.B Smart Numbering
Scans the target directory for \fIwallpaper_XXXXX.jpg\fR patterns and automatically starts numbering at \fImax + 1\fR.
.TP
.B Duplicate Detection
Calculates the SHA256 hash of every downloaded file. If the hash matches an existing file in the directory, the download is discarded to save space.
.TP
.B Source Variety
Supports a mix of API-based (Unsplash, Wallhaven) and scraping-based (Google, Bing) retrieval methods to ensure a wide selection of content.
.SH EXAMPLES
.TP
.B Download 20 space-themed wallpapers to a specific folder:
borednomore3-downloader -s "deep space nebula" -n 20 -d ~/Pictures/Space
.TP
.B Use only Unsplash and Pexels with deep search enabled:
borednomore3-downloader -w unsplash,pexels -D
.TP
.B Reset a collection by overwriting from the first image:
borednomore3-downloader -o 1 -n 50
.SH AUTHOR
Nepamuceno Bartolo <zzerver@gmail.com>
.SH SEE ALSO
.BR borednomore3 (1),
.BR borednomore3-gui (1)



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/debian/borednomore3.desktop ===

[Desktop Entry]
Name=BoredNoMore3 Mission Control
Comment=Manage and run wallpaper transitions
Exec=borednomore3-gui
Icon=preferences-desktop-wallpaper
Terminal=false
Type=Application
Categories=Settings;DesktopSettings;



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/backend/borednomore3.py ===

#!/usr/bin/env python3
"""
Dynamic Wallpaper Changer for Lubuntu/LXQt
Changes wallpapers with smooth transitions using imagemagick

Author: Nepamuceno
Email: (hidden)
GitHub: https://github.com/nepamuceno/borednomore3
Version: 0.6.0 - Added random wallpaper selection feature
"""

import os
import sys
import time
import random
import glob
import subprocess
import tempfile
import argparse
import configparser
from pathlib import Path

# Add lib directory to Python path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
LIB_DIR = os.path.join(SCRIPT_DIR, '..', 'lib')
CONF_DIR = os.path.join(SCRIPT_DIR, '..', 'conf')
WALLPAPERS_DIR = os.path.join(SCRIPT_DIR, '..', 'wallpapers')

# Add to sys.path
sys.path.insert(0, LIB_DIR)

try:
    from PIL import Image
except ImportError:
    print("Error: PIL/Pillow is required.")
    sys.exit(1)

try:
    from pynput import keyboard
except ImportError:
    print("Error: pynput is required.")
    sys.exit(1)

try:
    from borednomore3_transitions import TRANSITIONS, apply_transition
except ImportError:
    print(f"Error: Could not import borednomore3_transitions from {LIB_DIR}")
    print(f"Make sure borednomore3_transitions.py is in: {LIB_DIR}")
    sys.exit(1)

VERSION = "0.6.0"
AUTHOR = "Nepamuceno"
EMAIL = "(hidden)"
GITHUB = "https://github.com/nepamuceno/borednomore3"

# Default configuration values (used if no config file exists)
DEFAULT_CONFIG = {
    'interval': 300,
    'directory': WALLPAPERS_DIR,  # Absolute path to wallpapers directory
    'frames': 10,
    'speed': 0.001,
    'transitions': None,
    'randomize': False,
    'keep_image': False,
    'randomize_wallpapers': False,
    'borednomore3_gui_binary': 'borednomore3-gui'
}

# Default config file paths
DEFAULT_CONF_FILE = os.path.join(CONF_DIR, 'borednomore3.conf')
DEFAULT_LIST_FILE = os.path.join(CONF_DIR, 'borednomore3.list')


def load_config_file(config_path):
    """Load configuration from file"""
    config = {}
    if not os.path.exists(config_path):
        return config
    
    try:
        parser = configparser.ConfigParser()
        parser.read(config_path)
        
        if 'settings' in parser:
            settings = parser['settings']
            
            if 'interval' in settings:
                config['interval'] = int(settings['interval'])
            if 'directory' in settings:
                # If directory is relative, make it relative to config file
                dir_path = settings['directory']
                if not os.path.isabs(dir_path):
                    dir_path = os.path.join(os.path.dirname(config_path), dir_path)
                config['directory'] = os.path.abspath(dir_path)
            if 'frames' in settings:
                config['frames'] = int(settings['frames'])
            if 'speed' in settings:
                config['speed'] = float(settings['speed'])
            if 'transitions' in settings:
                config['transitions'] = settings['transitions']
            if 'randomize' in settings:
                config['randomize'] = settings.getboolean('randomize')
            if 'keep_image' in settings:
                config['keep_image'] = settings.getboolean('keep_image')
            if 'randomize_wallpapers' in settings:
                config['randomize_wallpapers'] = settings.getboolean('randomize_wallpapers')
            if 'borednomore3_gui_binary' in settings:
                config['borednomore3_gui_binary'] = settings['borednomore3_gui_binary']
        
        print(f"[*] Loaded configuration from: {config_path}")
        return config
    except Exception as e:
        print(f"[WARNING] Error loading config file: {e}")
        return config


def save_default_config(config_path):
    """Create default borednomore3.conf if it doesn't exist"""
    # Calculate relative path from config location to wallpapers
    config_dir = os.path.dirname(config_path)
    rel_wallpapers_path = os.path.relpath(WALLPAPERS_DIR, config_dir)
    
    parser = configparser.ConfigParser()
    parser['settings'] = {
        'interval': str(DEFAULT_CONFIG['interval']),
        'directory': rel_wallpapers_path,
        'frames': str(DEFAULT_CONFIG['frames']),
        'speed': str(DEFAULT_CONFIG['speed']),
        'transitions': '',
        'randomize': str(DEFAULT_CONFIG['randomize']),
        'keep_image': str(DEFAULT_CONFIG['keep_image']),
        'randomize_wallpapers': str(DEFAULT_CONFIG['randomize_wallpapers']),
        'borednomore3_gui_binary': DEFAULT_CONFIG['borednomore3_gui_binary']
    }
    
    try:
        with open(config_path, 'w') as f:
            parser.write(f)
        print(f"[*] Created default configuration file: {config_path}")
        return True
    except Exception as e:
        print(f"[WARNING] Failed to create default config: {e}")
        return False


def create_default_wallpaper_list(list_path):
    """Create default borednomore3.list if it doesn't exist"""
    default_patterns = [
        "*.jpg",
        "*.png", 
        "*.jpeg",
        "*.webp",
        "# Add more patterns as needed, one per line",
        "# *.bmp",
        "# *.tiff",
        "# *.gif"
    ]
    
    try:
        with open(list_path, 'w') as f:
            for pattern in default_patterns:
                f.write(pattern + '\n')
        print(f"[*] Created default wallpaper list file: {list_path}")
        return True
    except Exception as e:
        print(f"[WARNING] Failed to create default wallpaper list: {e}")
        return False


class BoredNoMore3:
    """Main wallpaper changer application"""
    
    def __init__(self, interval=300, directory=None, frames=10, fade_speed=0.001, 
                 transitions=None, randomize=False, keep_image=False, randomize_wallpapers=False,
                 wallpaper_patterns=None):
        # Set default directory if not provided
        if directory is None:
            self.directory = WALLPAPERS_DIR
        else:
            self.directory = os.path.abspath(os.path.expanduser(directory))
            
        self.interval = interval
        self.transition_frames = frames
        self.fade_speed = fade_speed
        self.wallpapers = []
        self.current_index = -1
        self.should_exit = False
        self.is_transitioning = False
        self.keep_image = keep_image
        self.randomize_wallpapers = randomize_wallpapers
        
        # Set random seed based on current time
        random.seed(time.time())
        
        # Setup transition list
        if transitions:
            self.transition_list = transitions
        else:
            self.transition_list = list(range(1, len(TRANSITIONS) + 1))
        
        self.randomize_transitions = randomize
        self.transition_index = 0  # For sequential mode
        
        # Wallpaper patterns (for --wallpaper-list)
        self.wallpaper_patterns = wallpaper_patterns if wallpaper_patterns else ["*.jpg", "*.png", "*.jpeg", "*.webp"]
        
        # Setup keyboard listener
        self.listener = keyboard.Listener(on_press=self.on_key_press)
        self.listener.start()
        
        # Screen resolution
        self.screen_width, self.screen_height = self.get_screen_resolution()
    
    def on_key_press(self, key):
        try:
            if hasattr(key, 'char') and key.char in ['q', 'Q']:
                if not self.should_exit:
                    print("\n\nExiting gracefully...")
                    self.should_exit = True
                    if hasattr(self, 'listener'):
                        self.listener.stop()
                    sys.exit(0)
        except:
            pass
    
    def get_screen_resolution(self):
        try:
            output = subprocess.check_output(['xrandr'], text=True)
            for line in output.split('\n'):
                if ' connected' in line:
                    parts = line.split()
                    for part in parts:
                        if 'x' in part and part[0].isdigit():
                            resolution = part.split('+')[0]
                            w, h = resolution.split('x')
                            return int(w), int(h)
        except:
            pass
        return 1920, 1080
    
    def load_wallpapers(self):
        if not os.path.isdir(self.directory):
            print(f"Error: Directory '{self.directory}' does not exist")
            print(f"Please create the directory or specify a different one with --directory")
            sys.exit(1)
        
        self.wallpapers = []
        for pattern in self.wallpaper_patterns:
            full_pattern = os.path.join(self.directory, pattern)
            matched = sorted(glob.glob(full_pattern))
            self.wallpapers.extend(matched)
        
        # Remove duplicates if any patterns overlap
        self.wallpapers = sorted(list(set(self.wallpapers)))
        
        if not self.wallpapers:
            print(f"Error: No files matched the patterns in {self.directory}")
            print(f"Patterns used: {', '.join(self.wallpaper_patterns)}")
            print(f"Directory contents: {os.listdir(self.directory)}")
            sys.exit(1)
        
        print(f"Loaded {len(self.wallpapers)} wallpapers from {self.directory}")
        print(f"Using patterns: {', '.join(self.wallpaper_patterns)}")
    
    def set_wallpaper(self, image_path):
        try:
            subprocess.run([
                "pcmanfm-qt", "--set-wallpaper", image_path,
                "--wallpaper-mode=stretch", "--desktop"
            ], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except:
            try:
                subprocess.run(["feh", "--bg-fill", image_path], 
                             check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except:
                pass
    
    def get_next_transition(self):
        if self.randomize_transitions:
            return random.choice(self.transition_list)
        else:
            # Sequential: cycle through the list in order
            transition = self.transition_list[self.transition_index]
            self.transition_index = (self.transition_index + 1) % len(self.transition_list)
            return transition
    
    def get_next_wallpaper_index(self):
        """Get the next wallpaper index based on randomize_wallpapers setting"""
        if self.randomize_wallpapers:
            # Random selection
            return random.randint(0, len(self.wallpapers) - 1)
        else:
            # Sequential selection
            return (self.current_index + 1) % len(self.wallpapers)
    
    def change_wallpaper(self):
        if self.should_exit or self.is_transitioning:
            return
        
        self.is_transitioning = True
        old_index = self.current_index
        self.current_index = self.get_next_wallpaper_index()
        new_wallpaper = self.wallpapers[self.current_index]
        
        print(f"\nChanging to: {os.path.basename(new_wallpaper)}")
        
        if old_index >= 0:
            old_wallpaper = self.wallpapers[old_index]
            transition_num = self.get_next_transition()
            transition_name = TRANSITIONS.get(transition_num, "fade")
            print(f"Using transition #{transition_num}: {transition_name}")
            
            apply_transition(
                old_wallpaper, new_wallpaper, transition_num,
                self.screen_width, self.screen_height,
                self.transition_frames, self.fade_speed,
                self.set_wallpaper, lambda: self.should_exit,
                self.keep_image
            )
        else:
            self.set_wallpaper(new_wallpaper)
        
        self.is_transitioning = False
    
    def run(self):
        print(f"Screen resolution: {self.screen_width}x{self.screen_height}")
        print(f"Keep image mode: {'Enabled' if self.keep_image else 'Disabled'}")
        print(f"Transition mode: {'RANDOM' if self.randomize_transitions else 'SEQUENTIAL'}")
        print(f"Wallpaper selection: {'RANDOM' if self.randomize_wallpapers else 'SEQUENTIAL'}")
        print(f"Using {len(self.transition_list)} transitions")
        self.load_wallpapers()
        
        self.change_wallpaper()
        
        print(f"\nborednomore3 running. Changing every {self.interval} seconds.")
        print(f"Transition frames: {self.transition_frames}")
        print("\nPress 'q' or 'Q' anywhere to exit immediately.")
        print("Press Ctrl+C to exit.\n")
        
        try:
            while not self.should_exit:
                time.sleep(self.interval)
                if not self.should_exit:
                    self.change_wallpaper()
        except KeyboardInterrupt:
            print("\n\nExiting gracefully...")
            if hasattr(self, 'listener'):
                self.listener.stop()
            sys.exit(0)


def print_help():
    help_text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      borednomore3 - Dynamic Wallpaper Changer                â•‘
â•‘                                  Version {VERSION}                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DESCRIPTION:
    Changes wallpapers with smooth transitions. Supports random or sequential order
    for both transitions and wallpaper selection.

USAGE:
    borednomore3 [OPTIONS]

OPTIONS:
    -h, --help                  Show this help message and exit
    -v, --version               Show version information
    -c, --credits               Show credits
    --config <path>             Config file (default: {DEFAULT_CONF_FILE})
    -i, --interval <sec>        Change interval in seconds (default: 300)
    -d, --directory <path>      Wallpaper directory (default: {WALLPAPERS_DIR})
    -f, --frames <num>          Transition frames (default: 10, range 5-100)
    -s, --speed <sec>           Seconds per frame (default: 0.001)
    -t, --transitions <list>    Comma-separated transition IDs (e.g., 1,5,23)
                                When used with -r, randomizes only from this list
    -r, --randomize             RANDOMIZE transitions (default: SEQUENTIAL)
                                If -t is given â†’ random from that list only
                                If no -t â†’ random from all available transitions
    -w, --randomize-wallpapers  RANDOMIZE wallpaper selection (default: SEQUENTIAL)
                                When enabled, picks a random wallpaper each time
                                instead of cycling in order
    -k, --keep-image            Keep previous image visible during transition
    -l, --wallpaper-list <file> File with wallpaper patterns (one per line)
                                If no file given after flag â†’ uses {DEFAULT_LIST_FILE}
                                Default without flag: *.jpg, *.png, *.jpeg, *.webp

CONFIGURATION FILE:
    Created automatically if missing.
    Command-line flags always override config values.

TRANSITION LIBRARY:
    {len(TRANSITIONS)} professional transitions available.

AUTHOR:
    {AUTHOR} - {GITHUB}
"""
    print(help_text)


def print_version():
    print(f"borednomore3 v{VERSION}")


def print_credits():
    print(f"""
borednomore3 v{VERSION}
Author: {AUTHOR}
GitHub: {GITHUB}

A dynamic wallpaper changer with smooth transitions for LXQt/Lubuntu.
Enjoy!
""")


def parse_transitions(transition_str):
    try:
        parts = [t.strip() for t in transition_str.split(',')]
        transitions = []
        for part in parts:
            if '-' in part:
                start, end = map(int, part.split('-'))
                transitions.extend(range(start, end + 1))
            else:
                transitions.append(int(part))
        
        for t in transitions:
            if t < 1 or t > len(TRANSITIONS):
                print(f"Error: Transition {t} out of range (1-{len(TRANSITIONS)})")
                sys.exit(1)
        return sorted(set(transitions))  # remove duplicates and sort
    except ValueError:
        print("Error: -t must be comma-separated numbers or ranges (e.g., 1,5,10-15)")
        sys.exit(1)


def load_wallpaper_patterns(list_file):
    """Load wallpaper patterns from a list file"""
    patterns = []
    if not os.path.exists(list_file):
        print(f"Warning: Wallpaper list file not found: {list_file}")
        # Create default if it's the default list file
        if list_file == DEFAULT_LIST_FILE:
            os.makedirs(CONF_DIR, exist_ok=True)
            create_default_wallpaper_list(list_file)
            return ["*.jpg", "*.png", "*.jpeg", "*.webp"]
        else:
            return ["*.jpg", "*.png", "*.jpeg", "*.webp"]
    
    try:
        with open(list_file, 'r') as f:
            for line in f:
                # Remove inline comments (anything after #) and strip whitespace
                line = line.split('#', 1)[0].strip()
                if line:  # only add non-empty patterns
                    patterns.append(line)
        if not patterns:
            print(f"Warning: No valid patterns in {list_file}, falling back to common formats")
            return ["*.jpg", "*.png", "*.jpeg", "*.webp"]
        print(f"Loaded {len(patterns)} wallpaper patterns from {list_file}")
        return patterns
    except Exception as e:
        print(f"Error reading wallpaper list file {list_file}: {e}")
        return ["*.jpg", "*.png", "*.jpeg", "*.webp"]


def main():
    parser = argparse.ArgumentParser(
        description='borednomore3 - Dynamic Wallpaper Changer',
        add_help=False,
        formatter_class=argparse.RawTextHelpFormatter
    )
    
    parser.add_argument('-h', '--help', action='store_true')
    parser.add_argument('-v', '--version', action='store_true')
    parser.add_argument('-c', '--credits', action='store_true')
    parser.add_argument('--config', type=str, default=None)
    parser.add_argument('-i', '--interval', type=int, default=None)
    parser.add_argument('-d', '--directory', type=str, default=None)
    parser.add_argument('-f', '--frames', type=int, default=None)
    parser.add_argument('-s', '--speed', type=float, default=None)
    parser.add_argument('-t', '--transitions', type=str, default=None)
    parser.add_argument('-r', '--randomize', action='store_true')
    parser.add_argument('-w', '--randomize-wallpapers', action='store_true')
    parser.add_argument('-k', '--keep-image', action='store_true')
    parser.add_argument('-l', '--wallpaper-list', nargs='?', const=DEFAULT_LIST_FILE, 
                       default=None, help=f"File with wallpaper patterns (default: {DEFAULT_LIST_FILE})")
    
    args = parser.parse_args()
    
    if args.help:
        print_help()
        sys.exit(0)
    if args.version:
        print_version()
        sys.exit(0)
    if args.credits:
        print_credits()
        sys.exit(0)
    
    # Seed random
    random.seed(time.time())
    
    # Config file logic
    if args.config:
        config_file = args.config
    else:
        config_file = DEFAULT_CONF_FILE
    
    # Create default config if it doesn't exist
    if not os.path.exists(config_file):
        os.makedirs(CONF_DIR, exist_ok=True)
        save_default_config(config_file)
    
    config = DEFAULT_CONFIG.copy()
    if os.path.exists(config_file):
        file_config = load_config_file(config_file)
        config.update(file_config)
    
    # Apply command-line overrides (highest priority)
    if args.interval is not None:
        config['interval'] = args.interval
    if args.directory is not None:
        config['directory'] = args.directory
    if args.frames is not None:
        config['frames'] = args.frames
    if args.speed is not None:
        config['speed'] = args.speed
    if args.transitions is not None:
        config['transitions'] = args.transitions
    if args.keep_image:
        config['keep_image'] = True
    
    # Transition randomization: -r overrides config
    config['randomize'] = args.randomize
    
    # Wallpaper randomization: -w overrides config
    config['randomize_wallpapers'] = args.randomize_wallpapers
    
    # Wallpaper list file handling
    wallpaper_patterns = ["*.jpg", "*.png", "*.jpeg", "*.webp"]
    if args.wallpaper_list:
        # Use provided list file or default
        list_file = args.wallpaper_list
        wallpaper_patterns = load_wallpaper_patterns(list_file)
    
    # Validate
    if config['interval'] < 1:
        print("Error: Interval must be >= 1 second")
        sys.exit(1)
    if config['frames'] < 5 or config['frames'] > 100:
        print("Error: Frames must be 5-100")
        sys.exit(1)
    if config['speed'] <= 0 or config['speed'] > 1.0:
        print("Error: Speed must be 0.0001-1.0")
        sys.exit(1)
    
    # Parse transitions (command-line has highest priority)
    transitions = None
    if config['transitions']:
        transitions = parse_transitions(config['transitions'])
    
    # Start the app
    print(f"borednomore3 v{VERSION}")
    print("=" * 80)
    
    app = BoredNoMore3(
        interval=config['interval'],
        directory=config['directory'],
        frames=config['frames'],
        fade_speed=config['speed'],
        transitions=transitions,
        randomize=config['randomize'],
        keep_image=config['keep_image'],
        randomize_wallpapers=config['randomize_wallpapers'],
        wallpaper_patterns=wallpaper_patterns
    )
    app.run()


if __name__ == "__main__":
    main()



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/backend/borednomore3_downloader.py ===

#!/usr/bin/env python3
"""
BoredNoMore3 Downloader
Advanced wallpaper downloader from multiple sources
Downloads high-quality wallpapers from:
- Unsplash (https://unsplash.com)
- Pexels (https://pexels.com)
- Pixabay (https://pixabay.com)
- Wallhaven (https://wallhaven.cc)
- Lorem Picsum (https://picsum.photos)
- Google Images (via scraping)
- Bing Images (via scraping)
Author: Nepamuceno Bartolo
Email: (hidden)
GitHub: https://github.com/nepamuceno/borednomore3
Version: 0.6.0
"""

import os
import sys
import time
import random
import hashlib
import argparse
import glob
import re
from pathlib import Path

# Import download engines
try:
    from borednomore3_downloader_engines import DownloadEngines
except ImportError:
    print("ERROR: borednomore3_downloader_engines.py not found!")
    print("Please ensure both files are in the same directory.")
    sys.exit(1)

VERSION = "0.6.0"
AUTHOR = "Nepamuceno Bartolo"
EMAIL = "(hidden)"
GITHUB = "https://github.com/nepamuceno/borednomore3"


class BoredNoMore3Downloader:
    """Advanced wallpaper downloader with smart numbering and duplicate detection"""

    def __init__(self, directory=".", search="dark wallpaper", count=10, deep_search=False, 
                 sources=None, start_from=None, randomize_source=False):
        self.directory = os.path.abspath(os.path.expanduser(directory))
        self.search = search
        self.count = count  # Use 'count' for consistency with engines
        self.deep_search = deep_search  # Use 'deep_search' for consistency with engines
        self.randomize_source = randomize_source
        self.downloaded = []
        self.downloaded_hashes = set()
        self.next_number = 1
        self.start_from = start_from
        
        # Initialize download engines
        self.engines = DownloadEngines(self)
        
        # Available sources mapping
        self.available_sources = {
            'unsplash': self.engines.download_from_unsplash,
            'pexels': self.engines.download_from_pexels,
            'pixabay': self.engines.download_from_pixabay,
            'picsum': self.engines.download_from_picsum,
            'wallhaven': self.engines.download_from_wallhaven,
            'google': self.engines.download_from_google,
            'bing': self.engines.download_from_bing,
        }
        
        # Handle source selection with randomization
        if randomize_source:
            random_source = random.choice(list(self.available_sources.keys()))
            self.sources = [random_source]
            print(f"ğŸ² Random source selected: {random_source}")
        elif sources:
            self.sources = sources
        else:
            self.sources = ['bing']
        
        # Create directory if it doesn't exist
        self._create_directory()
        
        # Scan existing files and determine next number
        self._scan_existing_files()

    def _create_directory(self):
        """Create output directory if it doesn't exist"""
        if not os.path.isdir(self.directory):
            try:
                os.makedirs(self.directory, exist_ok=True)
                print(f"ğŸ“ Created directory: {self.directory}")
            except Exception as e:
                print(f"âŒ Error: Cannot create directory '{self.directory}': {e}")
                sys.exit(1)

    def _scan_existing_files(self):
        """Scan directory for existing wallpapers and find next number"""
        print(f"ğŸ” Scanning directory: {self.directory}")
        
        pattern = os.path.join(self.directory, "wallpaper_*.jpg")
        existing_files = glob.glob(pattern)
        
        if not existing_files:
            print("ğŸ“ No existing wallpapers found. Starting from 1.")
            self.next_number = 1
            if self.start_from is not None:
                self.next_number = self.start_from
                print(f"âš ï¸  Override: Starting from specified number {self.next_number}")
            return
        
        # Extract numbers from filenames
        max_number = 0
        number_pattern = re.compile(r'wallpaper_(\d+)\.jpg')
        
        for filepath in existing_files:
            filename = os.path.basename(filepath)
            match = number_pattern.match(filename)
            if match:
                num = int(match.group(1))
                max_number = max(max_number, num)
            
            # Calculate hash to avoid duplicates (only if not overwriting)
            if self.start_from is None:
                try:
                    file_hash = self._get_file_hash(filepath)
                    if file_hash:
                        self.downloaded_hashes.add(file_hash)
                except Exception:
                    pass
        
        # Determine starting number
        if self.start_from is not None:
            self.next_number = self.start_from
            print(f"ğŸ“Š Found {len(existing_files)} existing wallpapers.")
            print(f"âš ï¸  Override mode: Starting from wallpaper number {self.next_number}")
            print(f"âš ï¸  WARNING: Existing wallpapers from {self.next_number} onwards will be overwritten!")
        else:
            self.next_number = max_number + 1
            print(f"ğŸ“Š Found {len(existing_files)} existing wallpapers.")
            print(f"â¡ï¸  Next wallpaper will be numbered: {self.next_number}")

    def _get_file_hash(self, filepath):
        """Calculate SHA256 hash of a file"""
        sha256_hash = hashlib.sha256()
        try:
            with open(filepath, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except Exception:
            return None

    def _is_duplicate(self, image_data):
        """Check if image data is a duplicate"""
        sha256_hash = hashlib.sha256()
        sha256_hash.update(image_data)
        file_hash = sha256_hash.hexdigest()
        
        if file_hash in self.downloaded_hashes:
            return True
        
        self.downloaded_hashes.add(file_hash)
        return False

    def save_image(self, image_data, source_name):
        """Save image with smart numbering (public method for engines)"""
        # Skip duplicate check if in overwrite mode
        if self.start_from is None:
            if self._is_duplicate(image_data):
                print(f"  â­ï¸  Skipped duplicate from {source_name}")
                return False
        else:
            # In overwrite mode, still add hash to track new downloads
            sha256_hash = hashlib.sha256()
            sha256_hash.update(image_data)
            file_hash = sha256_hash.hexdigest()
            self.downloaded_hashes.add(file_hash)
        
        filename = f"wallpaper_{self.next_number:05d}.jpg"
        save_path = os.path.join(self.directory, filename)
        
        # Check if we're overwriting
        overwrite_msg = ""
        if os.path.exists(save_path):
            overwrite_msg = " ğŸ”„ (OVERWRITTEN)"
        
        try:
            with open(save_path, "wb") as f:
                f.write(image_data)
            
            file_size_kb = len(image_data) / 1024
            self.downloaded.append(save_path)
            print(f"  âœ… Downloaded: {filename} from {source_name} ({file_size_kb:.1f} KB){overwrite_msg}")
            self.next_number += 1
            return True
        except Exception as e:
            print(f"  âŒ Error saving {filename}: {e}")
            return False

    def fetch_all_sources(self):
        """Download wallpapers from selected sources"""
        print("\n" + "=" * 80)
        print("ğŸš€ BoredNoMore3 Downloader - Starting Download Process")
        print("=" * 80)
        print(f"ğŸ” Search query: '{self.search}'")
        print(f"ğŸ¯ Target count: {self.count} wallpapers")
        print(f"ğŸ”¬ Deep search: {'âœ… Enabled' if self.deep_search else 'âŒ Disabled'}")
        print(f"ğŸ“ Save directory: {self.directory}")
        
        # Determine which sources to use
        if 'all' in self.sources:
            active_sources = list(self.available_sources.keys())
            print(f"ğŸŒ Sources: All ({', '.join(active_sources)})")
        else:
            active_sources = self.sources
            print(f"ğŸŒ Sources: {', '.join(active_sources)}")
        
        if self.start_from is not None:
            print(f"âš ï¸  Mode: OVERWRITE from number {self.start_from}")
        else:
            print(f"â• Mode: APPEND (continue from last)")
        
        print("=" * 80)
        
        initial_count = len(self.downloaded)
        
        # Download from selected sources
        for source in active_sources:
            if source in self.available_sources:
                try:
                    self.available_sources[source]()
                except KeyboardInterrupt:
                    raise
                except Exception as e:
                    print(f"âŒ [{source}] Fatal error: {e}")
            else:
                print(f"âš ï¸  Unknown source: {source}")
        
        print("\n" + "=" * 80)
        print("âœ… Download Process Completed")
        print("=" * 80)
        
        total_downloaded = len(self.downloaded) - initial_count
        print(f"ğŸ“¥ Total new wallpapers downloaded: {total_downloaded}")
        print(f"ğŸ“Š Total wallpapers in directory: {self.next_number - 1}")
        print(f"ğŸ’¾ Saved to: {self.directory}")
        print("=" * 80)


def print_help():
    """Print comprehensive help information"""
    help_text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                  BoredNoMore3 Downloader - Wallpaper Fetcher                 â•‘
â•‘                              Version {VERSION}                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DESCRIPTION:
    BoredNoMore3 Downloader is an advanced wallpaper downloading tool that fetches
    high-quality images from multiple sources with smart duplicate detection and
    sequential numbering.
USAGE:
    borednomore3_downloader.py [OPTIONS]
OPTIONS:
    -h, --help
        Display this comprehensive help message and exit.
    -v, --version
        Display version information and exit.
    -c, --credits
        Display credits and author information.
    -d, --directory <path>
        Directory where wallpapers will be saved.
        Default: current directory
        Example: -d ~/Pictures/Wallpapers
    -s, --search <query>
        Search query for finding wallpapers.
        Default: "dark wallpaper"
        Example: -s "nature landscape"
        Example: -s "abstract art"
    -n, --number <count>
        Number of wallpapers to download.
        Default: 10
        Range: 1-500
        Example: -n 20
    -D, --deep
        Enable deep search mode for more variety.
    -w, --websites <sources>
        Specify which websites/sources to use.
        Default: bing
        Available: unsplash, pexels, pixabay, picsum, wallhaven, google, bing, all
        
        Example: -w unsplash,pexels
        Example: -w all
    -o, --overwrite <number>
        Start overwriting from specified number.
        Example: -o 50
    -R, --random-source
        Randomly select one source.
SOURCES:
    â€¢ unsplash  - High-quality curated photography
    â€¢ pexels    - Professional stock photos (API key recommended)
    â€¢ pixabay   - Free images (API key recommended)
    â€¢ picsum    - Random quality photos
    â€¢ wallhaven - Community wallpapers (API key recommended)
    â€¢ google    - Google Images scraping
    â€¢ bing      - Bing Images scraping
    â€¢ all       - All available sources
FEATURES:
    âœ… Smart sequential numbering
    âœ… SHA256 duplicate detection
    âœ… Multiple source support
    âœ… Deep search mode
    âœ… Automatic directory creation
    âœ… Overwrite mode
AUTHOR:
    {AUTHOR}
    GitHub: {GITHUB}
NOTES:
    - For best results with Pexels, Pixabay, and Wallhaven, use their API keys
    - Edit borednomore3_downloader_engines.py to add API keys
    - Bing and Google work via scraping (no API key needed)
"""
    print(help_text)


def print_version():
    """Print version information"""
    print(f"BoredNoMore3 Downloader v{VERSION}")


def print_credits():
    """Print credits and author information"""
    credits_text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                  BoredNoMore3 Downloader - Wallpaper Fetcher                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Version:    {VERSION}
Author:     {AUTHOR}
Email:      {EMAIL}
GitHub:     {GITHUB}
Credits:
    â€¢ Unsplash.com - Beautiful free photos
    â€¢ Pexels.com - Free stock photos & videos
    â€¢ Pixabay.com - Free images & videos
    â€¢ Wallhaven.cc - Community wallpapers
    â€¢ Picsum.photos - Lorem Picsum random images
    
Thank you to all content creators and communities!
"""
    print(credits_text)


def main():
    """Main entry point"""
    try:
        parser = argparse.ArgumentParser(
            description='BoredNoMore3 Downloader - Wallpaper Fetcher',
            add_help=False
        )
        
        parser.add_argument('-h', '--help', action='store_true')
        parser.add_argument('-v', '--version', action='store_true')
        parser.add_argument('-c', '--credits', action='store_true')
        parser.add_argument('-d', '--directory', type=str, default='.')
        parser.add_argument('-s', '--search', type=str, default='dark wallpaper')
        parser.add_argument('-n', '--number', type=int, default=10)
        parser.add_argument('-D', '--deep', action='store_true')
        parser.add_argument('-w', '--websites', type=str, default=None)
        parser.add_argument('-o', '--overwrite', type=int, default=None)
        parser.add_argument('-R', '--random-source', action='store_true')
        
        args = parser.parse_args()
        
        if args.help:
            print_help()
            sys.exit(0)
        
        if args.version:
            print_version()
            sys.exit(0)
        
        if args.credits:
            print_credits()
            sys.exit(0)
        
        # Validate number
        if args.number < 1 or args.number > 500:
            print("âŒ Error: Number must be between 1 and 500")
            sys.exit(1)
        
        # Parse websites
        available = ['unsplash', 'pexels', 'pixabay', 'picsum', 'wallhaven', 'google', 'bing', 'all']
        sources = None
        
        if args.websites:
            if args.websites.lower() == 'all':
                sources = ['all']
            else:
                sources = [s.strip().lower() for s in args.websites.split(',')]
                invalid_sources = [s for s in sources if s not in available]
                if invalid_sources:
                    print(f"âŒ Error: Invalid source(s): {', '.join(invalid_sources)}")
                    print(f"Available sources: {', '.join(available)}")
                    sys.exit(1)
        
        # Create and run downloader
        print(f"ğŸ¨ BoredNoMore3 Downloader v{VERSION}")
        print("=" * 80)
        
        downloader = BoredNoMore3Downloader(
            directory=args.directory,
            search=args.search,
            count=args.number,
            deep_search=args.deep,
            sources=sources,
            start_from=args.overwrite,
            randomize_source=args.random_source
        )
        
        downloader.fetch_all_sources()
        
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Download interrupted by user. Exiting gracefully...")
        sys.exit(0)
    except Exception as e:
        print(f"\nâŒ An error occurred: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/frontend/borednomore3_gui.py ===

#!/usr/bin/env python3
import customtkinter as ctk
import threading
import os
import sys
import subprocess
import time
import signal
import configparser
from tkinter import filedialog, Text
from pathlib import Path
# --- VERSION METADATA ---
VERSION = "3.3.0"
AUTHOR = "Deb"
# --- DEFAULT CONFIGURATION ---
DEFAULT_CONFIG = {
    'interval': 300,
    'directory': os.getcwd(),
    'frames': 10,
    'speed': 0.001,
    'transitions': '',
    'randomize': True,
    'keep_image': False,
    'borednomore3_binary': 'borednomore3',
    'config_file': 'borednomore3.conf'
}
# --- PID MANAGEMENT ---
PID_FILE = "/tmp/borednomore3.pid"
def save_pid(pid):
    """Save process PID to file."""
    try:
        with open(PID_FILE, "w") as f:
            f.write(str(pid))
        return True
    except Exception as e:
        print(f"[ERROR] Failed to save PID: {e}")
        return False
def get_saved_pid():
    """Retrieve saved PID from file."""
    if os.path.exists(PID_FILE):
        try:
            with open(PID_FILE, "r") as f:
                return int(f.read().strip())
        except Exception as e:
            print(f"[WARNING] Could not read PID file: {e}")
            return None
    return None
def is_pid_running(pid):
    """Check if a process with the given PID is running."""
    if pid is None:
        return False
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False
def kill_process(pid):
    """Terminate a process by PID."""
    if pid is None:
        return False
    try:
        os.kill(pid, signal.SIGTERM)
        time.sleep(0.5)
      
        if is_pid_running(pid):
            os.kill(pid, signal.SIGKILL)
            time.sleep(0.3)
      
        return not is_pid_running(pid)
    except Exception as e:
        print(f"[ERROR] Failed to kill process {pid}: {e}")
        return False
def cleanup_pid_file():
    """Remove PID file."""
    try:
        if os.path.exists(PID_FILE):
            os.remove(PID_FILE)
    except Exception as e:
        print(f"[WARNING] Could not remove PID file: {e}")
# --- CONFIG FILE MANAGEMENT ---
def load_config_file(config_path):
    """Load configuration from file"""
    config = {}
    if not os.path.exists(config_path):
        return config
  
    try:
        parser = configparser.ConfigParser()
        parser.read(config_path)
      
        if 'settings' in parser:
            settings = parser['settings']
          
            if 'interval' in settings:
                config['interval'] = int(settings['interval'])
            if 'directory' in settings:
                config['directory'] = settings['directory']
            if 'frames' in settings:
                config['frames'] = int(settings['frames'])
            if 'speed' in settings:
                config['speed'] = float(settings['speed'])
            if 'transitions' in settings:
                config['transitions'] = settings['transitions']
            if 'randomize' in settings:
                config['randomize'] = settings.getboolean('randomize')
            if 'keep_image' in settings:
                config['keep_image'] = settings.getboolean('keep_image')
            if 'borednomore3_binary' in settings:
                config['borednomore3_binary'] = settings['borednomore3_binary']
      
        return config
    except Exception as e:
        print(f"[WARNING] Error loading config file: {e}")
        return config
def save_config_file(config_path, config):
    """Save configuration to file"""
    try:
        parser = configparser.ConfigParser()
        parser['settings'] = {
            'interval': str(config['interval']),
            'directory': config['directory'],
            'frames': str(config['frames']),
            'speed': str(config['speed']),
            'transitions': config['transitions'],
            'randomize': str(config['randomize']),
            'keep_image': str(config['keep_image']),
            'borednomore3_binary': config['borednomore3_binary']
        }
      
        with open(config_path, 'w') as f:
            parser.write(f)
      
        print(f"[*] Configuration saved to: {config_path}")
        return True
    except Exception as e:
        print(f"[ERROR] Failed to save config: {e}")
        return False
# --- LOG REDIRECTION ---
class ConsoleRedirector:
    """Redirect stdout/stderr to GUI console."""
    def __init__(self, textbox):
        self.textbox = textbox
        self.buffer = []
    def write(self, text):
        if text.strip():
            try:
                self.textbox.configure(state="normal")
                self.textbox.insert("end", text + "\n")
                self.textbox.see("end")
                self.textbox.configure(state="disabled")
            except Exception:
                pass
    def flush(self):
        pass
# --- CUSTOM WIDGETS ---
class NumberInput(ctk.CTkFrame):
    """Custom numeric input with increment/decrement buttons."""
    def __init__(self, master, label, default=5, step=1, min_val=1, **kwargs):
        super().__init__(master, fg_color="transparent", **kwargs)
        self.step = step
        self.min_val = min_val
      
        self.lbl = ctk.CTkLabel(
            self, text=label,
            font=ctk.CTkFont(size=8, weight="bold"),
            text_color="#64748B"
        )
        self.lbl.pack(side="top", anchor="w", pady=(0, 1))
      
        self.container = ctk.CTkFrame(
            self, fg_color="#1E293B",
            height=28, corner_radius=5
        )
        self.container.pack(fill="x")
      
        self.entry = ctk.CTkEntry(
            self.container, width=50,
            border_width=0, fg_color="transparent",
            font=ctk.CTkFont(size=10, weight="bold"),
            justify="center"
        )
        self.entry.insert(0, str(default))
        self.entry.pack(side="left", expand=True, fill="both", padx=3)
      
        self.btn_f = ctk.CTkFrame(self.container, fg_color="transparent")
        self.btn_f.pack(side="right", padx=1)
      
        self.b1 = ctk.CTkButton(
            self.btn_f, text="+", width=18, height=12,
            fg_color="#334155", hover_color="#3B82F6",
            command=lambda: self.update_val(self.step)
        )
        self.b1.pack(pady=1)
      
        self.b2 = ctk.CTkButton(
            self.btn_f, text="-", width=18, height=12,
            fg_color="#334155", hover_color="#3B82F6",
            command=lambda: self.update_val(-self.step)
        )
        self.b2.pack(pady=1)
    def update_val(self, n):
        try:
            curr = float(self.entry.get())
            new_val = max(self.min_val, curr + n)
            self.entry.delete(0, "end")
            if self.step < 1:
                formatted = f"{new_val:.4f}".rstrip('0').rstrip('.')
            else:
                formatted = str(int(new_val))
            self.entry.insert(0, formatted)
        except ValueError:
            self.entry.delete(0, "end")
            self.entry.insert(0, str(self.min_val))
    def get(self):
        return self.entry.get()
    def set(self, value):
        self.entry.delete(0, "end")
        self.entry.insert(0, str(value))
    def set_state(self, state):
        self.entry.configure(state=state)
        self.b1.configure(state=state)
        self.b2.configure(state=state)
# --- MAIN GUI ---
class BoredMissionControl(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(f"BoredNoMore3 Mission Control v{VERSION}")
        self.configure(fg_color="#090E1A")
      
        # Dynamic responsive geometry based on screen size
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        width = int(screen_width * 0.8)  # 80% of screen width
        height = int(screen_height * 0.8)  # 80% of screen height
        width = max(1000, min(width, 1400))  # Clamp between 1000-1400
        height = max(600, min(height, 950))  # Clamp between 600-950
        self.geometry(f"{width}x{height}")
      
        # Center the window
        self.update_idletasks()
        x = (screen_width // 2) - (width // 2)
        y = (screen_height // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
      
        # Process Management
        self.bg_process_pid = None
        self.log_monitor_thread = None
        self.monitoring = False
        self.start_time = None
        self.log_file = "/tmp/borednomore3.log"
      
        # Configuration
        self.config = DEFAULT_CONFIG.copy()
        self.config_file_path = 'borednomore3.conf'
      
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)
        # Setup UI
        self.setup_ui()
      
        # Load configuration if exists
        self.load_configuration()
      
        # Check if engine is already running from previous session
        self.check_existing_engine()
      
        # Handle window close event
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
    def setup_ui(self):
        """Build the complete GUI."""
        # --- Sidebar ---
        self.side = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color="#111827")
        self.side.grid(row=0, column=0, rowspan=1, sticky="nsew")
      
        ctk.CTkLabel(
            self.side, text="BoredNoMore3",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color="#3B82F6"
        ).pack(pady=(15, 2))
      
        self.status_lbl = ctk.CTkLabel(
            self.side, text="STATUS: STANDBY",
            font=ctk.CTkFont(size=9, weight="bold"),
            text_color="#3B82F6"
        )
        self.status_lbl.pack(pady=(0, 2))
        self.pid_lbl = ctk.CTkLabel(
            self.side, text="PID: N/A",
            font=ctk.CTkFont(family="monospace", size=8),
            text_color="#475569"
        )
        self.pid_lbl.pack(pady=(0, 2))
        self.timer_lbl = ctk.CTkLabel(
            self.side, text="UPTIME: 00:00:00",
            font=ctk.CTkFont(family="monospace", size=9),
            text_color="#475569"
        )
        self.timer_lbl.pack(pady=(0, 4))
        # Configuration File Selection
        config_f = ctk.CTkFrame(self.side, fg_color="transparent")
        config_f.pack(fill="x", padx=15, pady=(2, 3))
      
        ctk.CTkLabel(
            config_f, text="CONFIG FILE",
            font=ctk.CTkFont(size=8, weight="bold"),
            text_color="#64748B"
        ).pack(side="top", anchor="w", pady=(0, 1))
      
        config_input_f = ctk.CTkFrame(config_f, fg_color="transparent")
        config_input_f.pack(fill="x")
      
        self.config_var = ctk.StringVar(value=self.config_file_path)
        self.config_entry = ctk.CTkEntry(
            config_input_f, textvariable=self.config_var,
            height=26, font=ctk.CTkFont(size=8),
            fg_color="#1F2937", border_width=0
        )
        self.config_entry.pack(side="left", expand=True, fill="x", padx=(0, 3))
      
        self.config_browse_btn = ctk.CTkButton(
            config_input_f, text="ğŸ“", width=26, height=26,
            fg_color="#374151", hover_color="#3B82F6",
            command=self.browse_config
        )
        self.config_browse_btn.pack(side="right")
        # Load/Save Config Buttons
        config_btn_f = ctk.CTkFrame(self.side, fg_color="transparent")
        config_btn_f.pack(fill="x", padx=15, pady=(0, 4))
      
        self.load_config_btn = ctk.CTkButton(
            config_btn_f, text="LOAD CONFIG",
            height=22, fg_color="#1E293B",
            hover_color="#3B82F6",
            font=ctk.CTkFont(size=8),
            command=self.load_configuration
        )
        self.load_config_btn.pack(side="left", expand=True, fill="x", padx=(0, 2))
      
        self.save_config_btn = ctk.CTkButton(
            config_btn_f, text="SAVE CONFIG",
            height=22, fg_color="#1E293B",
            hover_color="#10B981",
            font=ctk.CTkFont(size=8),
            command=self.save_configuration
        )
        self.save_config_btn.pack(side="right", expand=True, fill="x", padx=(2, 0))
        # Directory Selection
        self.path_var = ctk.StringVar(value=self.config['directory'])
        dir_f = ctk.CTkFrame(self.side, fg_color="transparent")
        dir_f.pack(fill="x", padx=15, pady=(2, 3))
      
        ctk.CTkLabel(
            dir_f, text="WALLPAPER DIRECTORY",
            font=ctk.CTkFont(size=8, weight="bold"),
            text_color="#64748B"
        ).pack(side="top", anchor="w", pady=(0, 1))
      
        folder_input_f = ctk.CTkFrame(dir_f, fg_color="transparent")
        folder_input_f.pack(fill="x")
      
        self.path_entry = ctk.CTkEntry(
            folder_input_f, textvariable=self.path_var,
            height=28, font=ctk.CTkFont(size=9),
            fg_color="#1F2937", border_width=0
        )
        self.path_entry.pack(side="left", expand=True, fill="x", padx=(0, 3))
      
        self.browse_btn = ctk.CTkButton(
            folder_input_f, text="ğŸ“‚", width=28, height=28,
            fg_color="#374151", hover_color="#3B82F6",
            command=self.browse
        )
        self.browse_btn.pack(side="right")
        # Control Inputs
        self.interval_ctrl = NumberInput(
            self.side, "INTERVAL (SEC)", self.config['interval'], step=10, min_val=1
        )
        self.interval_ctrl.pack(padx=15, pady=3, fill="x")
        self.frames_ctrl = NumberInput(
            self.side, "ANIMATION DENSITY", self.config['frames'], step=1, min_val=5
        )
        self.frames_ctrl.pack(padx=15, pady=3, fill="x")
        self.speed_ctrl = NumberInput(
            self.side, "TRANSITION SPEED", self.config['speed'], step=0.001, min_val=0.0001
        )
        self.speed_ctrl.pack(padx=15, pady=3, fill="x")
        # Binary Path Selection
        binary_f = ctk.CTkFrame(self.side, fg_color="transparent")
        binary_f.pack(fill="x", padx=15, pady=(3, 3))
      
        ctk.CTkLabel(
            binary_f, text="BACKEND BINARY",
            font=ctk.CTkFont(size=8, weight="bold"),
            text_color="#64748B"
        ).pack(side="top", anchor="w", pady=(0, 1))
      
        self.binary_var = ctk.StringVar(value=self.config['borednomore3_binary'])
        self.binary_entry = ctk.CTkEntry(
            binary_f, textvariable=self.binary_var,
            height=26, font=ctk.CTkFont(size=9),
            fg_color="#1F2937", border_width=0
        )
        self.binary_entry.pack(fill="x")
        # Switches
        self.rand_switch = ctk.CTkSwitch(
            self.side, text="Randomize Sequence",
            progress_color="#3B82F6",
            font=ctk.CTkFont(size=9)
        )
        self.rand_switch.pack(pady=3)
        if self.config['randomize']:
            self.rand_switch.select()
        self.keep_image_switch = ctk.CTkSwitch(
            self.side, text="Keep Image Mode",
            progress_color="#10B981",
            font=ctk.CTkFont(size=9)
        )
        self.keep_image_switch.pack(pady=2)
        if self.config['keep_image']:
            self.keep_image_switch.select()
        # Action Buttons
        self.start_btn = ctk.CTkButton(
            self.side, text="INITIALIZE ENGINE",
            height=36, fg_color="#3B82F6",
            hover_color="#2563EB",
            font=ctk.CTkFont(weight="bold", size=11),
            command=self.start_engine
        )
        self.start_btn.pack(padx=15, pady=2, fill="x")
        self.stop_btn = ctk.CTkButton(
            self.side, text="STOP ENGINE",
            height=36, fg_color="transparent",
            border_width=2, border_color="#334155",
            text_color="#94A3B8", hover_color="#DC2626",
            state="disabled", command=self.stop_engine,
            font=ctk.CTkFont(size=11)
        )
        self.stop_btn.pack(padx=15, pady=2, fill="x")
        # Red "End Program" button - now below STOP ENGINE, kills backend and exits
        self.end_program_btn = ctk.CTkButton(
            self.side, text="End Program",
            height=36, fg_color="#EF4444",
            hover_color="#B91C1C",
            font=ctk.CTkFont(weight="bold", size=11),
            command=self.end_program
        )
        self.end_program_btn.pack(padx=15, pady=2, fill="x")
        # --- Main View ---
        self.main = ctk.CTkFrame(self, fg_color="transparent")
        self.main.grid(row=0, column=1, sticky="nsew", padx=15, pady=5)
        # Command Bar
        self.cmd_bar = ctk.CTkFrame(self.main, fg_color="#111827", height=36, corner_radius=6)
        self.cmd_bar.pack(fill="x", pady=(0, 5))
      
        ctk.CTkLabel(
            self.cmd_bar, text="SYSTEM TOOLS",
            font=ctk.CTkFont(size=10, weight="bold"),
            text_color="#3B82F6"
        ).pack(side="left", padx=10)
      
        self.cmd_btns = []
        for label, flag in [("VERSION", "-v"), ("CREDITS", "-c"), ("HELP", "-h")]:
            b = ctk.CTkButton(
                self.cmd_bar, text=label, width=70, height=22,
                fg_color="#1E293B", hover_color="#3B82F6",
                text_color="#94A3B8",
                font=ctk.CTkFont(size=9, weight="bold"),
                command=lambda f=flag: self.run_external_cmd(f)
            )
            b.pack(side="right", padx=3)
            self.cmd_btns.append(b)
        # Transition Matrix Header
        header_f = ctk.CTkFrame(self.main, fg_color="transparent")
        header_f.pack(fill="x", pady=(0, 3))
      
        ctk.CTkLabel(
            header_f, text="TRANSITION MATRIX",
            font=ctk.CTkFont(size=11, weight="bold"),
            text_color="#E2E8F0"
        ).pack(side="left")
        self.util_f = ctk.CTkFrame(header_f, fg_color="transparent")
        self.util_f.pack(side="right")
      
        self.all_btn = ctk.CTkButton(
            self.util_f, text="SELECT ALL",
            width=60, height=18, fg_color="#1E293B",
            hover_color="#3B82F6",
            font=ctk.CTkFont(size=8),
            command=lambda: self.bulk_matrix(True)
        )
        self.all_btn.pack(side="left", padx=3)
      
        self.none_btn = ctk.CTkButton(
            self.util_f, text="UNSELECT ALL",
            width=70, height=18, fg_color="#1E293B",
            hover_color="#EF4444",
            font=ctk.CTkFont(size=8),
            command=lambda: self.bulk_matrix(False)
        )
        self.none_btn.pack(side="left", padx=3)
        # Transition Grid
        self.grid_frame = ctk.CTkScrollableFrame(
            self.main, fg_color="#111827",
            corner_radius=8, border_width=1,
            border_color="#1F2937",
            height=180,
            scrollbar_button_color="#3B82F6",
            scrollbar_button_hover_color="#2563EB"
        )
        self.grid_frame.pack(fill="both", expand=False, padx=1, pady=1)
      
        for c in range(5):
            self.grid_frame.grid_columnconfigure(c, weight=1)
        self.trans_vars = {}
        self.check_boxes = []
      
        # Using 100 transitions with real names
        transition_names = {
            1: "instant-cut",
            2: "fade",
            3: "fade-in",
            4: "fade-out",
            5: "slide-left",
            6: "slide-right",
            7: "slide-up",
            8: "slide-down",
            9: "zoom-in",
            10: "zoom-out",
            11: "focus-in",
            12: "focus-out",
            13: "wipe-left-to-right",
            14: "wipe-right-to-left",
            15: "wipe-top-to-bottom",
            16: "wipe-bottom-to-top",
            17: "diagonal-top-left-to-bottom-right",
            18: "diagonal-bottom-right-to-top-left",
            19: "diagonal-top-right-to-bottom-left",
            20: "diagonal-bottom-left-to-top-right",
            21: "iris-in",
            22: "iris-out",
            23: "clock-wipe-clockwise",
            24: "clock-wipe-counterclockwise",
            25: "barn-door-open",
            26: "barn-door-close",
            27: "split-vertical-open",
            28: "split-vertical-close",
            29: "split-horizontal-open",
            30: "split-horizontal-close",
            31: "checker-dissolve",
            32: "pixelate-transition",
            33: "spiral-clockwise",
            34: "spiral-counterclockwise",
            35: "dissolve-white",
            36: "dissolve-black",
            37: "whip-pan-left",
            38: "whip-pan-right",
            39: "whip-pan-up",
            40: "whip-pan-down",
            41: "push-left",
            42: "push-right",
            43: "push-up",
            44: "push-down",
            45: "reveal-left",
            46: "reveal-right",
            47: "reveal-up",
            48: "reveal-down",
            49: "box-in",
            50: "box-out",
            51: "diamond-in",
            52: "diamond-out",
            53: "venetian-blinds-horizontal",
            54: "venetian-blinds-vertical",
            55: "checkerboard-inward",
            56: "checkerboard-outward",
            57: "radial-wipe-in",
            58: "radial-wipe-out",
            59: "crossfade",
            60: "glitch-transition",
            61: "light-leak",
            62: "film-burn",
            63: "corner-pin-top-left",
            64: "corner-pin-top-right",
            65: "corner-pin-bottom-left",
            66: "corner-pin-bottom-right",
            67: "center-expand",
            68: "center-collapse",
            69: "wave-left-to-right",
            70: "wave-right-to-left",
            71: "wave-top-to-bottom",
            72: "wave-bottom-to-top",
            73: "twist-clockwise",
            74: "twist-counterclockwise",
            75: "ripple-center",
            76: "ripple-edges",
            77: "mosaic-transition",
            78: "mirror-flip-horizontal",
            79: "mirror-flip-vertical",
            80: "shatter-from-center",
            81: "shatter-from-edges",
            82: "fold-left",
            83: "fold-right",
            84: "fold-up",
            85: "fold-down",
            86: "cube-rotate-left",
            87: "cube-rotate-right",
            88: "cube-rotate-up",
            89: "cube-rotate-down",
            90: "page-curl-top-right",
            91: "page-curl-bottom-left",
            92: "linear-blur-left-to-right",
            93: "linear-blur-right-to-left",
            94: "radial-blur-in",
            95: "radial-blur-out",
            96: "squares-random",
            97: "strips-left-to-right",
            98: "strips-right-to-left",
            99: "strips-top-to-bottom",
            100: "strips-bottom-to-top",
        }
      
        for i in range(1, 101):
            var = ctk.BooleanVar(value=True)
            name = transition_names.get(i, f"Unknown-{i}")
            display_text = f"{i}: {name}"
            cb = ctk.CTkCheckBox(
                self.grid_frame,
                text=display_text,
                variable=var,
                font=ctk.CTkFont(family="Consolas", size=7),
                checkbox_width=10, checkbox_height=10,
                hover_color="#3B82F6"
            )
            cb.grid(row=(i-1) // 5, column=(i-1) % 5, padx=4, pady=2, sticky="w")
            self.trans_vars[i] = var
            self.check_boxes.append(cb)
        # Console Section
        console_header = ctk.CTkFrame(self.main, fg_color="transparent")
        console_header.pack(fill="x", pady=(5, 2))
      
        ctk.CTkLabel(
            console_header, text="ENGINE CONSOLE",
            font=ctk.CTkFont(size=9, weight="bold"),
            text_color="#E2E8F0"
        ).pack(side="left")
      
        self.clear_btn = ctk.CTkButton(
            console_header, text="CLEAR",
            width=60, height=16, fg_color="transparent",
            text_color="#F59E0B", hover_color="#EF4444",
            font=ctk.CTkFont(size=8),
            command=self.clear_console
        )
        self.clear_btn.pack(side="right", padx=3)
      
        self.export_btn = ctk.CTkButton(
            console_header, text="EXPORT LOG",
            width=60, height=16, fg_color="transparent",
            text_color="#3B82F6", hover_color="#10B981",
            font=ctk.CTkFont(size=8),
            command=self.export_log
        )
        self.export_btn.pack(side="right")
        self.console = ctk.CTkTextbox(
            self.main, fg_color="#05070A",
            border_width=1, border_color="#1F2937",
            text_color="#10B981",
            font=ctk.CTkFont(family="monospace", size=9),
            wrap="word"
        )
        self.console.pack(fill="both", expand=True)
        self.console.configure(state="disabled")
      
        # Redirect stdout to console
        sys.stdout = ConsoleRedirector(self.console)
        sys.stderr = ConsoleRedirector(self.console)
      
        # Start clock update
        self.update_clock()
      
        print(f"[*] BoredNoMore3 Mission Control v{VERSION} initialized")
        print(f"[*] Ready to launch background engine")
    # --- CONFIGURATION MANAGEMENT ---
    def load_configuration(self):
        """Load configuration from file"""
        config_file = self.config_var.get()
        if os.path.exists(config_file):
            loaded_config = load_config_file(config_file)
            if loaded_config:
                self.config.update(loaded_config)
                self.apply_config_to_ui()
                print(f"[*] Configuration loaded from: {config_file}")
            else:
                print(f"[WARNING] Could not load configuration from: {config_file}")
        else:
            print(f"[INFO] Config file not found: {config_file}, using defaults")
    def save_configuration(self):
        """Save current UI settings to configuration file"""
        self.config['directory'] = self.path_var.get()
        self.config['interval'] = int(self.interval_ctrl.get())
        self.config['frames'] = int(self.frames_ctrl.get())
        self.config['speed'] = float(self.speed_ctrl.get())
        self.config['randomize'] = self.rand_switch.get()
        self.config['keep_image'] = self.keep_image_switch.get()
        self.config['borednomore3_binary'] = self.binary_var.get()
      
        # Get selected transitions
        selected = [str(n) for n, v in self.trans_vars.items() if v.get()]
        self.config['transitions'] = ','.join(selected)
      
        config_file = self.config_var.get()
        if save_config_file(config_file, self.config):
            print(f"[+] Configuration saved successfully")
        else:
            print(f"[ERROR] Failed to save configuration")
    def apply_config_to_ui(self):
        """Apply loaded configuration to UI elements"""
        self.path_var.set(self.config['directory'])
        self.interval_ctrl.set(self.config['interval'])
        self.frames_ctrl.set(self.config['frames'])
        self.speed_ctrl.set(self.config['speed'])
        self.binary_var.set(self.config['borednomore3_binary'])
      
        if self.config['randomize']:
            self.rand_switch.select()
        else:
            self.rand_switch.deselect()
      
        if self.config['keep_image']:
            self.keep_image_switch.select()
        else:
            self.keep_image_switch.deselect()
      
        # Apply transition selection
        if self.config['transitions']:
            # First deselect all
            for cb in self.check_boxes:
                cb.deselect()
          
            # Then select specified ones
            try:
                transitions = [int(t.strip()) for t in self.config['transitions'].split(',') if t.strip()]
                for t in transitions:
                    if t in self.trans_vars:
                        self.trans_vars[t].set(True)
            except:
                pass
    def browse_config(self):
        """Browse for configuration file"""
        path = filedialog.askopenfilename(
            initialdir=os.getcwd(),
            title="Select Configuration File",
            filetypes=(("Config files", "*.conf"), ("All files", "*.*"))
        )
        if path:
            self.config_var.set(path)
            self.load_configuration()
    # --- PROCESS MANAGEMENT ---
    def get_backend_command(self, use_unbuffered=False):
        """Get the backend command from config or detect binary
      
        Args:
            use_unbuffered: If True, add -u flag for unbuffered output (only for background processes)
        """
        binary = self.binary_var.get().strip()
      
        if not binary:
            binary = 'borednomore3'
      
        # Check if running from source or as binary
        if getattr(sys, 'frozen', False):
            # GUI is compiled, use configured binary name
            return [binary]
      
        # GUI is running as script, check if backend is .py or binary
        if os.path.exists(f"{binary}.py"):
            if use_unbuffered:
                return [sys.executable, "-u", f"{binary}.py"]
            else:
                return [sys.executable, f"{binary}.py"]
        elif os.path.exists(binary):
            return [f"./{binary}"]
        else:
            return [binary]
    def check_existing_engine(self):
        """Check if engine is already running from previous session."""
        pid = get_saved_pid()
        if pid and is_pid_running(pid):
            self.bg_process_pid = pid
            print(f"[*] Detected existing engine running (PID: {pid})")
            print(f"[*] Resuming monitoring of background process")
            print(f"[*] Output log: /tmp/borednomore3.log")
            self.set_running_state(True)
          
            # Try to load existing log content
            log_file = "/tmp/borednomore3.log"
            try:
                if os.path.exists(log_file):
                    with open(log_file, 'r') as f:
                        content = f.read()
                        if content:
                            print("=" * 80)
                            print("--- Previous Engine Output (last 30 lines) ---")
                            print("=" * 80)
                            lines = content.splitlines()
                            for line in lines[-30:]:
                                print(line)
                            print("=" * 80)
                            print("--- Continuing live output ---")
            except Exception as e:
                print(f"[WARNING] Could not read previous log: {e}")
          
            self.start_log_monitoring(log_file)
        else:
            if pid:
                print(f"[*] Stale PID file detected, cleaning up")
                cleanup_pid_file()
            self.set_running_state(False)
    def start_engine(self):
        """Launch the background engine process."""
        selected_t = [int(n) for n, v in self.trans_vars.items() if v.get()]
        if not selected_t:
            print("[ERROR] No transitions selected! Select at least one.")
            return
      
        base_cmd = self.get_backend_command(use_unbuffered=True)
        flags = [
            "-d", self.path_var.get(),
            "-i", str(self.interval_ctrl.get()),
            "-f", str(self.frames_ctrl.get()),
            "-s", str(self.speed_ctrl.get()),
            "-t", ",".join(map(str, selected_t))
        ]
        if self.rand_switch.get():
            flags.append("-r")
        if self.keep_image_switch.get():
            flags.append("-k")
        print(f"[*] Launching background engine...")
        print(f"[*] Command: {' '.join(base_cmd + flags)}")
        try:
            log_file = "/tmp/borednomore3.log"
          
            with open(log_file, "w") as log:
                process = subprocess.Popen(
                    base_cmd + flags,
                    stdout=log,
                    stderr=subprocess.STDOUT,
                    stdin=subprocess.DEVNULL,
                    start_new_session=True,
                    bufsize=0,
                    env={**os.environ, 'PYTHONUNBUFFERED': '1'}
                )
          
            self.bg_process_pid = process.pid
            save_pid(process.pid)
          
            print(f"[+] Engine started successfully (PID: {process.pid})")
            print(f"[+] Process is now running in background")
            print(f"[*] Output is being logged to: {log_file}")
            print(f"[*] Streaming engine output below:")
            print("=" * 80)
          
            self.start_time = time.time()
            self.set_running_state(True)
          
            self.start_log_monitoring(log_file)
          
        except Exception as e:
            print(f"[ERROR] Failed to start engine: {e}")
            self.set_running_state(False)
    def stop_engine(self):
        """Stop the background engine process."""
        if not self.bg_process_pid:
            print("[WARNING] No active process to stop")
            return
      
        print(f"[!] Terminating engine (PID: {self.bg_process_pid})...")
      
        if kill_process(self.bg_process_pid):
            print(f"[OK] Engine process {self.bg_process_pid} terminated")
            cleanup_pid_file()
            self.bg_process_pid = None
            self.start_time = None
            self.set_running_state(False)
        else:
            print(f"[ERROR] Failed to terminate process {self.bg_process_pid}")
            print(f"[*] You may need to kill it manually: kill {self.bg_process_pid}")
    def start_log_monitoring(self, log_file=None):
        """Monitor if background process is still running and tail log file."""
        if self.monitoring:
            return
      
        self.monitoring = True
        self.log_file = log_file or "/tmp/borednomore3.log"
      
        def monitor():
            last_position = 0
            time.sleep(0.2)
          
            while self.monitoring and self.bg_process_pid:
                if not is_pid_running(self.bg_process_pid):
                    print("=" * 80)
                    print(f"[!] Background process {self.bg_process_pid} has terminated")
                    cleanup_pid_file()
                    self.after(0, lambda: self.set_running_state(False))
                    self.bg_process_pid = None
                    break
              
                try:
                    if os.path.exists(self.log_file):
                        with open(self.log_file, 'r') as f:
                            f.seek(last_position)
                            new_content = f.read()
                            if new_content:
                                for line in new_content.splitlines():
                                    print(line)
                                last_position = f.tell()
                except Exception:
                    pass
              
                time.sleep(0.3)
      
        self.log_monitor_thread = threading.Thread(target=monitor, daemon=True)
        self.log_monitor_thread.start()
    # --- UI STATE MANAGEMENT ---
    def set_running_state(self, running):
        """Update GUI to reflect engine state."""
        if running:
            self.status_lbl.configure(
                text="STATUS: ACTIVE (BACKGROUND)",
                text_color="#10B981"
            )
            self.pid_lbl.configure(
                text=f"PID: {self.bg_process_pid or 'N/A'}",
                text_color="#10B981"
            )
            self.start_btn.configure(
                state="disabled",
                text="ENGINE ACTIVE",
                fg_color="#334155"
            )
            self.stop_btn.configure(
                state="normal",
                text_color="#EF4444",
                border_color="#EF4444"
            )
            self.set_controls_state(False)
          
            if not self.monitoring:
                self.start_log_monitoring()
              
        else:
            self.status_lbl.configure(
                text="STATUS: STANDBY",
                text_color="#3B82F6"
            )
            self.pid_lbl.configure(
                text="PID: N/A",
                text_color="#475569"
            )
            self.start_btn.configure(
                state="normal",
                text="INITIALIZE ENGINE",
                fg_color="#3B82F6"
            )
            self.stop_btn.configure(
                state="disabled",
                text_color="#94A3B8",
                border_color="#334155"
            )
            self.set_controls_state(True)
            self.monitoring = False
    def set_controls_state(self, enabled):
        """Enable/disable control inputs."""
        state = "normal" if enabled else "disabled"
      
        self.path_entry.configure(state=state)
        self.browse_btn.configure(state=state)
        self.config_entry.configure(state=state)
        self.config_browse_btn.configure(state=state)
        self.load_config_btn.configure(state=state)
        self.save_config_btn.configure(state=state)
        self.interval_ctrl.set_state(state)
        self.frames_ctrl.set_state(state)
        self.speed_ctrl.set_state(state)
        self.binary_entry.configure(state=state)
        self.rand_switch.configure(state=state)
        self.keep_image_switch.configure(state=state)
        self.all_btn.configure(state=state)
        self.none_btn.configure(state=state)
      
        for cb in self.check_boxes:
            cb.configure(state=state)
      
        for b in self.cmd_btns:
            b.configure(state=state)
    # --- UI UTILITIES ---
    def update_clock(self):
        """Update uptime display."""
        if self.start_time and self.bg_process_pid and is_pid_running(self.bg_process_pid):
            elapsed = int(time.time() - self.start_time)
            self.timer_lbl.configure(
                text=f"UPTIME: {time.strftime('%H:%M:%S', time.gmtime(elapsed))}",
                text_color="#10B981"
            )
        else:
            self.timer_lbl.configure(
                text="UPTIME: 00:00:00",
                text_color="#475569"
            )
      
        self.after(1000, self.update_clock)
    def bulk_matrix(self, state):
        """Select/deselect all transitions."""
        for cb in self.check_boxes:
            if state:
                cb.select()
            else:
                cb.deselect()
    def run_external_cmd(self, flag):
        """Run backend command and capture output."""
        def execute():
            cmd = self.get_backend_command(use_unbuffered=False) + [flag]
            print(f"[*] Executing: {' '.join(cmd)}")
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.stdout:
                    for line in result.stdout.splitlines():
                        print(line)
                if result.stderr:
                    for line in result.stderr.splitlines():
                        print(f"[ERROR] {line}")
            except subprocess.TimeoutExpired:
                print("[ERROR] Command timed out")
            except Exception as e:
                print(f"[ERROR] Command failed: {e}")
      
        threading.Thread(target=execute, daemon=True).start()
    def clear_console(self):
        """Clear console output."""
        self.console.configure(state="normal")
        self.console.delete("1.0", "end")
        self.console.configure(state="disabled")
        print(f"[*] Console cleared at {time.strftime('%H:%M:%S')}")
    def export_log(self):
        """Export console log to file."""
        try:
            content = self.console.get("1.0", "end-1c")
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"borednomore_log_{timestamp}.txt"
          
            with open(filename, "w") as f:
                f.write(content)
          
            print(f"[*] Log exported to {filename}")
        except Exception as e:
            print(f"[ERROR] Failed to export log: {e}")
    def browse(self):
        """Open directory browser."""
        path = filedialog.askdirectory(initialdir=self.path_var.get())
        if path:
            self.path_var.set(path)
            print(f"[*] Directory changed to: {path}")
    def on_closing(self):
        """Handle window close - keep engine running."""
        if self.bg_process_pid and is_pid_running(self.bg_process_pid):
            print(f"[*] Closing GUI - engine will continue running (PID: {self.bg_process_pid})")
            print(f"[*] To stop engine, restart GUI and click STOP ENGINE")
      
        self.monitoring = False
        self.destroy()
    def end_program(self):
        """End Program - stop backend if running and close GUI"""
        if self.bg_process_pid and is_pid_running(self.bg_process_pid):
            self.stop_engine()
        self.destroy()
# --- MAIN ENTRY POINT ---
if __name__ == "__main__":
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("blue")
  
    app = BoredMissionControl()
    app.mainloop()



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/frontend/borednomore3_downloader_gui.py ===

#!/usr/bin/env python3
import os
import sys
import hashlib
import glob
import re
import threading
import subprocess
import time
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import customtkinter as ctk

VERSION = "0.7.0"

# Import the engines module
try:
    from borednomore3_downloader_engines import DownloadEngines
except ImportError:
    print("ERROR: borednomore3_downloader_engines.py not found!")
    print("Please ensure the engines file is in the same directory.")
    sys.exit(1)

# --- LOG REDIRECTION ---
class RedirectText:
    """Thread-safe text redirection to GUI console."""
    def __init__(self, text_widget):
        self.text_widget = text_widget
        self.queue = []
        self.lock = threading.Lock()

    def write(self, string):
        """Write to buffer (called from any thread)."""
        if string.strip():
            with self.lock:
                self.queue.append(string)

    def flush_to_widget(self):
        """Flush buffer to widget (must be called from main thread)."""
        with self.lock:
            if self.queue:
                self.text_widget.configure(state="normal")
                for text in self.queue:
                    self.text_widget.insert("end", text)
                self.text_widget.see("end")
                self.text_widget.configure(state="disabled")
                self.queue.clear()

    def flush(self):
        pass

# --- CORE DOWNLOADER ENGINE ---
class BoredNoMore3Downloader:
    """Main downloader class that uses the engines module."""

    def __init__(self, directory=".", search="dark wallpaper", count=10, sources=None,
                 start_from=None, deep=False, random_src=False):
        self.directory = os.path.abspath(os.path.expanduser(directory))
        self.search = search
        self.target_count = count
        self.deep = deep
        self.downloaded_hashes = set()
        self.start_from = start_from
        self.total_saved = 0

        # Initialize download engines
        self.engines = DownloadEngines(self)

        # Available sources mapping to engine methods
        self.available_sources = {
            'unsplash': self.engines.download_from_unsplash,
            'pexels': self.engines.download_from_pexels,
            'pixabay': self.engines.download_from_pixabay,
            'picsum': self.engines.download_from_picsum,
            'wallhaven': self.engines.download_from_wallhaven,
            'google': self.engines.download_from_google,
            'bing': self.engines.download_from_bing,
        }

        # Handle source selection
        if random_src:
            import random
            self.sources = [random.choice(list(self.available_sources.keys()))]
            print(f"Random source selected: {self.sources[0]}")
        elif not sources:
            self.sources = list(self.available_sources.keys())
        else:
            self.sources = sources

        # Create directory if needed
        if not os.path.isdir(self.directory):
            os.makedirs(self.directory, exist_ok=True)
            print(f"Created directory: {self.directory}")

        self._initialize_numbering()

    def _initialize_numbering(self):
        """Scan existing files and determine next number."""
        existing_files = glob.glob(os.path.join(self.directory, "wallpaper*.jpg"))
        max_number = 0
        number_pattern = re.compile(r'wallpaper_(\d+)\.jpg')

        for filepath in existing_files:
            filename = os.path.basename(filepath)
            match = number_pattern.match(filename)
            if match:
                num = int(match.group(1))
                max_number = max(max_number, num)

            # Load hashes for duplicate detection
            if self.start_from is None:
                h = self._get_file_hash(filepath)
                if h:
                    self.downloaded_hashes.add(h)

        self.next_number = self.start_from if self.start_from is not None else max_number + 1

        if existing_files:
            print(f"Found {len(existing_files)} existing wallpapers")
            print(f"Starting from number: {self.next_number}")

    def _get_file_hash(self, filepath):
        """Calculate SHA256 hash of a file."""
        sha256_hash = hashlib.sha256()
        try:
            with open(filepath, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except:
            return None

    def save_image(self, image_data, source_name):
        """Save image with smart numbering."""
        if self.total_saved >= self.target_count:
            return "STOP"

        if not image_data or len(image_data) < 10000:
            return False

        # Check for duplicates (unless in overwrite mode)
        if self.start_from is None:
            file_hash = hashlib.sha256(image_data).hexdigest()
            if file_hash in self.downloaded_hashes:
                return False
            self.downloaded_hashes.add(file_hash)

        filename = f"wallpaper_{self.next_number:05d}.jpg"
        try:
            with open(os.path.join(self.directory, filename), "wb") as f:
                f.write(image_data)

            file_size_kb = len(image_data) / 1024
            print(f" {filename} ({source_name}) - {file_size_kb:.1f} KB")
            self.next_number += 1
            self.total_saved += 1
            return True
        except Exception as e:
            print(f" Error saving {filename}: {e}")
            return False

    def fetch_all_sources(self):
        """Download wallpapers from selected sources."""
        print(f"\n{'='*80}")
        print(f" BoredNoMore3 Downloader v{VERSION}")
        print(f"{'='*80}")
        print(f" Search: '{self.search}'")
        print(f" Target: {self.target_count} images")
        print(f" Sources: {', '.join(self.sources)}")
        print(f" Directory: {self.directory}")
        print(f"{'='*80}\n")

        for s in self.sources:
            if self.total_saved >= self.target_count:
                break
            if s in self.available_sources:
                try:
                    self.available_sources[s]()
                except Exception as e:
                    print(f"[{s}] Error: {e}")

        print(f"\n{'='*80}")
        print(f" Download Complete!")
        print(f" Total images saved: {self.total_saved}")
        print(f" Location: {self.directory}")
        print(f"{'='*80}")

# --- TRANSITION DESCRIPTIONS ---
TRANSITION_DESCRIPTIONS = {
    "instant-cut": "Instantly switches to the new wallpaper. No animation.",
    "fade": "Smooth crossfade between old and new wallpaper.",
    "fade-in": "Fades from black to the new wallpaper.",
    "fade-out": "Fades to black, then reveals the new wallpaper.",
    "slide-left": "New wallpaper slides in from the right over the old one.",
    "slide-right": "New wallpaper slides in from the left.",
    "slide-up": "New wallpaper slides in from the bottom.",
    "slide-down": "New wallpaper slides in from the top.",
    "zoom-in": "New wallpaper zooms in from the center.",
    "zoom-out": "Old wallpaper zooms out, revealing the new one underneath.",
    "focus-in": "Blur shifts from old to new wallpaper.",
    "focus-out": "Blur shifts from new to old (reverse focus).",
    "wipe-left-to-right": "Wipe reveal from left to right.",
    "wipe-right-to-left": "Wipe reveal from right to left.",
    "wipe-top-to-bottom": "Wipe reveal from top to bottom.",
    "wipe-bottom-to-top": "Wipe reveal from bottom to top.",
    "diagonal-top-left-to-bottom-right": "Diagonal wipe from top-left corner.",
    "diagonal-bottom-right-to-top-left": "Diagonal wipe from bottom-right.",
    "diagonal-top-right-to-bottom-left": "Diagonal wipe from top-right.",
    "diagonal-bottom-left-to-top-right": "Diagonal wipe from bottom-left.",
    "iris-in": "Circular iris expands from center revealing new wallpaper.",
    "iris-out": "Circular iris closes to center showing new underneath.",
    "clock-wipe-clockwise": "Clock hand wipe rotating clockwise.",
    "clock-wipe-counterclockwise": "Clock hand wipe rotating counterclockwise.",
    "box-in": "Square expands from center revealing new wallpaper.",
    "box-out": "Square collapses to center.",
    "diamond-in": "Diamond shape expands from center.",
    "diamond-out": "Diamond shape collapses to center.",
    "page-curl-top-right": "Realistic page curl effect from top-right corner.",
    "page-curl-bottom-left": "Page curl from bottom-left corner.",
    "cube-rotate-left": "3D cube rotation to the left.",
    "cube-rotate-right": "3D cube rotation to the right.",
    "cube-rotate-up": "3D cube rotation upward.",
    "cube-rotate-down": "3D cube rotation downward.",
    "glitch-transition": "Digital glitch effect with RGB separation.",
    "checker-dissolve": "Checkerboard pattern dissolve.",
    "pixelate-transition": "Gradual pixelation dissolve.",
    "wave-left-to-right": "Sinusoidal wave distortion moving left to right.",
    "venetian-blinds-horizontal": "Horizontal blind slats opening.",
    "venetian-blinds-vertical": "Vertical blind slats opening.",
}

# --- GUI LAYER ---
class BoredNoMoreGUI(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(f"BoredNoMore3 Downloader v{VERSION}")
        self.geometry("1200x950")
        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")

        self.bg_process = None
        self.is_running = False
        self.redirector = None

        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=1)
        self.grid_rowconfigure(2, weight=0)

        # Sidebar
        self.sidebar = ctk.CTkFrame(self, width=220, corner_radius=0, fg_color="#111827")
        self.sidebar.grid(row=0, column=0, rowspan=3, sticky="nsew")

        ctk.CTkLabel(
            self.sidebar, text="BNM3\nDownloader",
            font=ctk.CTkFont(size=22, weight="bold"),
            text_color="#3B82F6"
        ).pack(pady=40)

        ctk.CTkButton(
            self.sidebar, text="Help",
            fg_color="transparent", border_width=1,
            hover_color="#3B82F6",
            command=lambda: self.run_cli("-h")
        ).pack(pady=5, padx=20, fill="x")

        ctk.CTkButton(
            self.sidebar, text="Credits",
            fg_color="transparent", border_width=1,
            hover_color="#3B82F6",
            command=lambda: self.run_cli("-c")
        ).pack(pady=5, padx=20, fill="x")

        ctk.CTkButton(
            self.sidebar, text="Version",
            fg_color="transparent", border_width=1,
            hover_color="#3B82F6",
            command=lambda: self.run_cli("-v")
        ).pack(pady=5, padx=20, fill="x")

        # Transition Info Button
        ctk.CTkButton(
            self.sidebar, text="Transition Info",
            fg_color="#6366F1", hover_color="#4F46E5",
            command=self.show_transition_info
        ).pack(pady=15, padx=20, fill="x")

        # End Program Button
        self.exit_btn = ctk.CTkButton(
            self.sidebar, text="End Program",
            fg_color="#EF4444", hover_color="#B91C1C",
            font=ctk.CTkFont(weight="bold"),
            command=self.quit_app
        )
        self.exit_btn.pack(side="bottom", pady=30, padx=20, fill="x")

        # Main Layout
        self.main_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.main_frame.grid(row=0, column=1, padx=20, pady=10, sticky="nsew")

        ctk.CTkLabel(
            self.main_frame, text="Search Keywords",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(10, 5))

        self.search_entry = ctk.CTkEntry(
            self.main_frame, width=600, height=35,
            placeholder_text="Enter search keywords..."
        )
        self.search_entry.pack(pady=(0, 15), padx=10, anchor="w", fill="x")
        self.search_entry.insert(0, "dark wallpaper")

        # Directory selection
        dir_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        dir_frame.pack(fill="x", padx=10, pady=(0, 15))

        self.path_var = tk.StringVar(value=os.getcwd())
        self.dir_btn = ctk.CTkButton(
            dir_frame, text="Select Folder",
            width=150, command=self.select_dir
        )
        self.dir_btn.pack(side="left")

        ctk.CTkLabel(
            dir_frame, textvariable=self.path_var,
            font=("Courier", 10), text_color="#64748B"
        ).pack(side="left", padx=10, fill="x", expand=True)

        # Source selection
        ctk.CTkLabel(
            self.main_frame, text="Download Sources",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(10, 5))

        self.source_frame = ctk.CTkFrame(self.main_frame, fg_color="#1E293B", corner_radius=8)
        self.source_frame.pack(fill="x", padx=10, pady=5)

        self.sources_vars = {}
        srcs = ['unsplash', 'pexels', 'pixabay', 'picsum', 'wallhaven', 'google', 'bing']
        for i, s in enumerate(srcs):
            v = tk.BooleanVar(value=True)
            cb = ctk.CTkCheckBox(
                self.source_frame, text=s.capitalize(),
                variable=v, hover_color="#3B82F6"
            )
            cb.grid(row=0, column=i, padx=10, pady=10)
            self.sources_vars[s] = v

        # Control options
        self.ctrl_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        self.ctrl_frame.pack(fill="x", padx=10, pady=10)

        self.deep_var = tk.BooleanVar(value=False)
        self.rand_var = tk.BooleanVar(value=False)

        self.deep_cb = ctk.CTkCheckBox(
            self.ctrl_frame, text="Deep Search (More Pages)",
            variable=self.deep_var
        )
        self.deep_cb.pack(side="left", padx=10)

        self.rand_cb = ctk.CTkCheckBox(
            self.ctrl_frame, text="Random Source Selection",
            variable=self.rand_var
        )
        self.rand_cb.pack(side="left", padx=10)

        # Count slider
        ctk.CTkLabel(
            self.main_frame, text="Download Count",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(10, 5))

        self.count_slider = ctk.CTkSlider(
            self.main_frame, from_=1, to=100,
            command=lambda v: self.count_lbl.configure(
                text=f"Total images to download: {int(v)}"
            )
        )
        self.count_slider.set(10)
        self.count_slider.pack(fill="x", padx=10)

        self.count_lbl = ctk.CTkLabel(
            self.main_frame, text="Total images to download: 10",
            font=("Courier", 11), text_color="#64748B"
        )
        self.count_lbl.pack(anchor="w", padx=15, pady=(5, 10))

        # Overwrite option
        ow_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        ow_frame.pack(fill="x", padx=10, pady=5)

        ctk.CTkLabel(
            ow_frame, text="Overwrite from number:",
            font=ctk.CTkFont(size=11)
        ).pack(side="left")

        self.ow_entry = ctk.CTkEntry(
            ow_frame, placeholder_text="Leave empty for append mode",
            width=200
        )
        self.ow_entry.pack(side="left", padx=10)

        # Console
        console_label = ctk.CTkLabel(
            self, text="Console Output",
            font=ctk.CTkFont(weight="bold", size=12)
        )
        console_label.grid(row=1, column=1, padx=20, pady=(10, 5), sticky="w")

        self.console_box = ctk.CTkTextbox(
            self, font=("Courier New", 11),
            fg_color="#000000", text_color="#10B981",
            state="disabled", wrap="word"
        )
        self.console_box.grid(row=1, column=1, padx=20, pady=(0, 10), sticky="nsew")

        # Setup redirector and start periodic update
        self.redirector = RedirectText(self.console_box)
        sys.stdout = self.redirector
        sys.stderr = self.redirector
        self.update_console()

        # Action Buttons
        self.btn_f = ctk.CTkFrame(self, fg_color="transparent")
        self.btn_f.grid(row=2, column=1, padx=20, pady=(0, 20), sticky="ew")

        self.launch_btn = ctk.CTkButton(
            self.btn_f, text="START DOWNLOAD",
            height=50, fg_color="#10B981",
            hover_color="#059669",
            font=ctk.CTkFont(weight="bold", size=14),
            command=self.start
        )
        self.launch_btn.pack(side="left", expand=True, fill="x", padx=(0, 5))

        self.stop_btn = ctk.CTkButton(
            self.btn_f, text="STOP",
            height=50, width=150,
            fg_color="#EF4444", hover_color="#DC2626",
            font=ctk.CTkFont(weight="bold", size=14),
            state="disabled", command=self.stop_mission
        )
        self.stop_btn.pack(side="right")

        self.input_widgets = [
            self.search_entry, self.dir_btn, self.deep_cb,
            self.rand_cb, self.count_slider, self.ow_entry,
            self.launch_btn
        ]

        print(f" BoredNoMore3 Downloader GUI v{VERSION}")
        print("Ready to download wallpapers!")

    def update_console(self):
        """Periodically update console from buffer."""
        if self.redirector:
            self.redirector.flush_to_widget()
        self.after(100, self.update_console)

    def show_transition_info(self):
        """Show a window with all transition names and descriptions."""
        info_win = ctk.CTkToplevel(self)
        info_win.title("Wallpaper Transition Effects")
        info_win.geometry("900x700")
        info_win.transient(self)
        info_win.grab_set()

        ctk.CTkLabel(
            info_win, text="Available Transition Effects",
            font=ctk.CTkFont(size=18, weight="bold")
        ).pack(pady=15)

        # Scrollable frame
        canvas = tk.Canvas(info_win, bg="#1E293B")
        scrollbar = ttk.Scrollbar(info_win, orient="vertical", command=canvas.yview)
        scrollable_frame = ctk.CTkFrame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y")

        # Populate transitions
        sorted_trans = sorted(TRANSITION_DESCRIPTIONS.items(), key=lambda x: x[0])

        for name, desc in sorted_trans:
            frame = ctk.CTkFrame(scrollable_frame, fg_color="transparent")
            frame.pack(fill="x", padx=15, pady=5)

            ctk.CTkLabel(
                frame, text=name.replace("-", " ").title(),
                font=ctk.CTkFont(weight="bold", size=13),
                anchor="w"
            ).pack(anchor="w")

            ctk.CTkLabel(
                frame, text=desc,
                font=ctk.CTkFont(size=11),
                text_color="#94A3B8", anchor="w", wraplength=800, justify="left"
            ).pack(anchor="w", pady=(0, 10))

    def get_backend_command(self):
        """Detect if running from source or as binary."""
        if getattr(sys, 'frozen', False):
            return ["borednomore3-downloader"]
        if os.path.exists("borednomore3_downloader.py"):
            return [sys.executable, "borednomore3_downloader.py"]
        return ["borednomore3-downloader"]

    def run_cli(self, flag):
        """Run CLI command and show output."""
        def exec_cli():
            cmd = self.get_backend_command() + [flag]
            print(f"\n[*] Executing: {' '.join(cmd)}\n")
            try:
                res = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
                if res.stdout:
                    print(res.stdout)
                if res.stderr:
                    print(f"[ERROR] {res.stderr}")
            except subprocess.TimeoutExpired:
                print("[ERROR] Command timed out")
            except Exception as e:
                print(f"[ERROR] {e}")
        threading.Thread(target=exec_cli, daemon=True).start()

    def select_dir(self):
        """Open directory selection dialog."""
        d = filedialog.askdirectory(initialdir=self.path_var.get())
        if d:
            self.path_var.set(d)
            print(f" Directory set to: {d}")

    def stop_mission(self):
        """Signal to stop the download."""
        self.is_running = False
        print("\n Stopping download... (finishing current image)")

    def start(self):
        """Start the download process."""
        self.is_running = True
        for w in self.input_widgets:
            w.configure(state="disabled")
        self.stop_btn.configure(state="normal")
        threading.Thread(target=self.run_logic, daemon=True).start()

    def run_logic(self):
        """Main download logic running in thread."""
        try:
            ow = self.ow_entry.get()
            selected_sources = [s for s, v in self.sources_vars.items() if v.get()]

            if not selected_sources:
                print(" Error: No sources selected! Please select at least one source.")
                self.after(0, self.reset_ui)
                return

            downloader = BoredNoMore3Downloader(
                directory=self.path_var.get(),
                search=self.search_entry.get(),
                count=int(self.count_slider.get()),
                sources=selected_sources,
                start_from=int(ow) if ow.isdigit() else None,
                deep=self.deep_var.get(),
                random_src=self.rand_var.get()
            )

            # Run source by source, checking stop signal
            for s in downloader.sources:
                if not self.is_running or downloader.total_saved >= downloader.target_count:
                    break
                if s in downloader.available_sources:
                    downloader.available_sources[s]()

            if not self.is_running:
                print("\n Download stopped by user")

            print(f"\n{'='*80}")
            print(f" Session Complete!")
            print(f" Images saved: {downloader.total_saved}")
            print(f"{'='*80}")

        except Exception as e:
            print(f"\n Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.after(0, self.reset_ui)

    def reset_ui(self):
        """Reset UI to initial state."""
        for w in self.input_widgets:
            w.configure(state="normal")
        self.stop_btn.configure(state="disabled")
        self.is_running = False

    def quit_app(self):
        """Safely exit the application."""
        if messagebox.askokcancel("Quit", "Do you really want to exit BoredNoMore3?"):
            self.is_running = False
            self.destroy()
            sys.exit(0)

if __name__ == "__main__":
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("blue")
    app = BoredNoMoreGUI()
    app.mainloop()



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/lib/borednomore3_transitions.py ===

#!/usr/bin/env python3
"""
BoredNoMore3 Transitions
Main transition module that combines all functionality
"""

# Import core functionality
from .borednomore3_transitions_core import (
    apply_transition,
    apply_transition_with_direction,
    TRANSITIONS
)

# Import metadata
from .borednomore3_transitions_meta import (
    get_transition_metadata,
    get_all_metadata,
    get_transitions_by_category,
    get_category_name,
    TRANSITION_CATEGORIES
)

# Re-export everything for easy access
__all__ = [
    'apply_transition',
    'apply_transition_with_direction',
    'get_transition_metadata',
    'get_all_metadata',
    'get_transitions_by_category',
    'get_category_name',
    'TRANSITIONS',
    'TRANSITION_CATEGORIES'
]



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/lib/borednomore3_transitions_core.py ===

#!/usr/bin/env python3
"""
Core Transition Functions for borednomore3
Main transition logic with in/out support
"""

import os
import tempfile
import subprocess
import time
import math
from PIL import Image, ImageFilter, ImageDraw, ImageOps

# Import metadata
from .borednomore3_transitions_meta import get_transition_metadata

def resize_and_crop(image_path, width, height):
    """Resize image to fit screen"""
    img = Image.open(image_path)
    return img.resize((width, height), Image.Resampling.LANCZOS)

def create_temp_dir(prefix="transition_"):
    """Create temporary directory for frames"""
    return tempfile.mkdtemp(prefix=prefix)

def cleanup_temp_dir(temp_dir):
    """Clean up temporary directory"""
    try:
        for file in os.listdir(temp_dir):
            os.remove(os.path.join(temp_dir, file))
        os.rmdir(temp_dir)
    except:
        pass

def set_wallpaper_default(image_path):
    """Default wallpaper setter"""
    try:
        subprocess.run([
            "pcmanfm-qt", "--set-wallpaper", image_path,
            "--wallpaper-mode=stretch", "--desktop"
        ], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except:
        try:
            subprocess.run(["feh", "--bg-fill", image_path], 
                         check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except:
            pass

def apply_frame_sequence(frame_paths, set_wallpaper_func, should_exit_func, frame_delay=0.001):
    """Apply sequence of frames as transition"""
    for frame_path in frame_paths:
        if should_exit_func():
            break
        set_wallpaper_func(frame_path)
        time.sleep(frame_delay)

def apply_transition_with_direction(transition_id, old_image, new_image, width, height, 
                                   frames=10, speed=0.001, direction="in", keep_image=False):
    """
    Apply transition with proper direction handling
    
    direction options:
    - "in": New image appears (default)
    - "out": Old image disappears
    - "cross": Crossfade (both directions)
    - "out_in": First out then in
    """
    
    metadata = get_transition_metadata(transition_id)
    
    # Map transition ID to function
    if transition_id == 1:
        return _transition_fade(old_image, new_image, width, height, frames, direction, keep_image)
    elif transition_id == 2:
        return _transition_fade_out_in(old_image, new_image, width, height, frames, direction)
    elif transition_id == 3:
        return _transition_crossfade_blur(old_image, new_image, width, height, frames, direction)
    # Add all other transitions...
    
    # Default fallback
    return _transition_fade(old_image, new_image, width, height, frames, "in", keep_image)

# Transition 1: Basic Fade
def _transition_fade(old_image, new_image, width, height, frames=10, direction="in", keep_image=True):
    """Transition 1: Basic crossfade"""
    temp_dir = create_temp_dir("fade_")
    frame_paths = []
    
    old_img = resize_and_crop(old_image, width, height)
    new_img = resize_and_crop(new_image, width, height)
    
    if direction == "in":
        # New image fades in
        for i in range(frames):
            alpha = i / (frames - 1) if frames > 1 else 1.0
            blended = Image.blend(old_img, new_img, alpha)
            
            frame_path = os.path.join(temp_dir, f"frame_{i:03d}.jpg")
            blended.save(frame_path, quality=95)
            frame_paths.append(frame_path)
    
    elif direction == "out":
        # Old image fades out (reverse of fade in)
        for i in range(frames):
            alpha = 1.0 - (i / (frames - 1) if frames > 1 else 1.0)
            blended = Image.blend(old_img, new_img, alpha)
            
            frame_path = os.path.join(temp_dir, f"frame_{i:03d}.jpg")
            blended.save(frame_path, quality=95)
            frame_paths.append(frame_path)
    
    elif direction == "cross" or keep_image:
        # Crossfade (both visible during transition)
        for i in range(frames):
            alpha = i / (frames - 1) if frames > 1 else 1.0
            blended = Image.blend(old_img, new_img, alpha)
            
            frame_path = os.path.join(temp_dir, f"frame_{i:03d}.jpg")
            blended.save(frame_path, quality=95)
            frame_paths.append(frame_path)
    
    return frame_paths, temp_dir

# Transition 2: Fade Out then In
def _transition_fade_out_in(old_image, new_image, width, height, frames=10, direction="out_in"):
    """Transition 2: Fade out then in"""
    temp_dir = create_temp_dir("fade_out_in_")
    frame_paths = []
    
    old_img = resize_and_crop(old_image, width, height)
    new_img = resize_and_crop(new_image, width, height)
    black = Image.new('RGB', (width, height), (0, 0, 0))
    
    half_frames = max(1, frames // 2)
    
    if direction == "out_in" or direction == "in":
        # Fade out to black
        for i in range(half_frames):
            alpha = i / (half_frames - 1) if half_frames > 1 else 1.0
            blended = Image.blend(old_img, black, alpha)
            
            frame_path = os.path.join(temp_dir, f"frame_out_{i:03d}.jpg")
            blended.save(frame_path, quality=95)
            frame_paths.append(frame_path)
        
        # Fade in from black
        for i in range(half_frames):
            alpha = i / (half_frames - 1) if half_frames > 1 else 1.0
            blended = Image.blend(black, new_img, alpha)
            
            frame_path = os.path.join(temp_dir, f"frame_in_{i:03d}.jpg")
            blended.save(frame_path, quality=95)
            frame_paths.append(frame_path)
    
    elif direction == "out":
        # Just fade out to black (no fade in)
        for i in range(frames):
            alpha = i / (frames - 1) if frames > 1 else 1.0
            blended = Image.blend(old_img, black, alpha)
            
            frame_path = os.path.join(temp_dir, f"frame_{i:03d}.jpg")
            blended.save(frame_path, quality=95)
            frame_paths.append(frame_path)
    
    return frame_paths, temp_dir

# Transition 3: Crossfade with Blur
def _transition_crossfade_blur(old_image, new_image, width, height, frames=10, direction="cross"):
    """Transition 3: Crossfade with blur"""
    temp_dir = create_temp_dir("blur_fade_")
    frame_paths = []
    
    old_img = resize_and_crop(old_image, width, height)
    new_img = resize_and_crop(new_image, width, height)
    
    for i in range(frames):
        alpha = i / (frames - 1) if frames > 1 else 1.0
        
        # Apply blur based on transition progress
        blur_amount = int(5 * (1 - abs(alpha - 0.5) * 2))  # More blur in middle
        if blur_amount > 0:
            old_blurred = old_img.filter(ImageFilter.GaussianBlur(blur_amount))
            new_blurred = new_img.filter(ImageFilter.GaussianBlur(blur_amount))
            blended = Image.blend(old_blurred, new_blurred, alpha)
        else:
            blended = Image.blend(old_img, new_img, alpha)
        
        frame_path = os.path.join(temp_dir, f"frame_{i:03d}.jpg")
        blended.save(frame_path, quality=95)
        frame_paths.append(frame_path)
    
    return frame_paths, temp_dir

# Add more transition functions for all 75 transitions...
# Each should handle direction parameter appropriately

def apply_transition(old_wallpaper, new_wallpaper, transition_num,
                    screen_width, screen_height, frames, speed,
                    set_wallpaper_func, should_exit_func,
                    keep_image=False):
    """
    Main transition application function
    Compatible with original borednomore3.py
    """
    # Get metadata to determine default direction
    metadata = get_transition_metadata(transition_num)
    
    # Determine direction based on metadata and keep_image
    if keep_image:
        direction = "cross"
    elif metadata.get("has_in_out", False):
        direction = metadata.get("default_direction", "in")
    else:
        direction = "in"
    
    try:
        # Generate frames
        frame_paths, temp_dir = apply_transition_with_direction(
            transition_num, old_wallpaper, new_wallpaper,
            screen_width, screen_height, frames,
            direction, keep_image
        )
        
        # Display frames
        apply_frame_sequence(frame_paths, set_wallpaper_func, should_exit_func, speed)
        
        # Cleanup
        cleanup_temp_dir(temp_dir)
        
    except Exception as e:
        print(f"Error during transition {transition_num}: {e}")
        # Fallback to immediate change
        set_wallpaper_func(new_wallpaper)

# For backward compatibility
TRANSITIONS = {
    1: "Fade",
    2: "Fade Out then In",
    3: "Crossfade with Blur",
    4: "Fade with Zoom",
    5: "Color Fade",
    6: "Soft Fade",
    7: "Fade with Brightness",
    8: "Fade with Contrast",
    9: "Fade with Saturation",
    10: "Fade with Hue Shift",
    11: "Fade with Vignette",
    # Continue for all 75...
}



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/lib/borednomore3_transitions_meta.py ===

#!/usr/bin/env python3
"""
Transition Metadata for borednomore3
Contains metadata for all transitions
"""

# Transition metadata structure
TRANSITION_META = {
    # Fade Transitions (1-11)
    1: {
        "name": "Fade",
        "short_desc": "Simple crossfade between images",
        "long_desc": "Classic crossfade where one image smoothly transitions into another.",
        "version": "1.0",
        "category": "fade",
        "has_in_out": True,
        "default_direction": "in"
    },
    2: {
        "name": "Fade Out then In",
        "short_desc": "Old fades out completely before new fades in",
        "long_desc": "Old image fades to black, then new image fades in from black.",
        "version": "1.0",
        "category": "fade",
        "has_in_out": True,
        "default_direction": "out_in"
    },
    3: {
        "name": "Crossfade with Blur",
        "short_desc": "Crossfade with blur effect during transition",
        "long_desc": "Images blur during crossfade for a dreamy effect.",
        "version": "1.0",
        "category": "fade",
        "has_in_out": False,
        "default_direction": "cross"
    },
    4: {
        "name": "Fade with Zoom",
        "short_desc": "Fade combined with slight zoom effect",
        "long_desc": "Crossfade with simultaneous zoom in/out effect.",
        "version": "1.0",
        "category": "fade",
        "has_in_out": True,
        "default_direction": "in"
    },
    5: {
        "name": "Color Fade",
        "short_desc": "Fade through color channels",
        "long_desc": "Fade through RGB channels separately for color transition effect.",
        "version": "1.0",
        "category": "fade",
        "has_in_out": False,
        "default_direction": "cross"
    },
    
    # Slide Transitions (12-35)
    12: {
        "name": "Slide Right",
        "short_desc": "New image slides in from right",
        "long_desc": "New image slides from right to left, covering old image.",
        "version": "1.0",
        "category": "slide",
        "has_in_out": True,
        "default_direction": "in"
    },
    13: {
        "name": "Slide Left",
        "short_desc": "New image slides in from left",
        "long_desc": "New image slides from left to right, covering old image.",
        "version": "1.0",
        "category": "slide",
        "has_in_out": True,
        "default_direction": "in"
    },
    
    # Continue for all 75 transitions...
}

# Categories mapping
TRANSITION_CATEGORIES = {
    "fade": "Fade & Opacity Effects (1-11)",
    "slide": "Slide & Wipe Effects (12-35)",
    "zoom": "Zoom & Scale Effects (36-45)",
    "reveal": "Reveal & Uncover Effects (46-55)",
    "special": "Special & Complex Effects (56-75)"
}

def get_transition_metadata(transition_id):
    """Get metadata for a specific transition"""
    return TRANSITION_META.get(transition_id, {
        "name": f"Transition {transition_id}",
        "short_desc": "No description available",
        "long_desc": "This transition has no detailed description.",
        "version": "1.0",
        "category": "unknown",
        "has_in_out": False,
        "default_direction": "in"
    })

def get_all_metadata():
    """Get all transition metadata"""
    return TRANSITION_META

def get_transitions_by_category(category):
    """Get all transitions in a category"""
    return {tid: meta for tid, meta in TRANSITION_META.items() 
            if meta.get("category") == category}

def get_category_name(category):
    """Get display name for category"""
    return TRANSITION_CATEGORIES.get(category, category)



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/lib/borednomore3_downloader_engines.py ===

#!/usr/bin/env python3
"""
BoredNoMore3 Downloader Engines
Search engine implementations for wallpaper downloading

This module contains all the download engine implementations for various
wallpaper sources. Each engine is responsible for fetching images from
a specific source.

Author: Nepamuceno Bartolo
Version: 0.6.0
"""

import time
import random
import requests
import re
from urllib.parse import quote, unquote
import json
from bs4 import BeautifulSoup

# ============================================================================
# API KEYS CONFIGURATION
# ============================================================================
# Add your API keys here for better results and higher rate limits

PEXELS_API_KEY = ""  # Get from: https://www.pexels.com/api/
PIXABAY_API_KEY = ""  # Get from: https://pixabay.com/api/docs/
WALLHAVEN_API_KEY = ""  # Get from: https://wallhaven.cc/settings/account

# ============================================================================
# USER AGENT
# ============================================================================
USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'


class DownloadEngines:
    """Collection of download engines for various wallpaper sources"""
    
    def __init__(self, downloader):
        """Initialize with reference to main downloader instance"""
        self.downloader = downloader
        self.headers = {
            'User-Agent': USER_AGENT,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        }
    
    @property
    def count(self):
        """Get download count from downloader (handles different attribute names)."""
        return getattr(self.downloader, 'count', getattr(self.downloader, 'target_count', 10))
    
    @property
    def deep_search(self):
        """Get deep search flag from downloader (handles different attribute names)."""
        return getattr(self.downloader, 'deep_search', getattr(self.downloader, 'deep', False))
    
    # ========================================================================
    # UNSPLASH
    # ========================================================================
    
    def download_from_unsplash(self):
        """Download wallpapers from Unsplash"""
        print(f"\n[Unsplash] Searching for '{self.downloader.search}'...")
        
        try:
            downloaded_count = 0
            attempts = self.count * 3  # Try more to account for failures
            
            # Use the source.unsplash.com endpoint which doesn't require API key
            search_encoded = quote(self.downloader.search)
            
            for i in range(attempts):
                if downloaded_count >= self.count:
                    break
                
                # Add random parameters to get different images
                random_seed = random.randint(1, 999999)
                url = f"https://source.unsplash.com/1920x1080/?{search_encoded}"
                
                # Add cache-busting parameters
                params = {
                    'sig': random_seed,
                    't': int(time.time() * 1000)
                }
                
                try:
                    response = requests.get(url, params=params, headers=self.headers, 
                                          timeout=15, allow_redirects=True)
                    
                    if response.status_code == 200 and len(response.content) > 50000:
                        # Check if it's actually an image
                        if response.headers.get('content-type', '').startswith('image/'):
                            if self.downloader.save_image(response.content, "Unsplash"):
                                downloaded_count += 1
                    
                    time.sleep(0.8)  # Rate limiting
                except Exception as e:
                    print(f"  âš ï¸  Attempt {i+1} failed: {str(e)[:50]}")
                    time.sleep(1)
                    continue
            
            print(f"[Unsplash] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Unsplash] Error: {e}")
    
    # ========================================================================
    # PEXELS
    # ========================================================================
    
    def download_from_pexels(self):
        """Download wallpapers from Pexels"""
        print(f"\n[Pexels] Searching for '{self.downloader.search}'...")
        
        try:
            downloaded_count = 0
            
            if PEXELS_API_KEY:
                # Use official API
                pages = 5 if self.deep_search else 2
                
                for page in range(1, pages + 1):
                    if downloaded_count >= self.count:
                        break
                    
                    url = "https://api.pexels.com/v1/search"
                    headers = {**self.headers, 'Authorization': PEXELS_API_KEY}
                    params = {
                        'query': self.downloader.search,
                        'per_page': 80,
                        'page': page
                    }
                    
                    try:
                        response = requests.get(url, headers=headers, params=params, timeout=15)
                        if response.status_code == 200:
                            data = response.json()
                            if 'photos' in data:
                                for photo in data['photos']:
                                    if downloaded_count >= self.count:
                                        break
                                    
                                    img_url = photo.get('src', {}).get('original')
                                    if img_url:
                                        try:
                                            img_response = requests.get(img_url, timeout=15)
                                            if img_response.status_code == 200:
                                                if self.downloader.save_image(img_response.content, "Pexels"):
                                                    downloaded_count += 1
                                            time.sleep(0.3)
                                        except Exception:
                                            continue
                        time.sleep(1)
                    except Exception as e:
                        print(f"  âš ï¸  Error with Pexels API: {e}")
                        continue
            else:
                # Scraping method - search Pexels website
                print("  â„¹ï¸  No API key - using web scraping (add API key for better results)")
                
                search_encoded = quote(self.downloader.search)
                page = 1
                attempts = 0
                max_attempts = self.count * 3
                
                while downloaded_count < self.count and attempts < max_attempts:
                    attempts += 1
                    url = f"https://www.pexels.com/search/{search_encoded}/?page={page}"
                    
                    try:
                        response = requests.get(url, headers=self.headers, timeout=15)
                        if response.status_code == 200:
                            # Find image URLs in the page
                            # Pexels uses specific patterns for image URLs
                            img_patterns = [
                                r'https://images\.pexels\.com/photos/\d+/[^"]+\.jpeg\?[^"]*w=1920',
                                r'data-big-src="(https://images\.pexels\.com/photos/[^"]+)"',
                                r'srcset="([^"]*images\.pexels\.com/photos/[^"]*\d+w)"'
                            ]
                            
                            img_urls = []
                            for pattern in img_patterns:
                                matches = re.findall(pattern, response.text)
                                img_urls.extend(matches)
                            
                            # Get unique URLs and filter for large images
                            img_urls = list(set(img_urls))
                            img_urls = [url for url in img_urls if '1920' in url or '1280' in url]
                            
                            if img_urls:
                                for img_url in img_urls:
                                    if downloaded_count >= self.count:
                                        break
                                    
                                    try:
                                        # Clean URL
                                        img_url = img_url.split()[0] if ' ' in img_url else img_url
                                        
                                        img_response = requests.get(img_url, headers=self.headers, timeout=15)
                                        if img_response.status_code == 200 and len(img_response.content) > 50000:
                                            if self.downloader.save_image(img_response.content, "Pexels"):
                                                downloaded_count += 1
                                        time.sleep(0.5)
                                    except Exception as e:
                                        continue
                            
                            page += 1
                            time.sleep(2)  # Rate limiting for scraping
                        else:
                            break
                    except Exception as e:
                        print(f"  âš ï¸  Scraping error: {str(e)[:50]}")
                        break
            
            print(f"[Pexels] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Pexels] Error: {e}")
    
    # ========================================================================
    # PIXABAY
    # ========================================================================
    
    def download_from_pixabay(self):
        """Download wallpapers from Pixabay"""
        print(f"\n[Pixabay] Searching for '{self.downloader.search}'...")
        
        try:
            downloaded_count = 0
            
            if PIXABAY_API_KEY:
                # Use official API
                pages = 5 if self.deep_search else 2
                
                for page in range(1, pages + 1):
                    if downloaded_count >= self.count:
                        break
                    
                    url = "https://pixabay.com/api/"
                    params = {
                        'key': PIXABAY_API_KEY,
                        'q': self.downloader.search,
                        'image_type': 'photo',
                        'per_page': 200,
                        'page': page
                    }
                    
                    try:
                        response = requests.get(url, params=params, timeout=15)
                        if response.status_code == 200:
                            data = response.json()
                            if 'hits' in data:
                                for hit in data['hits']:
                                    if downloaded_count >= self.count:
                                        break
                                    
                                    img_url = hit.get('largeImageURL') or hit.get('webformatURL')
                                    if img_url:
                                        try:
                                            img_response = requests.get(img_url, timeout=15)
                                            if img_response.status_code == 200:
                                                if self.downloader.save_image(img_response.content, "Pixabay"):
                                                    downloaded_count += 1
                                            time.sleep(0.3)
                                        except Exception:
                                            continue
                        time.sleep(1)
                    except Exception as e:
                        print(f"  âš ï¸  Error with Pixabay API: {e}")
                        continue
            else:
                # Scraping method
                print("  â„¹ï¸  No API key - using web scraping (add API key for better results)")
                
                search_encoded = quote(self.downloader.search)
                page = 1
                attempts = 0
                max_attempts = self.count * 3
                
                while downloaded_count < self.count and attempts < max_attempts:
                    attempts += 1
                    url = f"https://pixabay.com/images/search/{search_encoded}/?pagi={page}"
                    
                    try:
                        response = requests.get(url, headers=self.headers, timeout=15)
                        if response.status_code == 200:
                            # Find image URLs
                            img_patterns = [
                                r'https://pixabay\.com/get/[^"]+_1280\.jpg',
                                r'https://pixabay\.com/get/[^"]+_1920\.jpg',
                                r'data-lazy="(https://cdn\.pixabay\.com/[^"]+)"'
                            ]
                            
                            img_urls = []
                            for pattern in img_patterns:
                                matches = re.findall(pattern, response.text)
                                img_urls.extend(matches)
                            
                            img_urls = list(set(img_urls))
                            
                            if img_urls:
                                for img_url in img_urls:
                                    if downloaded_count >= self.count:
                                        break
                                    
                                    try:
                                        img_response = requests.get(img_url, headers=self.headers, timeout=15)
                                        if img_response.status_code == 200 and len(img_response.content) > 50000:
                                            if self.downloader.save_image(img_response.content, "Pixabay"):
                                                downloaded_count += 1
                                        time.sleep(0.5)
                                    except Exception:
                                        continue
                            
                            page += 1
                            time.sleep(2)
                        else:
                            break
                    except Exception as e:
                        print(f"  âš ï¸  Scraping error: {str(e)[:50]}")
                        break
            
            print(f"[Pixabay] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Pixabay] Error: {e}")
    
    # ========================================================================
    # LOREM PICSUM
    # ========================================================================
    
    def download_from_picsum(self):
        """Download wallpapers from Lorem Picsum"""
        print(f"\n[Lorem Picsum] Downloading random wallpapers...")
        
        try:
            downloaded_count = 0
            
            for i in range(self.count * 2):
                if downloaded_count >= self.count:
                    break
                
                photo_id = random.randint(1, 1084)  # Picsum has ~1084 photos
                url = f"https://picsum.photos/id/{photo_id}/1920/1080.jpg"
                
                try:
                    response = requests.get(url, timeout=15, allow_redirects=True)
                    if response.status_code == 200 and len(response.content) > 50000:
                        if self.downloader.save_image(response.content, "Picsum"):
                            downloaded_count += 1
                    time.sleep(0.3)
                except Exception:
                    continue
            
            print(f"[Picsum] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Picsum] Error: {e}")
    
    # ========================================================================
    # WALLHAVEN
    # ========================================================================
    
    def download_from_wallhaven(self):
        """Download wallpapers from Wallhaven"""
        print(f"\n[Wallhaven] Searching for '{self.downloader.search}'...")
        
        try:
            downloaded_count = 0
            pages = 3 if self.deep_search else 2
            
            for page in range(1, pages + 1):
                if downloaded_count >= self.count:
                    break
                
                url = "https://wallhaven.cc/api/v1/search"
                
                params = {
                    'q': self.downloader.search,
                    'page': page,
                    'sorting': 'relevance',
                    'atleast': '1920x1080',
                    'purity': '100'  # SFW only
                }
                
                if WALLHAVEN_API_KEY:
                    params['apikey'] = WALLHAVEN_API_KEY
                
                try:
                    response = requests.get(url, params=params, headers=self.headers, timeout=15)
                    
                    if response.status_code == 200:
                        data = response.json()
                        
                        if 'data' in data and len(data['data']) > 0:
                            for item in data['data']:
                                if downloaded_count >= self.count:
                                    break
                                
                                img_url = item.get('path')
                                if img_url:
                                    try:
                                        img_response = requests.get(img_url, headers=self.headers, timeout=15)
                                        if img_response.status_code == 200 and len(img_response.content) > 50000:
                                            if self.downloader.save_image(img_response.content, "Wallhaven"):
                                                downloaded_count += 1
                                        time.sleep(0.5)
                                    except Exception as e:
                                        continue
                        else:
                            print(f"  â„¹ï¸  No results found for '{self.downloader.search}'")
                            break
                    
                    time.sleep(1.5)  # Rate limiting
                except Exception as e:
                    print(f"  âš ï¸  Error with Wallhaven API: {str(e)[:50]}")
                    continue
            
            print(f"[Wallhaven] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Wallhaven] Error: {e}")
    
    # ========================================================================
    # GOOGLE IMAGES
    # ========================================================================
    
    def download_from_google(self):
        """Download wallpapers from Google Images via scraping"""
        print(f"\n[Google Images] Searching for '{self.downloader.search}'...")
        
        try:
            downloaded_count = 0
            search_encoded = quote(self.downloader.search + ' wallpaper')
            
            # Google Images search with size filter
            url = f"https://www.google.com/search?q={search_encoded}&tbm=isch&tbs=isz:l"
            
            try:
                response = requests.get(url, headers=self.headers, timeout=15)
                
                if response.status_code == 200:
                    # Multiple patterns to find images
                    patterns = [
                        r'"(https?://[^"]+\.(?:jpg|jpeg|png))"',
                        r'https?://[^\s"<>]+\.(?:jpg|jpeg|png)',
                        r'"ou":"(https?://[^"]+)"'
                    ]
                    
                    all_urls = []
                    for pattern in patterns:
                        matches = re.findall(pattern, response.text)
                        all_urls.extend(matches)
                    
                    # Deduplicate and filter
                    all_urls = list(set(all_urls))
                    filtered_urls = [
                        url for url in all_urls 
                        if 'gstatic' not in url.lower() 
                        and 'google' not in url.lower()
                        and 'encrypted' not in url.lower()
                        and len(url) < 500  # Skip data URIs
                    ]
                    
                    print(f"  Found {len(filtered_urls)} potential images")
                    
                    for img_url in filtered_urls:
                        if downloaded_count >= self.count:
                            break
                        
                        try:
                            # Decode URL if needed
                            img_url = unquote(img_url)
                            
                            img_response = requests.get(img_url, headers=self.headers, timeout=10)
                            if (img_response.status_code == 200 and 
                                len(img_response.content) > 50000 and
                                img_response.headers.get('content-type', '').startswith('image/')):
                                
                                if self.downloader.save_image(img_response.content, "Google"):
                                    downloaded_count += 1
                            
                            time.sleep(0.7)
                        except Exception:
                            continue
                
            except Exception as e:
                print(f"  âš ï¸  Error scraping Google: {str(e)[:50]}")
            
            print(f"[Google Images] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Google Images] Error: {e}")
    
    # ========================================================================
    # BING IMAGES
    # ========================================================================
    
    def download_from_bing(self):
        """Download wallpapers from Bing Images via scraping"""
        print(f"\n[Bing Images] Searching for '{self.downloader.search}'...")
        
        try:
            downloaded_count = 0
            search_encoded = quote(self.downloader.search + ' wallpaper')
            
            # Bing Images search with size filter
            url = f"https://www.bing.com/images/search?q={search_encoded}&qft=+filterui:imagesize-large&FORM=IRFLTR"
            
            try:
                response = requests.get(url, headers=self.headers, timeout=15)
                
                if response.status_code == 200:
                    # Bing-specific patterns
                    patterns = [
                        r'murl&quot;:&quot;(https?://[^&]+?\.(?:jpg|jpeg|png))',
                        r'"murl":"(https?://[^"]+\.(?:jpg|jpeg|png))"',
                        r'mediaurl=([^&]+\.(?:jpg|jpeg|png))'
                    ]
                    
                    all_urls = []
                    for pattern in patterns:
                        matches = re.findall(pattern, response.text)
                        all_urls.extend(matches)
                    
                    # Deduplicate
                    all_urls = list(set(all_urls))
                    
                    # Filter out thumbnails
                    filtered_urls = [
                        url for url in all_urls 
                        if 'th?id' not in url.lower() 
                        and 'thumbnail' not in url.lower()
                    ]
                    
                    print(f"  Found {len(filtered_urls)} potential images")
                    
                    for img_url in filtered_urls:
                        if downloaded_count >= self.count:
                            break
                        
                        try:
                            # Decode HTML entities
                            img_url = img_url.replace('&amp;', '&')
                            img_url = unquote(img_url)
                            
                            img_response = requests.get(img_url, headers=self.headers, timeout=10)
                            if (img_response.status_code == 200 and 
                                len(img_response.content) > 30000 and
                                img_response.headers.get('content-type', '').startswith('image/')):
                                
                                if self.downloader.save_image(img_response.content, "Bing"):
                                    downloaded_count += 1
                            
                            time.sleep(0.5)
                        except Exception:
                            continue
                
            except Exception as e:
                print(f"  âš ï¸  Error scraping Bing: {str(e)[:50]}")
            
            print(f"[Bing Images] Downloaded {downloaded_count} images")
        except Exception as e:
            print(f"[Bing Images] Error: {e}")



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/conf/borednomore3.list ===

# BoredNoMore3 Wallpaper Pattern Configuration File
# =================================================
#
# PURPOSE:
# Defines file patterns for automatic wallpaper discovery. Each pattern
# matches wallpaper files in the directory specified in borednomore3.conf
# or via the --directory command-line argument.
#
# USAGE:
# 1. Copy this file to 'borednomore3.list' in ${CONF_DIR}/
# 2. Uncomment or add patterns below to match your wallpaper collection
# 3. Save the file and run borednomore3 with --wallpaper-list option
#
# FILE LOCATION:
# Default: ${CONF_DIR}/borednomore3.list
# When running from backend/: ../conf/borednomore3.list
#
# PATTERN SYNTAX:
# - One pattern per line
# - Lines starting with # are comments
# - Empty lines are ignored
# - Standard glob pattern matching (*, ?, [])
# - Patterns are relative to wallpaper directory
# - Order matters: earlier matches appear first in rotation
#
# FALLBACK BEHAVIOR:
# If this file is missing, empty, or contains no valid patterns,
# the following defaults are used:
#   *.jpg, *.png, *.jpeg, *.webp
#
# COMMAND-LINE INTEGRATION:
# Use with: borednomore3 --wallpaper-list borednomore3.list
# Or specify custom file: borednomore3 --wallpaper-list custom.list

# SECTION 1: Standard Image Formats
# ==================================

# JPEG Images (Most Common Format)
*.jpg
*.jpeg

# PNG Images (Supports Transparency)
*.png

# WebP Images (Modern Compression)
*.webp

# SECTION 2: Extended Format Support
# ===================================
# Uncomment lines below to enable additional formats

# BMP Images (Uncompressed)
# *.bmp

# TIFF Images (High Quality/Print)
# *.tiff
# *.tif

# GIF Images (Animated/Static)
# *.gif

# SECTION 3: Thematic Pattern Examples
# =====================================
# Use these as templates for organizing wallpaper collections

# Nature Themes
# nature_*.jpg
# landscape_*.png
# forest-*.jpg
# mountain_*.*

# Abstract/Art Themes  
# abstract_*.jpg
# art_*.png
# pattern_*.*

# Technology/Cyberpunk
# cyberpunk_*.jpg
# tech_*.png
# neon_*.*

# Minimalist Themes
# minimal_*.jpg
# simple_*.png
# white_*.*

# SECTION 4: Structured Naming Conventions
# =========================================
# For organized collections with numbered sequences

# Numbered Sequences (5 digits)
# wallpaper_[0-9][0-9][0-9][0-9][0-9].jpg
# bg_[0-9][0-9][0-9][0-9].png

# Categorized Sequences
# nature_[0-9][0-9].jpg
# abstract_[0-9][0-9][0-9].png
# city_[A-Z][0-9][0-9].jpg

# SECTION 5: Quality/Resolution Indicators
# =========================================

# Resolution Tags
# *_4k.*
# *_1080p.*
# *_HD.*
# *_UHD.*

# Quality Indicators
# *_highres.*
# *_hq.*
# *_premium.*

# SECTION 6: Subdirectory Patterns
# =================================
# For wallpapers organized in folder structures
# Requires wallpaper directory to contain these subfolders

# Single Level Subdirectories
# nature/*.jpg
# abstract/*.png
# cities/*.*

# Recursive Matching (All Subdirectories)
# **/*.jpg
# **/*.png

# SECTION 7: Advanced Pattern Examples
# =====================================

# Time-Based Selection
# morning_*.jpg
# day_*.png
# night_*.jpg
# sunset_*.*

# Mood-Based Selection
# calm_*.jpg
# energetic_*.png
# dark_*.*
# bright_*.*

# EXCLUSION PATTERNS (Note: Requires negative logic in separate system)
# To exclude specific patterns, consider organizing files in separate
# directories or using a more advanced file management system.

# FILE METADATA
# =============
# Pattern Specification Version: 1.0
# Compatible with: borednomore3 v0.6.0+
# Last Updated: $(date)
# Author: Nepamuceno
# GitHub: https://github.com/nepamuceno/borednomore3

# TECHNICAL NOTES:
# ================
# 1. Pattern matching uses Python's glob module
# 2. Patterns are case-sensitive on Linux, case-insensitive on Windows
# 3. For recursive patterns (**) Python 3.5+ is required
# 4. Character classes: [abc], [a-z], [0-9], [!abc] (negation)
# 5. Wildcards: * (any characters), ? (single character)
# 6. Pattern order determines file display order in sequential mode
# 7. Duplicate files matching multiple patterns are deduplicated
#
# RELATED FILES:
# - borednomore3.conf: Main configuration settings
# - borednomore3.py: Main application logic
# - documentation/: User guide and API reference



=== /home/deb/borednomore3/borednomore3/debian/src/lxqt/conf/borednomore3.conf ===

# BoredNoMore3 Configuration File
# ===============================
# 
# PURPOSE:
# This configuration file defines persistent settings for the BoredNoMore3
# dynamic wallpaper changer application. Settings here are loaded on startup
# and can be overridden by command-line arguments.
#
# USAGE:
# 1. Copy this file to 'borednomore3.conf' in the same directory
# 2. Modify the values below to suit your preferences
# 3. Run borednomore3 without arguments to use these settings
#
# FILE LOCATION:
# Default: ${CONF_DIR}/borednomore3.conf
# When running from backend/: ../conf/borednomore3.conf
#
# PRECEDENCE:
# 1. Command-line arguments (highest priority)
# 2. This configuration file
# 3. Application defaults (lowest priority)

[settings]
# SECTION: Application Behavior Settings
# ======================================

# Change Interval (seconds)
# -------------------------
# DESCRIPTION: Time between automatic wallpaper changes
# COMMAND-LINE: -i, --interval
# TYPE: Integer
# RANGE: 1 - 86400 (1 second to 24 hours)
# DEFAULT: 300 (5 minutes)
# EXAMPLE: 60 = change every minute
# EXAMPLE: 1800 = change every 30 minutes
interval = 300

# Wallpaper Directory Path
# ------------------------
# DESCRIPTION: Location of wallpaper image files
# COMMAND-LINE: -d, --directory
# TYPE: String (file path)
# FORMAT: Absolute path or path relative to this config file
# DEFAULT: ../wallpapers/ (relative from config location)
# EXAMPLE: /home/user/Pictures/Wallpapers
# EXAMPLE: ../../wallpapers
# REQUIREMENT: Directory must exist and contain image files
directory = ../wallpapers

# Transition Frames Count
# -----------------------
# DESCRIPTION: Number of intermediate frames during transition animations
# COMMAND-LINE: -f, --frames
# TYPE: Integer
# RANGE: 5 - 100
# DEFAULT: 10
# EFFECT: Higher values = smoother animations but slower transitions
# EXAMPLE: 20 = very smooth but slower transition
# EXAMPLE: 5 = fast but choppy transition
frames = 10

# Transition Frame Duration (seconds)
# -----------------------------------
# DESCRIPTION: Display time for each transition frame
# COMMAND-LINE: -s, --speed
# TYPE: Float
# RANGE: 0.0001 - 1.0
# DEFAULT: 0.001
# EFFECT: Lower values = faster transitions
# EXAMPLE: 0.0005 = very fast transition
# EXAMPLE: 0.01 = slow, visible transition steps
speed = 0.001

# SECTION: Transition Selection Settings
# ======================================

# Transition IDs to Use
# ---------------------
# DESCRIPTION: Specific transitions to include in rotation
# COMMAND-LINE: -t, --transitions
# TYPE: String (comma-separated list or ranges)
# FORMAT: Numbers or ranges: "1,5,10-15,23"
# DEFAULT: (empty = use all available transitions)
# AVAILABLE: See TRANSITIONS dictionary in borednomore3_transitions.py
# EXAMPLE: "1,3,5" = use only transitions 1, 3, and 5
# EXAMPLE: "1-10,23" = use transitions 1 through 10 and 23
transitions = 

# Randomize Transition Selection
# ------------------------------
# DESCRIPTION: Whether to select transitions randomly vs sequentially
# COMMAND-LINE: -r, --randomize
# TYPE: Boolean
# VALUES: True, False
# DEFAULT: False
# BEHAVIOR: True = random selection, False = sequential in order
# INTERACTION: When combined with 'transitions' above, randomizes only from specified IDs
randomize = False

# Keep Previous Image During Transition
# -------------------------------------
# DESCRIPTION: Display behavior during transitions
# COMMAND-LINE: -k, --keep-image
# TYPE: Boolean
# VALUES: True, False
# DEFAULT: False
# EFFECT: True = crossfade (both images visible), False = fade (only new image)
# VISUAL: Useful for comparing or previewing wallpapers
keep_image = False

# SECTION: Wallpaper Selection Settings
# =====================================

# Randomize Wallpaper Selection
# -----------------------------
# DESCRIPTION: Wallpaper selection method
# COMMAND-LINE: -w, --randomize-wallpapers
# TYPE: Boolean
# VALUES: True, False
# DEFAULT: False
# BEHAVIOR: True = random selection, False = alphabetical sequential
# NOTE: Independent of transition randomization setting
randomize_wallpapers = False

# SECTION: Integration Settings
# =============================

# GUI Binary Name
# ---------------
# DESCRIPTION: Executable name for GUI integration
# COMMAND-LINE: (Not available - config only)
# TYPE: String
# DEFAULT: borednomore3-gui
# PURPOSE: Used by GUI components to launch configuration interface
# WARNING: Do not modify unless you understand the integration
borednomore3_gui_binary = borednomore3-gui

# FILE METADATA
# =============
# Configuration Format Version: 1.0
# Compatible with: borednomore3 v0.6.0+
# Last Updated: $(date)
# Author: Nepamuceno
# GitHub: https://github.com/nepamuceno/borednomore3

# RELATED FILES:
# - borednomore3.list: Wallpaper file patterns (separate file)
# - borednomore3_transitions.py: Available transition effects
# - documentation/: User guide and technical documentation





[Archivo: /home/deb/borednomore3/borednomore3/debian/src/lxqt/backend/borednomore3.py]
#!/usr/bin/env python3
"""
Dynamic Wallpaper Changer for Lubuntu/LXQt
Changes wallpapers with smooth transitions using OpenCV

Author: Nepamuceno
Email: (hidden)
GitHub: https://github.com/nepamuceno/borednomore3
Version: 0.7.0 - Major refactor with OpenCV, pre-calculated frames, and debug mode
"""

import os
import sys
import time
import random
import glob
import subprocess
import argparse
import configparser
from pathlib import Path

# --- STEP 1: DEFINE BASE DIRECTORIES ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
LIB_DIR = os.path.abspath(os.path.join(SCRIPT_DIR, '..', 'lib'))
TRANS_DIR = os.path.join(LIB_DIR, 'transitions')

# --- STEP 2: DEFINE CONFIG AND WALLPAPER PATHS ---
CONF_DIR = os.path.abspath(os.path.join(SCRIPT_DIR, '..', 'conf'))
WALLPAPERS_DIR = os.path.abspath(os.path.join(SCRIPT_DIR, '..', 'wallpapers'))

# --- STEP 3: UPDATE SYSTEM PATHS ---
if LIB_DIR not in sys.path:
    sys.path.insert(0, LIB_DIR)
if TRANS_DIR not in sys.path:
    sys.path.insert(0, TRANS_DIR)

# --- STEP 4: IMPORT ---
try:
    from borednomore3_transitions import TransitionEngine, get_curated_transitions
except ImportError as e:
    print(f"Error: Could not import borednomore3_transitions from {TRANS_DIR}")
    print(f"Python looked in: {sys.path[:2]}")
    sys.exit(1)

try:
    from PIL import Image
except ImportError:
    print("Error: PIL/Pillow is required.")
    sys.exit(1)

try:
    from pynput import keyboard
except ImportError:
    print("Error: pynput is required.")
    sys.exit(1)

try:
    import cv2
    import numpy as np
except ImportError:
    print("Error: opencv-python (cv2) and numpy are required.")
    sys.exit(1)

VERSION = "0.7.0"
AUTHOR = "Nepamuceno"
EMAIL = "(hidden)"
GITHUB = "https://github.com/nepamuceno/borednomore3"

# Default configuration values
DEFAULT_CONFIG = {
    'interval': 300,
    'directory': WALLPAPERS_DIR,
    'frames': 8,
    'speed': 0,
    'transitions': None,
    'randomize': False,
    'randomize_wallpapers': False,
    'debug': False,
    'borednomore3_gui_binary': 'borednomore3-gui'
}

# Default config file paths
DEFAULT_CONF_FILE = os.path.join(CONF_DIR, 'borednomore3.conf')
DEFAULT_LIST_FILE = os.path.join(CONF_DIR, 'borednomore3.list')


def load_config_file(config_path):
    """Load configuration from file"""
    config = {}
    if not os.path.exists(config_path):
        return config
    
    try:
        parser = configparser.ConfigParser()
        parser.read(config_path)
        
        if 'settings' in parser:
            settings = parser['settings']
            
            if 'interval' in settings:
                config['interval'] = int(settings['interval'])
            if 'directory' in settings:
                dir_path = settings['directory']
                if not os.path.isabs(dir_path):
                    dir_path = os.path.join(os.path.dirname(config_path), dir_path)
                config['directory'] = os.path.abspath(dir_path)
            if 'frames' in settings:
                config['frames'] = int(settings['frames'])
            if 'speed' in settings:
                config['speed'] = float(settings['speed'])
            if 'transitions' in settings:
                config['transitions'] = settings['transitions']
            if 'randomize' in settings:
                config['randomize'] = settings.getboolean('randomize')
            if 'randomize_wallpapers' in settings:
                config['randomize_wallpapers'] = settings.getboolean('randomize_wallpapers')
            if 'debug' in settings:
                config['debug'] = settings.getboolean('debug')
            if 'borednomore3_gui_binary' in settings:
                config['borednomore3_gui_binary'] = settings['borednomore3_gui_binary']
        
        print(f"[*] Loaded configuration from: {config_path}")
        return config
    except Exception as e:
        print(f"[WARNING] Error loading config file: {e}")
        return config


class BoredNoMore3:
    """Main wallpaper changer application"""
    
    def __init__(self, interval=300, directory=None, frames=10, fade_speed=0.001, 
                 transitions=None, randomize=False, randomize_wallpapers=False,
                 wallpaper_patterns=None, debug=False):
        
        self.debug = debug
        
        # Initialize true random seed once
        random.seed(int(time.time() * 1000000) % (2**32))
        
        if directory is None:
            self.directory = WALLPAPERS_DIR
        else:
            self.directory = os.path.abspath(os.path.expanduser(directory))
            
        self.interval = interval
        self.transition_frames = frames
        self.fade_speed = fade_speed
        self.wallpapers = []
        self.current_index = -1
        self.should_exit = False
        self.is_transitioning = False
        self.randomize_wallpapers = randomize_wallpapers
        
        # Get screen resolution
        self.screen_width, self.screen_height = self.get_screen_resolution()
        
        # Initialize transition engine
        self.transition_engine = TransitionEngine(
            self.screen_width, 
            self.screen_height,
            debug=self.debug
        )
        
        # Setup transition list
        self.curated = get_curated_transitions()
        if transitions:
            self.transition_list = transitions
        else:
            self.transition_list = list(self.curated.keys())
        
        self.randomize_transitions = randomize
        self.transition_index = 0
        
        # Wallpaper patterns
        self.wallpaper_patterns = wallpaper_patterns if wallpaper_patterns else ["*.jpg", "*.png", "*.jpeg", "*.webp"]

        # Setup keyboard listener
        self.listener = keyboard.Listener(on_press=self.on_key_press)
        self.listener.start()
        
        # Pre-calculated frames cache
        self.next_frames = None
        self.next_wallpaper = None
        self.next_transition_id = None
        
        # Cache fastest wallpaper setter method
        self.wallpaper_setter = self._detect_wallpaper_setter()
    
    def _detect_wallpaper_setter(self):
        """Detect and cache the fastest available wallpaper setter"""
        methods = [
            (["nitrogen", "--help"], lambda p: ["nitrogen", "--set-zoom-fill", p]),
            (["feh", "--version"], lambda p: ["feh", "--bg-fill", p]),
            (["xwallpaper", "--version"], lambda p: ["xwallpaper", "--zoom", p]),
            (["pcmanfm-qt", "--version"], lambda p: ["pcmanfm-qt", "--set-wallpaper", p, "--wallpaper-mode=stretch", "--desktop"]),
            (["gsettings", "help"], lambda p: ["gsettings", "set", "org.gnome.desktop.background", "picture-uri", f"file://{p}"])
        ]
        
        for test_cmd, cmd_builder in methods:
            try:
                subprocess.run(test_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=1)
                self.debug_print(f"Detected wallpaper setter: {test_cmd[0]}")
                return cmd_builder
            except (FileNotFoundError, subprocess.TimeoutExpired):
                continue
        
        self.debug_print("Warning: No wallpaper setter found!")
        return None
    
    def debug_print(self, message):
        """Print debug messages if debug mode is enabled"""
        if self.debug:
            print(f"[DEBUG] {message}")
    
    def on_key_press(self, key):
        try:
            if hasattr(key, 'char') and key.char in ['q', 'Q']:
                if not self.should_exit:
                    print("\n\nExiting gracefully...")
                    self.should_exit = True
                    if hasattr(self, 'listener'):
                        self.listener.stop()
                    sys.exit(0)
        except:
            pass
    
    def get_screen_resolution(self):
        """Detect screen resolution using xrandr"""
        try:
            output = subprocess.check_output(['xrandr'], text=True)
            for line in output.split('\n'):
                if ' connected' in line:
                    parts = line.split()
                    for part in parts:
                        if 'x' in part and part[0].isdigit():
                            resolution = part.split('+')[0]
                            w, h = resolution.split('x')
                            return int(w), int(h)
        except:
            pass
        return 1920, 1080
    
    def load_wallpapers(self):
        """Load wallpaper list from directory"""
        if not os.path.isdir(self.directory):
            print(f"Error: Directory '{self.directory}' does not exist")
            print(f"Please create the directory or specify a different one with --directory")
            sys.exit(1)
        
        self.wallpapers = []
        for pattern in self.wallpaper_patterns:
            full_pattern = os.path.join(self.directory, pattern)
            matched = sorted(glob.glob(full_pattern))
            self.wallpapers.extend(matched)
        
        self.wallpapers = sorted(list(set(self.wallpapers)))
        
        if not self.wallpapers:
            print(f"Error: No files matched the patterns in {self.directory}")
            print(f"Patterns used: {', '.join(self.wallpaper_patterns)}")
            sys.exit(1)
        
        print(f"Loaded {len(self.wallpapers)} wallpapers from {self.directory}")
        if self.debug:
            print(f"Using patterns: {', '.join(self.wallpaper_patterns)}")
    
    def get_current_wallpaper(self):
        """Detect current system wallpaper"""
        try:
            # Try pcmanfm-qt config
            config_path = os.path.expanduser("~/.config/pcmanfm-qt/lxqt/settings.conf")
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    for line in f:
                        if 'Wallpaper=' in line:
                            wallpaper = line.split('=', 1)[1].strip()
                            if os.path.exists(wallpaper):
                                self.debug_print(f"Current wallpaper detected: {wallpaper}")
                                return wallpaper
        except Exception as e:
            self.debug_print(f"Could not detect current wallpaper: {e}")
        
        return None
    
    def set_wallpaper(self, image_path):
        """Set system wallpaper using cached fastest method"""
        if self.wallpaper_setter is None:
            self.debug_print("No wallpaper setter available")
            return
        
        try:
            cmd = self.wallpaper_setter(image_path)
            # Use Popen for non-blocking, faster execution
            subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True
            )
        except Exception as e:
            self.debug_print(f"Error setting wallpaper: {e}")
    
    def get_next_transition(self):
        """Get next transition ID"""
        if self.randomize_transitions:
            return random.choice(self.transition_list)
        else:
            transition = self.transition_list[self.transition_index]
            self.transition_index = (self.transition_index + 1) % len(self.transition_list)
            return transition
    
    def get_next_wallpaper_index(self):
        """Get next wallpaper index"""
        if self.randomize_wallpapers:
            return random.randint(0, len(self.wallpapers) - 1)
        else:
            return (self.current_index + 1) % len(self.wallpapers)
    
    def validate_and_resize_image(self, image_path):
        """Validate if image can be resized to screen resolution"""
        try:
            img = cv2.imread(image_path)
            if img is None:
                self.debug_print(f"Cannot load image: {image_path}")
                return None
            
            # Try to resize
            resized = cv2.resize(img, (self.screen_width, self.screen_height))
            if resized is not None:
                return image_path
            return None
        except Exception as e:
            self.debug_print(f"Error validating image {image_path}: {e}")
            return None
    
    def find_valid_wallpaper(self, start_index):
        """Find next valid wallpaper that can be resized"""
        attempts = 0
        test_index = start_index
        
        while attempts < len(self.wallpapers):
            test_wallpaper = self.wallpapers[test_index]
            if self.validate_and_resize_image(test_wallpaper):
                return test_index, test_wallpaper
            
            # Try next
            if self.randomize_wallpapers:
                test_index = random.randint(0, len(self.wallpapers) - 1)
            else:
                test_index = (test_index + 1) % len(self.wallpapers)
            
            attempts += 1
        
        print("Error: No valid wallpapers found that can be resized")
        sys.exit(1)
    
    def change_wallpaper(self):
        """Change wallpaper with transition"""
        if self.should_exit or self.is_transitioning:
            return
        
        self.is_transitioning = True
        old_index = self.current_index
        
        # Get next wallpaper
        next_idx = self.get_next_wallpaper_index()
        next_idx, new_wallpaper = self.find_valid_wallpaper(next_idx)
        self.current_index = next_idx
        
        # Get transition info
        trans_id = self.get_next_transition()
        trans_info = self.curated[trans_id]
        
        # Print transition info
        print(f"\n{'='*80}")
        print(f"Transition #{trans_id}: {trans_info['name']}")
        print(f"  â†’ {trans_info['short_desc']}")
        print(f"  â†’ Changing to: {os.path.basename(new_wallpaper)}")
        print(f"{'='*80}")
        
        if old_index >= 0:
            old_wallpaper = self.wallpapers[old_index]
            
            self.debug_print(f"Generating {self.transition_frames} frames...")
            
            # Generate transition frames
            frames = self.transition_engine.generate_transition_frames(
                old_wallpaper, new_wallpaper, trans_id, self.transition_frames
            )
            
            if frames:
                self.debug_print(f"Playing {len(frames)} frames at {self.fade_speed}s per frame")
                
                # Play all frames
                for frame_path in frames:
                    if self.should_exit:
                        break
                    self.set_wallpaper(frame_path)
                    if self.fade_speed > 0:
                        time.sleep(self.fade_speed)
                    else:
                        time.sleep(0.016)  # ~60fps
                
                self.debug_print("Transition complete")
        
        # Set final wallpaper
        self.set_wallpaper(new_wallpaper)
        self.is_transitioning = False
    
    def run(self):
        """Main execution loop"""
        print(f"Screen resolution: {self.screen_width}x{self.screen_height}")
        print(f"Transition mode: {'RANDOM' if self.randomize_transitions else 'SEQUENTIAL'}")
        print(f"Wallpaper selection: {'RANDOM' if self.randomize_wallpapers else 'SEQUENTIAL'}")
        print(f"Debug mode: {'Enabled' if self.debug else 'Disabled'}")
        print(f"Using {len(self.transition_list)} transitions")
        
        self.load_wallpapers()
        
        # Initial wallpaper
        self.current_index = 0 if not self.randomize_wallpapers else random.randint(0, len(self.wallpapers) - 1)
        self.set_wallpaper(self.wallpapers[self.current_index])
        print(f"Initial wallpaper: {os.path.basename(self.wallpapers[self.current_index])}")
        
        print(f"\nborednomore3 running. Changing every {self.interval} seconds.")
        print(f"Transition frames: {self.transition_frames}")
        print("\nPress 'q' or 'Q' anywhere to exit immediately.")
        print("Press Ctrl+C to exit.\n")
        
        try:
            while not self.should_exit:
                time.sleep(self.interval)
                if not self.should_exit:
                    self.change_wallpaper()
                    
        except KeyboardInterrupt:
            print("\n\nExiting gracefully...")
            if hasattr(self, 'listener'):
                self.listener.stop()
            sys.exit(0)


def print_help():
    def_interval = DEFAULT_CONFIG['interval']
    def_dir = DEFAULT_CONFIG['directory']
    def_frames = DEFAULT_CONFIG['frames']
    def_speed = DEFAULT_CONFIG['speed']

    help_text = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                 borednomore3 - Dynamic Wallpaper Changer                  â•‘
â•‘                                Version {VERSION}                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DESCRIPTION:
    Changes wallpapers with smooth transitions using OpenCV. Supports random or 
    sequential order for both transitions and wallpaper selection.

USAGE:
    borednomore3 [OPTIONS]

OPTIONS:
    -h, --help                Show this help message and exit
    -v, --version             Show version information
    -c, --credits             Show credits
    --config <path>           Path to a custom .conf file (default: {DEFAULT_CONF_FILE})
    -i, --interval <sec>      Change interval in seconds (default: {def_interval})
    -d, --directory <path>    Directory to search for wallpapers (default: {def_dir})
    -f, --frames <num>        Transition frames (default: {def_frames}, range 5-100)
    -s, --speed <sec>         Seconds per frame (default: {def_speed})
    -t, --transitions <list>  Comma-separated transition IDs (e.g., 1,5,23)
                              When used with -r, randomizes only from this list
    -r, --randomize           RANDOMIZE transitions (default: SEQUENTIAL)
    -w, --randomize-wallpapers RANDOMIZE wallpaper selection (default: SEQUENTIAL)
    -D, --debug               Enable debug output (default: disabled)
    -l, --wallpaper-list <file> Load patterns from file (default: {DEFAULT_LIST_FILE})
    --list-transitions        Show all available transitions in JSON format

CONFIGURATION PRIORITY:
    1. Command-line flags (Highest priority)
    2. Config file settings (--config or auto-detected via -l)
    3. Source code default values (Lowest priority)

PERFORMANCE:
    - Uses OpenCV for fast frame generation
    - Auto-detects fastest wallpaper setter (nitrogen > feh > pcmanfm-qt)
    - True random seed initialization for better randomization

AUTHOR:
    {AUTHOR} - {GITHUB}
"""
    print(help_text)


def print_version():
    print(f"borednomore3 v{VERSION}")


def print_credits():
    print(f"""
borednomore3 v{VERSION}
Author: {AUTHOR}
GitHub: {GITHUB}

A dynamic wallpaper changer with smooth transitions for LXQt/Lubuntu.
Powered by OpenCV for optimal performance.
Enjoy!
""")


def print_transitions_json():
    """Print transitions in JSON format for external programs"""
    import json
    transitions = get_curated_transitions()
    print(json.dumps(transitions, indent=2))


def parse_transitions(transition_str):
    """Parse transition string into list of IDs"""
    try:
        parts = [t.strip() for t in transition_str.split(',')]
        transitions = []
        for part in parts:
            if '-' in part:
                start_str, end_str = part.split('-')
                start, end = int(start_str), int(end_str)
                transitions.extend(range(start, end + 1))
            else:
                transitions.append(int(part))
        
        curated = get_curated_transitions()
        valid_transitions = []
        for t in transitions:
            if t in curated:
                valid_transitions.append(t)
            else:
                print(f"Warning: Transition {t} is not in the library. Skipping.")
        
        if not valid_transitions:
             print("Error: No valid transition IDs provided.")
             sys.exit(1)

        return sorted(set(valid_transitions))
    except ValueError:
        print("Error: -t must be comma-separated numbers or ranges (e.g., 1,5,10-15)")
        sys.exit(1)


def load_wallpaper_patterns(list_file):
    """Load wallpaper patterns from a list file"""
    patterns = []
    if not os.path.exists(list_file):
        return ["*.jpg", "*.png", "*.jpeg", "*.webp"]
    
    try:
        with open(list_file, 'r') as f:
            for line in f:
                line = line.split('#', 1)[0].strip()
                if line:
                    patterns.append(line)
        if not patterns:
            return ["*.jpg", "*.png", "*.jpeg", "*.webp"]
        print(f"Loaded {len(patterns)} wallpaper patterns from {list_file}")
        return patterns
    except Exception as e:
        print(f"Error reading wallpaper list file {list_file}: {e}")
        return ["*.jpg", "*.png", "*.jpeg", "*.webp"]


def main():
    parser = argparse.ArgumentParser(
        description='borednomore3 - Dynamic Wallpaper Changer',
        add_help=False,
        formatter_class=argparse.RawTextHelpFormatter
    )
    
    parser.add_argument('-h', '--help', action='store_true')
    parser.add_argument('-v', '--version', action='store_true')
    parser.add_argument('-c', '--credits', action='store_true')
    parser.add_argument('--config', type=str, default=None)
    parser.add_argument('-i', '--interval', type=int, default=None)
    parser.add_argument('-d', '--directory', type=str, default=None)
    parser.add_argument('-f', '--frames', type=int, default=None)
    parser.add_argument('-s', '--speed', type=float, default=None)
    parser.add_argument('-t', '--transitions', type=str, default=None)
    parser.add_argument('-r', '--randomize', action='store_true')
    parser.add_argument('-w', '--randomize-wallpapers', action='store_true')
    parser.add_argument('-D', '--debug', action='store_true')
    parser.add_argument('-l', '--wallpaper-list', nargs='?', const=DEFAULT_LIST_FILE, 
                       default=None)
    parser.add_argument('--list-transitions', action='store_true',
                       help='Show all available transitions in JSON format')
    
    args = parser.parse_args()
    
    if args.help:
        print_help()
        sys.exit(0)
    if args.version:
        print_version()
        sys.exit(0)
    if args.credits:
        print_credits()
        sys.exit(0)
    if args.list_transitions:
        print_transitions_json()
        sys.exit(0)
    
    # Start with defaults
    config = DEFAULT_CONFIG.copy()

    # Config file selection
    config_file = DEFAULT_CONF_FILE
    
    if args.config:
        config_file = args.config
    elif args.wallpaper_list and args.wallpaper_list != DEFAULT_LIST_FILE:
        potential_conf = os.path.splitext(args.wallpaper_list)[0] + ".conf"
        if os.path.exists(potential_conf):
            config_file = potential_conf

    if os.path.exists(config_file):
        file_config = load_config_file(config_file)
        config.update(file_config)
    
    # Command-line overrides
    if args.interval is not None:
        config['interval'] = args.interval
    if args.directory is not None:
        config['directory'] = args.directory
    if args.frames is not None:
        config['frames'] = args.frames
    if args.speed is not None:
        config['speed'] = args.speed
    if args.transitions is not None:
        config['transitions'] = args.transitions
    if args.randomize:
        config['randomize'] = True
    if args.randomize_wallpapers:
        config['randomize_wallpapers'] = True
    if args.debug:
        config['debug'] = True
    
    # Wallpaper patterns
    list_file = args.wallpaper_list if args.wallpaper_list else DEFAULT_LIST_FILE
    wallpaper_patterns = load_wallpaper_patterns(list_file)
    
    # Validate
    if config['interval'] < 1:
        print("Error: Interval must be >= 1 second")
        sys.exit(1)
    if config['frames'] < 5 or config['frames'] > 100:
        print("Error: Frames must be 5-100")
        sys.exit(1)
    if config['speed'] < 0 or config['speed'] > 1.0:
        print("Error: Speed must be 0-1.0")
        sys.exit(1)
    
    # Parse transitions
    transitions = None
    if config['transitions']:
        transitions = parse_transitions(config['transitions'])
    
    # Start the app
    print(f"borednomore3 v{VERSION}")
    print("=" * 80)
    
    app = BoredNoMore3(
        interval=config['interval'],
        directory=config['directory'],
        frames=config['frames'],
        fade_speed=config['speed'],
        transitions=transitions,
        randomize=config['randomize'],
        randomize_wallpapers=config['randomize_wallpapers'],
        wallpaper_patterns=wallpaper_patterns,
        debug=config['debug']
    )
    app.run()


if __name__ == "__main__":
    main()


[Archivo: /home/deb/borednomore3/borednomore3/debian/src/lxqt/lib/transitions/borednomore3_transitions.py]
"""
borednomore3 Transition Engine
Handles all transition generation and playback using OpenCV

Author: Nepamuceno
Version: 0.7.0
"""

import os
import time
import random
from pathlib import Path
import cv2
import numpy as np

VERSION = "0.7.0"
AUTHOR = "Nepamuceno"

# --- CURATED TRANSITIONS LIBRARY ---
# Only visually impactful transitions (perceptible differences)
CURATED_TRANSITIONS = {
    # === SLIDE TRANSITIONS (Horizontal) ===
    1: {
        "name": "Slide Left",
        "short_desc": "Slides horizontally to the left",
        "long_desc": "Current wallpaper slides out left while new one enters from right",
        "family": "slide",
        "direction": "left",
        "version": VERSION,
        "author": AUTHOR
    },
    2: {
        "name": "Slide Right",
        "short_desc": "Slides horizontally to the right",
        "long_desc": "Current wallpaper slides out right while new one enters from left",
        "family": "slide",
        "direction": "right",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === SLIDE TRANSITIONS (Vertical) ===
    3: {
        "name": "Slide Up",
        "short_desc": "Slides vertically upward",
        "long_desc": "Current wallpaper slides out up while new one enters from bottom",
        "family": "slide",
        "direction": "up",
        "version": VERSION,
        "author": AUTHOR
    },
    4: {
        "name": "Slide Down",
        "short_desc": "Slides vertically downward",
        "long_desc": "Current wallpaper slides out down while new one enters from top",
        "family": "slide",
        "direction": "down",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === SLIDE TRANSITIONS (Diagonal) ===
    5: {
        "name": "Slide Top-Left",
        "short_desc": "Slides diagonally to top-left corner",
        "long_desc": "Current wallpaper exits to top-left while new enters from bottom-right",
        "family": "slide",
        "direction": "top-left",
        "version": VERSION,
        "author": AUTHOR
    },
    6: {
        "name": "Slide Top-Right",
        "short_desc": "Slides diagonally to top-right corner",
        "long_desc": "Current wallpaper exits to top-right while new enters from bottom-left",
        "family": "slide",
        "direction": "top-right",
        "version": VERSION,
        "author": AUTHOR
    },
    7: {
        "name": "Slide Bottom-Left",
        "short_desc": "Slides diagonally to bottom-left corner",
        "long_desc": "Current wallpaper exits to bottom-left while new enters from top-right",
        "family": "slide",
        "direction": "bottom-left",
        "version": VERSION,
        "author": AUTHOR
    },
    8: {
        "name": "Slide Bottom-Right",
        "short_desc": "Slides diagonally to bottom-right corner",
        "long_desc": "Current wallpaper exits to bottom-right while new enters from top-left",
        "family": "slide",
        "direction": "bottom-right",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === ROTATION TRANSITIONS ===
    9: {
        "name": "Rotate Clockwise 90Â°",
        "short_desc": "90Â° clockwise rotation",
        "long_desc": "Current wallpaper rotates 90Â° clockwise revealing new wallpaper",
        "family": "rotate",
        "angle": 90,
        "direction": "cw",
        "version": VERSION,
        "author": AUTHOR
    },
    10: {
        "name": "Rotate Counter-Clockwise 90Â°",
        "short_desc": "90Â° counter-clockwise rotation",
        "long_desc": "Current wallpaper rotates 90Â° counter-clockwise revealing new wallpaper",
        "family": "rotate",
        "angle": 90,
        "direction": "ccw",
        "version": VERSION,
        "author": AUTHOR
    },
    11: {
        "name": "Rotate Clockwise 180Â°",
        "short_desc": "180Â° clockwise spin",
        "long_desc": "Current wallpaper spins 180Â° clockwise to reveal new wallpaper",
        "family": "rotate",
        "angle": 180,
        "direction": "cw",
        "version": VERSION,
        "author": AUTHOR
    },
    12: {
        "name": "Rotate Counter-Clockwise 180Â°",
        "short_desc": "180Â° counter-clockwise spin",
        "long_desc": "Current wallpaper spins 180Â° counter-clockwise to reveal new wallpaper",
        "family": "rotate",
        "angle": 180,
        "direction": "ccw",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === ZOOM TRANSITIONS ===
    13: {
        "name": "Zoom Out",
        "short_desc": "Zooms out to reveal new wallpaper",
        "long_desc": "Current wallpaper zooms out from center while new one appears behind",
        "family": "zoom",
        "direction": "out",
        "version": VERSION,
        "author": AUTHOR
    },
    14: {
        "name": "Zoom In",
        "short_desc": "New wallpaper zooms in from center",
        "long_desc": "New wallpaper zooms in from center covering current wallpaper",
        "family": "zoom",
        "direction": "in",
        "version": VERSION,
        "author": AUTHOR
    },
    15: {
        "name": "Zoom Pulse",
        "short_desc": "Pulsing zoom effect",
        "long_desc": "Current wallpaper pulses with zoom effect transitioning to new one",
        "family": "zoom",
        "direction": "pulse",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === FADE TRANSITIONS ===
    16: {
        "name": "Fade Cross-Dissolve",
        "short_desc": "Classic cross-fade transition",
        "long_desc": "Current wallpaper fades out while new one fades in simultaneously",
        "family": "fade",
        "direction": "cross",
        "version": VERSION,
        "author": AUTHOR
    },
    17: {
        "name": "Fade to Black",
        "short_desc": "Fades through black screen",
        "long_desc": "Current wallpaper fades to black, then new one fades in from black",
        "family": "fade",
        "direction": "black",
        "version": VERSION,
        "author": AUTHOR
    },
    18: {
        "name": "Fade to White",
        "short_desc": "Fades through white screen",
        "long_desc": "Current wallpaper fades to white, then new one fades in from white",
        "family": "fade",
        "direction": "white",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === WIPE TRANSITIONS ===
    19: {
        "name": "Wipe Left",
        "short_desc": "Wipes from right to left",
        "long_desc": "New wallpaper wipes in from right edge pushing current one left",
        "family": "wipe",
        "direction": "left",
        "version": VERSION,
        "author": AUTHOR
    },
    20: {
        "name": "Wipe Right",
        "short_desc": "Wipes from left to right",
        "long_desc": "New wallpaper wipes in from left edge pushing current one right",
        "family": "wipe",
        "direction": "right",
        "version": VERSION,
        "author": AUTHOR
    },
    21: {
        "name": "Wipe Up",
        "short_desc": "Wipes from bottom to top",
        "long_desc": "New wallpaper wipes in from bottom edge pushing current one up",
        "family": "wipe",
        "direction": "up",
        "version": VERSION,
        "author": AUTHOR
    },
    22: {
        "name": "Wipe Down",
        "short_desc": "Wipes from top to bottom",
        "long_desc": "New wallpaper wipes in from top edge pushing current one down",
        "family": "wipe",
        "direction": "down",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === PUSH TRANSITIONS ===
    23: {
        "name": "Push Left",
        "short_desc": "Pushes current wallpaper to the left",
        "long_desc": "New wallpaper pushes current one out to the left",
        "family": "push",
        "direction": "left",
        "version": VERSION,
        "author": AUTHOR
    },
    24: {
        "name": "Push Right",
        "short_desc": "Pushes current wallpaper to the right",
        "long_desc": "New wallpaper pushes current one out to the right",
        "family": "push",
        "direction": "right",
        "version": VERSION,
        "author": AUTHOR
    },
    25: {
        "name": "Push Up",
        "short_desc": "Pushes current wallpaper upward",
        "long_desc": "New wallpaper pushes current one out to the top",
        "family": "push",
        "direction": "up",
        "version": VERSION,
        "author": AUTHOR
    },
    26: {
        "name": "Push Down",
        "short_desc": "Pushes current wallpaper downward",
        "long_desc": "New wallpaper pushes current one out to the bottom",
        "family": "push",
        "direction": "down",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === SPLIT TRANSITIONS ===
    27: {
        "name": "Split Horizontal",
        "short_desc": "Splits horizontally from center",
        "long_desc": "Current wallpaper splits horizontally revealing new one in center",
        "family": "split",
        "direction": "horizontal",
        "version": VERSION,
        "author": AUTHOR
    },
    28: {
        "name": "Split Vertical",
        "short_desc": "Splits vertically from center",
        "long_desc": "Current wallpaper splits vertically revealing new one in center",
        "family": "split",
        "direction": "vertical",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === BOX TRANSITIONS ===
    29: {
        "name": "Box In",
        "short_desc": "Box grows from center outward",
        "long_desc": "New wallpaper appears in expanding box from center",
        "family": "box",
        "direction": "in",
        "version": VERSION,
        "author": AUTHOR
    },
    30: {
        "name": "Box Out",
        "short_desc": "Box shrinks to center",
        "long_desc": "Current wallpaper shrinks in box to center revealing new one",
        "family": "box",
        "direction": "out",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === CIRCLE TRANSITIONS ===
    31: {
        "name": "Circle In",
        "short_desc": "Circle grows from center",
        "long_desc": "New wallpaper appears in expanding circle from center",
        "family": "circle",
        "direction": "in",
        "version": VERSION,
        "author": AUTHOR
    },
    32: {
        "name": "Circle Out",
        "short_desc": "Circle shrinks to center",
        "long_desc": "Current wallpaper visible only in shrinking circle revealing new one",
        "family": "circle",
        "direction": "out",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === PIXELATE TRANSITIONS ===
    33: {
        "name": "Pixelate Dissolve",
        "short_desc": "Dissolves through pixelation",
        "long_desc": "Current wallpaper pixelates and dissolves to new one",
        "family": "pixelate",
        "direction": "dissolve",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === BLUR TRANSITIONS ===
    34: {
        "name": "Blur Transition",
        "short_desc": "Blurs through transition",
        "long_desc": "Current wallpaper blurs out while new one blurs in",
        "family": "blur",
        "direction": "cross",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === FLIP TRANSITIONS ===
    35: {
        "name": "Flip Horizontal",
        "short_desc": "Flips horizontally like a card",
        "long_desc": "Wallpaper flips horizontally revealing new one on back",
        "family": "flip",
        "direction": "horizontal",
        "version": VERSION,
        "author": AUTHOR
    },
    36: {
        "name": "Flip Vertical",
        "short_desc": "Flips vertically like a card",
        "long_desc": "Wallpaper flips vertically revealing new one on back",
        "family": "flip",
        "direction": "vertical",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === DOOR TRANSITIONS ===
    37: {
        "name": "Door Swing Left",
        "short_desc": "Swings open like a door to the left",
        "long_desc": "Current wallpaper swings left like a door revealing new one",
        "family": "door",
        "direction": "left",
        "version": VERSION,
        "author": AUTHOR
    },
    38: {
        "name": "Door Swing Right",
        "short_desc": "Swings open like a door to the right",
        "long_desc": "Current wallpaper swings right like a door revealing new one",
        "family": "door",
        "direction": "right",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === BARN DOOR TRANSITIONS ===
    39: {
        "name": "Barn Doors Horizontal",
        "short_desc": "Opens like barn doors horizontally",
        "long_desc": "Current wallpaper splits in middle and opens like barn doors",
        "family": "barn",
        "direction": "horizontal",
        "version": VERSION,
        "author": AUTHOR
    },
    40: {
        "name": "Barn Doors Vertical",
        "short_desc": "Opens like barn doors vertically",
        "long_desc": "Current wallpaper splits in middle and opens like barn doors vertically",
        "family": "barn",
        "direction": "vertical",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === CORNER TRANSITIONS ===
    41: {
        "name": "Corner Peel Top-Left",
        "short_desc": "Peels from top-left corner",
        "long_desc": "Current wallpaper peels from top-left corner revealing new one",
        "family": "peel",
        "direction": "top-left",
        "version": VERSION,
        "author": AUTHOR
    },
    42: {
        "name": "Corner Peel Top-Right",
        "short_desc": "Peels from top-right corner",
        "long_desc": "Current wallpaper peels from top-right corner revealing new one",
        "family": "peel",
        "direction": "top-right",
        "version": VERSION,
        "author": AUTHOR
    },
    43: {
        "name": "Corner Peel Bottom-Left",
        "short_desc": "Peels from bottom-left corner",
        "long_desc": "Current wallpaper peels from bottom-left corner revealing new one",
        "family": "peel",
        "direction": "bottom-left",
        "version": VERSION,
        "author": AUTHOR
    },
    44: {
        "name": "Corner Peel Bottom-Right",
        "short_desc": "Peels from bottom-right corner",
        "long_desc": "Current wallpaper peels from bottom-right corner revealing new one",
        "family": "peel",
        "direction": "bottom-right",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === WAVE TRANSITIONS ===
    45: {
        "name": "Wave Horizontal",
        "short_desc": "Wave effect horizontally",
        "long_desc": "Current wallpaper waves horizontally transitioning to new one",
        "family": "wave",
        "direction": "horizontal",
        "version": VERSION,
        "author": AUTHOR
    },
    46: {
        "name": "Wave Vertical",
        "short_desc": "Wave effect vertically",
        "long_desc": "Current wallpaper waves vertically transitioning to new one",
        "family": "wave",
        "direction": "vertical",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === SPIRAL TRANSITIONS ===
    47: {
        "name": "Spiral Clockwise",
        "short_desc": "Spirals clockwise from center",
        "long_desc": "New wallpaper spirals in clockwise from center",
        "family": "spiral",
        "direction": "cw",
        "version": VERSION,
        "author": AUTHOR
    },
    48: {
        "name": "Spiral Counter-Clockwise",
        "short_desc": "Spirals counter-clockwise from center",
        "long_desc": "New wallpaper spirals in counter-clockwise from center",
        "family": "spiral",
        "direction": "ccw",
        "version": VERSION,
        "author": AUTHOR
    },
    
    # === CHECKERBOARD TRANSITIONS ===
    49: {
        "name": "Checkerboard",
        "short_desc": "Checkerboard pattern reveal",
        "long_desc": "New wallpaper reveals in checkerboard pattern",
        "family": "checkerboard",
        "direction": "normal",
        "version": VERSION,
        "author": AUTHOR
    },
    50: {
        "name": "Checkerboard Inverse",
        "short_desc": "Inverse checkerboard pattern",
        "long_desc": "New wallpaper reveals in inverse checkerboard pattern",
        "family": "checkerboard",
        "direction": "inverse",
        "version": VERSION,
        "author": AUTHOR
    }
}


def get_curated_transitions():
    """Return the curated transitions dictionary"""
    return CURATED_TRANSITIONS


class TransitionEngine:
    """Handles transition frame generation using OpenCV with proper compositing"""
    
    def __init__(self, screen_width, screen_height, debug=False):
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.debug = debug
        self.tmp_dir = "/tmp/bnm3_frames"
        Path(self.tmp_dir).mkdir(parents=True, exist_ok=True)
    
    def debug_print(self, message):
        """Print debug messages if debug mode is enabled"""
        if self.debug:
            print(f"[TRANSITION DEBUG] {message}")
    
    def prepare_image(self, img_path):
        """Load and resize image to screen resolution"""
        img = cv2.imread(str(img_path))
        if img is None:
            raise ValueError(f"Cannot load image {img_path}")
        return cv2.resize(img, (self.screen_width, self.screen_height), interpolation=cv2.INTER_LANCZOS4)
    
    def composite_images(self, old_img, new_img, old_transform, new_transform, keep_image=False):
        """
        Composite two images with transformations
        
        Args:
            old_img: Current wallpaper (numpy array)
            new_img: New wallpaper (numpy array)
            old_transform: Transformation matrix for old image
            new_transform: Transformation matrix for new image
            keep_image: If True, show new image as background
            
        Returns:
            Composited frame
        """
        w, h = self.screen_width, self.screen_height
        
        # Apply transformations
        old_transformed = cv2.warpAffine(old_img, old_transform, (w, h), 
                                        borderMode=cv2.BORDER_CONSTANT, 
                                        borderValue=(0, 0, 0))
        new_transformed = cv2.warpAffine(new_img, new_transform, (w, h),
                                        borderMode=cv2.BORDER_CONSTANT,
                                        borderValue=(0, 0, 0))
        
        if keep_image:
            # Start with new image as background
            result = new_transformed.copy()
            # Create mask for old image (non-black pixels)
            mask = cv2.cvtColor(old_transformed, cv2.COLOR_BGR2GRAY)
            mask = (mask > 10).astype(np.uint8) * 255
            mask = cv2.merge([mask, mask, mask])
            # Composite old on top where it's not black
            result = np.where(mask > 0, old_transformed, result)
        else:
            # Black background, composite both images
            result = np.zeros((h, w, 3), dtype=np.uint8)
            # Add new image first (background)
            new_mask = cv2.cvtColor(new_transformed, cv2.COLOR_BGR2GRAY)
            new_mask = (new_mask > 10).astype(np.uint8) * 255
            new_mask = cv2.merge([new_mask, new_mask, new_mask])
            result = np.where(new_mask > 0, new_transformed, result)
            # Add old image on top
            old_mask = cv2.cvtColor(old_transformed, cv2.COLOR_BGR2GRAY)
            old_mask = (old_mask > 10).astype(np.uint8) * 255
            old_mask = cv2.merge([old_mask, old_mask, old_mask])
            result = np.where(old_mask > 0, old_transformed, result)
        
        return result
    
    def generate_slide_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate slide transition frames with proper compositing"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            # Calculate offsets for old and new images
            if direction == "left":
                old_dx, old_dy = -int(progress * w), 0
                new_dx, new_dy = w - int(progress * w), 0
            elif direction == "right":
                old_dx, old_dy = int(progress * w), 0
                new_dx, new_dy = -w + int(progress * w), 0
            elif direction == "up":
                old_dx, old_dy = 0, -int(progress * h)
                new_dx, new_dy = 0, h - int(progress * h)
            elif direction == "down":
                old_dx, old_dy = 0, int(progress * h)
                new_dx, new_dy = 0, -h + int(progress * h)
            elif direction == "top-left":
                old_dx, old_dy = -int(progress * w), -int(progress * h)
                new_dx, new_dy = w - int(progress * w), h - int(progress * h)
            elif direction == "top-right":
                old_dx, old_dy = int(progress * w), -int(progress * h)
                new_dx, new_dy = -w + int(progress * w), h - int(progress * h)
            elif direction == "bottom-left":
                old_dx, old_dy = -int(progress * w), int(progress * h)
                new_dx, new_dy = w - int(progress * w), -h + int(progress * h)
            elif direction == "bottom-right":
                old_dx, old_dy = int(progress * w), int(progress * h)
                new_dx, new_dy = -w + int(progress * w), -h + int(progress * h)
            
            # Create transformation matrices
            old_M = np.float32([[1, 0, old_dx], [0, 1, old_dy]])
            new_M = np.float32([[1, 0, new_dx], [0, 1, new_dy]])
            
            # Composite frame
            frame = self.composite_images(old_img, new_img, old_M, new_M, keep_image)
            
            # Save frame
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_rotate_transition(self, old_img, new_img, angle, direction, num_frames, keep_image=False):
        """Generate rotation transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        center = (w // 2, h // 2)
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            # Calculate rotation angle
            if direction == "cw":
                current_angle = progress * angle
            else:  # ccw
                current_angle = -progress * angle
            
            # Old image rotates out
            old_M = cv2.getRotationMatrix2D(center, current_angle, 1.0)
            
            # New image stays in place (or rotates in from opposite direction)
            new_M = cv2.getRotationMatrix2D(center, 0, 1.0)
            
            # For smooth transition, fade in new image
            old_alpha = 1.0 - progress
            new_alpha = progress
            
            old_transformed = cv2.warpAffine(old_img, old_M, (w, h))
            new_transformed = cv2.warpAffine(new_img, new_M, (w, h))
            
            # Blend with alpha
            frame = cv2.addWeighted(old_transformed, old_alpha, new_transformed, new_alpha, 0)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_zoom_transition(self, old_img, new_img, zoom_direction, num_frames, keep_image=False):
        """Generate zoom transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        center = (w // 2, h // 2)
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            if zoom_direction == "out":
                # Old image zooms out
                old_scale = 1.0 - progress
                new_scale = 1.0
                old_alpha = 1.0 - progress
                new_alpha = progress
            elif zoom_direction == "in":
                # New image zooms in
                old_scale = 1.0
                new_scale = progress
                old_alpha = 1.0 - progress
                new_alpha = progress
            else:  # pulse
                old_scale = 1.0 + 0.3 * np.sin(progress * np.pi)
                new_scale = 1.0
                old_alpha = 1.0 - progress
                new_alpha = progress
            
            if old_scale <= 0:
                old_scale = 0.01
            if new_scale <= 0:
                new_scale = 0.01
            
            old_M = cv2.getRotationMatrix2D(center, 0, old_scale)
            old_M[0, 2] += (w / 2) * (1 - old_scale)
            old_M[1, 2] += (h / 2) * (1 - old_scale)
            
            new_M = cv2.getRotationMatrix2D(center, 0, new_scale)
            new_M[0, 2] += (w / 2) * (1 - new_scale)
            new_M[1, 2] += (h / 2) * (1 - new_scale)
            
            old_transformed = cv2.warpAffine(old_img, old_M, (w, h))
            new_transformed = cv2.warpAffine(new_img, new_M, (w, h))
            
            frame = cv2.addWeighted(old_transformed, old_alpha, new_transformed, new_alpha, 0)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_fade_transition(self, old_img, new_img, fade_type, num_frames, keep_image=False):
        """Generate fade transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            if fade_type == "cross":
                # Simple cross-dissolve
                frame = cv2.addWeighted(old_img, 1.0 - progress, new_img, progress, 0)
            elif fade_type == "black":
                # Fade through black
                if progress < 0.5:
                    # Fade old to black
                    black = np.zeros_like(old_img)
                    frame = cv2.addWeighted(old_img, 1.0 - (progress * 2), black, progress * 2, 0)
                else:
                    # Fade from black to new
                    black = np.zeros_like(new_img)
                    frame = cv2.addWeighted(black, 1.0 - ((progress - 0.5) * 2), new_img, (progress - 0.5) * 2, 0)
            else:  # white
                # Fade through white
                if progress < 0.5:
                    white = np.full_like(old_img, 255)
                    frame = cv2.addWeighted(old_img, 1.0 - (progress * 2), white, progress * 2, 0)
                else:
                    white = np.full_like(new_img, 255)
                    frame = cv2.addWeighted(white, 1.0 - ((progress - 0.5) * 2), new_img, (progress - 0.5) * 2, 0)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_wipe_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate wipe transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = old_img.copy()
            
            if direction == "left":
                x_cut = int((1.0 - progress) * w)
                frame[:, x_cut:] = new_img[:, x_cut:]
            elif direction == "right":
                x_cut = int(progress * w)
                frame[:, :x_cut] = new_img[:, :x_cut]
            elif direction == "up":
                y_cut = int((1.0 - progress) * h)
                frame[y_cut:, :] = new_img[y_cut:, :]
            elif direction == "down":
                y_cut = int(progress * h)
                frame[:y_cut, :] = new_img[:y_cut, :]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_push_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate push transition (both images move together)"""
        return self.generate_slide_transition(old_img, new_img, direction, num_frames, keep_image)
    
    def generate_split_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate split transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = new_img.copy()
            
            if direction == "horizontal":
                # Split horizontally from center
                half_h = h // 2
                offset = int((1.0 - progress) * half_h)
                frame[:half_h - offset, :] = old_img[:half_h - offset, :]
                frame[half_h + offset:, :] = old_img[half_h + offset:, :]
            else:  # vertical
                # Split vertically from center
                half_w = w // 2
                offset = int((1.0 - progress) * half_w)
                frame[:, :half_w - offset] = old_img[:, :half_w - offset]
                frame[:, half_w + offset:] = old_img[:, half_w + offset:]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_box_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate box transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            if direction == "in":
                # Box grows from center
                frame = old_img.copy()
                box_w = int(progress * w)
                box_h = int(progress * h)
                x1 = (w - box_w) // 2
                y1 = (h - box_h) // 2
                x2 = x1 + box_w
                y2 = y1 + box_h
                frame[y1:y2, x1:x2] = new_img[y1:y2, x1:x2]
            else:  # out
                # Box shrinks to center
                frame = new_img.copy()
                box_w = int((1.0 - progress) * w)
                box_h = int((1.0 - progress) * h)
                x1 = (w - box_w) // 2
                y1 = (h - box_h) // 2
                x2 = x1 + box_w
                y2 = y1 + box_h
                frame[y1:y2, x1:x2] = old_img[y1:y2, x1:x2]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_circle_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate circle transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        center = (w // 2, h // 2)
        max_radius = int(np.sqrt(w**2 + h**2) / 2)
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            if direction == "in":
                radius = int(progress * max_radius)
                frame = old_img.copy()
                mask = np.zeros((h, w), dtype=np.uint8)
                cv2.circle(mask, center, radius, 255, -1)
                mask = cv2.merge([mask, mask, mask])
                frame = np.where(mask > 0, new_img, old_img)
            else:  # out
                radius = int((1.0 - progress) * max_radius)
                frame = new_img.copy()
                mask = np.zeros((h, w), dtype=np.uint8)
                cv2.circle(mask, center, radius, 255, -1)
                mask = cv2.merge([mask, mask, mask])
                frame = np.where(mask > 0, old_img, new_img)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_pixelate_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate pixelate transition frames"""
        frames = []
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            # Pixelate factor (more pixelated in the middle)
            if progress < 0.5:
                pixel_factor = int(1 + (progress * 2) * 20)
            else:
                pixel_factor = int(1 + ((1.0 - progress) * 2) * 20)
            
            # Pixelate based on progress
            if progress < 0.5:
                base = old_img.copy()
            else:
                base = new_img.copy()
            
            h, w = base.shape[:2]
            temp = cv2.resize(base, (w // pixel_factor, h // pixel_factor), interpolation=cv2.INTER_LINEAR)
            frame = cv2.resize(temp, (w, h), interpolation=cv2.INTER_NEAREST)
            
            # Blend with target
            if progress < 0.5:
                frame = cv2.addWeighted(frame, 1.0, new_img, progress * 2, 0)
            else:
                frame = cv2.addWeighted(old_img, 1.0 - ((progress - 0.5) * 2), frame, 1.0, 0)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_blur_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate blur transition frames"""
        frames = []
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            # Blur strength (max in middle)
            if progress < 0.5:
                blur_amount = int(1 + (progress * 2) * 30)
                alpha = 1.0 - (progress * 2)
                base = old_img
            else:
                blur_amount = int(1 + ((1.0 - progress) * 2) * 30)
                alpha = (progress - 0.5) * 2
                base = new_img
            
            if blur_amount % 2 == 0:
                blur_amount += 1
            
            blurred = cv2.GaussianBlur(base, (blur_amount, blur_amount), 0)
            
            # Crossfade
            if progress < 0.5:
                frame = cv2.addWeighted(blurred, 1.0, new_img, progress * 2, 0)
            else:
                frame = cv2.addWeighted(old_img, 1.0 - alpha, blurred, 1.0, 0)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_flip_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate 3D flip transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            
            # 3D flip effect using perspective transform
            if direction == "horizontal":
                # Horizontal flip
                scale_x = abs(np.cos(progress * np.pi))
                if progress < 0.5:
                    base = old_img
                else:
                    base = cv2.flip(new_img, 1)  # Flip new image horizontally
                
                M = np.float32([[scale_x, 0, w * (1 - scale_x) / 2], [0, 1, 0]])
            else:  # vertical
                scale_y = abs(np.cos(progress * np.pi))
                if progress < 0.5:
                    base = old_img
                else:
                    base = cv2.flip(new_img, 0)  # Flip new image vertically
                
                M = np.float32([[1, 0, 0], [0, scale_y, h * (1 - scale_y) / 2]])
            
            frame = cv2.warpAffine(base, M, (w, h))
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_door_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate door swing transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = new_img.copy()
            
            # Door swing effect using perspective
            swing_width = int(w * (1.0 - progress))
            
            if direction == "left":
                # Door swings from left edge
                if swing_width > 0:
                    door_part = old_img[:, :swing_width]
                    # Perspective scale
                    scale = 1.0 - progress * 0.5
                    new_h = int(h * scale)
                    if new_h > 0:
                        resized = cv2.resize(door_part, (swing_width, new_h))
                        y_offset = (h - new_h) // 2
                        frame[y_offset:y_offset+new_h, :swing_width] = resized
            else:  # right
                # Door swings from right edge
                if swing_width > 0:
                    door_part = old_img[:, -swing_width:]
                    scale = 1.0 - progress * 0.5
                    new_h = int(h * scale)
                    if new_h > 0:
                        resized = cv2.resize(door_part, (swing_width, new_h))
                        y_offset = (h - new_h) // 2
                        frame[y_offset:y_offset+new_h, -swing_width:] = resized
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_barn_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate barn door transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = new_img.copy()
            
            if direction == "horizontal":
                # Horizontal barn doors
                door_width = int((w // 2) * (1.0 - progress))
                if door_width > 0:
                    frame[:, :door_width] = old_img[:, :door_width]
                    frame[:, -door_width:] = old_img[:, -door_width:]
            else:  # vertical
                door_height = int((h // 2) * (1.0 - progress))
                if door_height > 0:
                    frame[:door_height, :] = old_img[:door_height, :]
                    frame[-door_height:, :] = old_img[-door_height:, :]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_peel_transition(self, old_img, new_img, corner, num_frames, keep_image=False):
        """Generate corner peel transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = new_img.copy()
            
            # Calculate peel area
            peel_w = int(w * (1.0 - progress))
            peel_h = int(h * (1.0 - progress))
            
            if corner == "top-left":
                if peel_w > 0 and peel_h > 0:
                    frame[:peel_h, :peel_w] = old_img[:peel_h, :peel_w]
            elif corner == "top-right":
                if peel_w > 0 and peel_h > 0:
                    frame[:peel_h, -peel_w:] = old_img[:peel_h, -peel_w:]
            elif corner == "bottom-left":
                if peel_w > 0 and peel_h > 0:
                    frame[-peel_h:, :peel_w] = old_img[-peel_h:, :peel_w]
            else:  # bottom-right
                if peel_w > 0 and peel_h > 0:
                    frame[-peel_h:, -peel_w:] = old_img[-peel_h:, -peel_w:]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_wave_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate wave transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = old_img.copy()
            
            for y in range(h):
                if direction == "horizontal":
                    # Horizontal wave
                    wave_offset = int(20 * np.sin((y / h * 10 + progress * 5) * np.pi))
                    cut_x = int(progress * w) + wave_offset
                    if 0 <= cut_x < w:
                        frame[y, :cut_x] = new_img[y, :cut_x]
                else:  # vertical
                    # Vertical wave
                    wave_offset = int(20 * np.sin((y / h * 10 + progress * 5) * np.pi))
                    cut_y = int(progress * h)
                    if cut_y < h:
                        frame[cut_y:, :] = new_img[cut_y:, :]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_spiral_transition(self, old_img, new_img, direction, num_frames, keep_image=False):
        """Generate spiral transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        center = (w // 2, h // 2)
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = old_img.copy()
            
            # Create spiral mask
            mask = np.zeros((h, w), dtype=np.uint8)
            max_radius = int(np.sqrt(w**2 + h**2) / 2)
            
            for radius in range(0, int(progress * max_radius), 2):
                if direction == "cw":
                    angle_range = np.linspace(0, progress * 4 * np.pi, 100)
                else:  # ccw
                    angle_range = np.linspace(0, -progress * 4 * np.pi, 100)
                
                for angle in angle_range:
                    r = radius
                    x = int(center[0] + r * np.cos(angle))
                    y = int(center[1] + r * np.sin(angle))
                    if 0 <= x < w and 0 <= y < h:
                        cv2.circle(mask, (x, y), 3, 255, -1)
            
            mask = cv2.merge([mask, mask, mask])
            frame = np.where(mask > 0, new_img, old_img)
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_checkerboard_transition(self, old_img, new_img, pattern_type, num_frames, keep_image=False):
        """Generate checkerboard transition frames"""
        frames = []
        w, h = self.screen_width, self.screen_height
        checker_size = 40
        
        for i in range(num_frames):
            progress = i / max(num_frames - 1, 1)
            frame = old_img.copy()
            
            for y in range(0, h, checker_size):
                for x in range(0, w, checker_size):
                    checker_row = y // checker_size
                    checker_col = x // checker_size
                    
                    if pattern_type == "normal":
                        is_checker = (checker_row + checker_col) % 2 == 0
                    else:  # inverse
                        is_checker = (checker_row + checker_col) % 2 == 1
                    
                    # Random reveal based on progress
                    reveal_threshold = progress + random.random() * 0.1
                    
                    if is_checker and reveal_threshold > 0.5:
                        y2 = min(y + checker_size, h)
                        x2 = min(x + checker_size, w)
                        frame[y:y2, x:x2] = new_img[y:y2, x:x2]
            
            frame_path = f"{self.tmp_dir}/frame_{i:04d}.jpg"
            cv2.imwrite(frame_path, frame, [cv2.IMWRITE_JPEG_QUALITY, 95])
            frames.append(frame_path)
        
        return frames
    
    def generate_transition_frames(self, old_img, new_img, trans_id, total_frames, keep_image=False):
        """
        Generate all frames for a transition with proper compositing
        
        Args:
            old_img: Path to current wallpaper
            new_img: Path to next wallpaper
            trans_id: Transition ID from CURATED_TRANSITIONS
            total_frames: Total number of frames to generate
            keep_image: Whether to keep new image visible as background
            
        Returns:
            List of frame paths
        """
        if trans_id not in CURATED_TRANSITIONS:
            self.debug_print(f"Invalid transition ID {trans_id}, using random")
            trans_id = random.choice(list(CURATED_TRANSITIONS.keys()))
        
        transition = CURATED_TRANSITIONS[trans_id]
        
        self.debug_print(f"Transition #{trans_id}: {transition['name']}")
        self.debug_print(f"  {transition['short_desc']}")
        self.debug_print(f"  Keep image mode: {keep_image}")
        
        # Prepare images
        self.debug_print("Loading and resizing images...")
        old_img_prepared = self.prepare_image(old_img)
        new_img_prepared = self.prepare_image(new_img)
        
        # Generate frames based on family
        family = transition['family']
        direction = transition.get('direction', '')
        
        self.debug_print(f"Generating {total_frames} frames for family '{family}'")
        
        if family == "slide":
            frames = self.generate_slide_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "rotate":
            angle = transition.get('angle', 90)
            frames = self.generate_rotate_transition(old_img_prepared, new_img_prepared, angle, direction, total_frames, keep_image)
        elif family == "zoom":
            frames = self.generate_zoom_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "fade":
            frames = self.generate_fade_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "wipe":
            frames = self.generate_wipe_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "push":
            frames = self.generate_push_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "split":
            frames = self.generate_split_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "box":
            frames = self.generate_box_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "circle":
            frames = self.generate_circle_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "pixelate":
            frames = self.generate_pixelate_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "blur":
            frames = self.generate_blur_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "flip":
            frames = self.generate_flip_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "door":
            frames = self.generate_door_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "barn":
            frames = self.generate_barn_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "peel":
            frames = self.generate_peel_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "wave":
            frames = self.generate_wave_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "spiral":
            frames = self.generate_spiral_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        elif family == "checkerboard":
            frames = self.generate_checkerboard_transition(old_img_prepared, new_img_prepared, direction, total_frames, keep_image)
        else:
            self.debug_print(f"Unknown family '{family}', using fade")
            frames = self.generate_fade_transition(old_img_prepared, new_img_prepared, "cross", total_frames, keep_image)
        
        self.debug_print(f"Generated {len(frames)} total frames")
        
        return frames
    
    def cleanup_frames(self):
        """Clean up temporary frame files"""
        try:
            for file in Path(self.tmp_dir).glob("*.jpg"):
                file.unlink()
            self.debug_print("Cleaned up temporary frames")
        except Exception as e:
            self.debug_print(f"Error cleaning up frames: {e}")


def print_transition_library():
    """Print all available transitions with metadata"""
    print("\n" + "="*80)
    print("CURATED TRANSITION LIBRARY")
    print("="*80)
    
    families = {}
    for tid, trans in CURATED_TRANSITIONS.items():
        family = trans['family']
        if family not in families:
            families[family] = []
        families[family].append((tid, trans))
    
    for family, transitions in sorted(families.items()):
        print(f"\n### {family.upper()} TRANSITIONS ###")
        for tid, trans in sorted(transitions):
            print(f"  [{tid:3d}] {trans['name']}")
            print(f"        {trans['short_desc']}")
    
    print(f"\n{'='*80}")
    print(f"Total: {len(CURATED_TRANSITIONS)} curated transitions across {len(families)} families")
    print(f"{'='*80}\n")


# Global export for main program
if __name__ == "__main__":
    print_transition_library()
